<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API reference · BSeries.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link rel="canonical" href="https://ranocha.github.io/BSeries.jl/stable/api_reference/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">BSeries.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../tutorials/bseries_basics/">B-series basics</a></li><li><a class="tocitem" href="../tutorials/bseries_creation/">Creating B-series</a></li><li><a class="tocitem" href="../tutorials/modified_equations/">Modified equations</a></li><li><a class="tocitem" href="../tutorials/modifying_integrators/">Modifying integrators</a></li><li><a class="tocitem" href="../tutorials/symbolic_computations/">Symbolic computations</a></li></ul></li><li><a class="tocitem" href="../benchmarks/">Benchmarks</a></li><li class="is-active"><a class="tocitem" href>API reference</a><ul class="internal"><li><a class="tocitem" href="#BSeries.jl-API"><span>BSeries.jl API</span></a></li><li><a class="tocitem" href="#RootedTrees.jl-API"><span>RootedTrees.jl API</span></a></li></ul></li><li><a class="tocitem" href="../contributing/">Contributing</a></li><li><a class="tocitem" href="../license/">License</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>API reference</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>API reference</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/ranocha/BSeries.jl/blob/main/docs/src/api_reference.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="API-reference"><a class="docs-heading-anchor" href="#API-reference">API reference</a><a id="API-reference-1"></a><a class="docs-heading-anchor-permalink" href="#API-reference" title="Permalink"></a></h1><h2 id="BSeries.jl-API"><a class="docs-heading-anchor" href="#BSeries.jl-API">BSeries.jl API</a><a id="BSeries.jl-API-1"></a><a class="docs-heading-anchor-permalink" href="#BSeries.jl-API" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="BSeries.BSeries" href="#BSeries.BSeries"><code>BSeries.BSeries</code></a> — <span class="docstring-category">Module</span></header><section><div><p><strong>BSeries</strong></p><p><a href="https://ranocha.de/BSeries.jl/stable"><img src="https://img.shields.io/badge/docs-stable-blue.svg" alt="Docs-stable"/></a> <a href="https://ranocha.de/BSeries.jl/dev"><img src="https://img.shields.io/badge/docs-dev-blue.svg" alt="Docs-dev"/></a> <a href="https://github.com/ranocha/BSeries.jl/actions?query=workflow%3ACI"><img src="https://github.com/ranocha/BSeries.jl/workflows/CI/badge.svg" alt="Build Status"/></a> <a href="https://coveralls.io/github/ranocha/BSeries.jl?branch=main"><img src="https://coveralls.io/repos/github/ranocha/BSeries.jl/badge.svg?branch=main" alt="Coveralls"/></a> <a href="https://codecov.io/gh/ranocha/BSeries.jl"><img src="https://codecov.io/gh/ranocha/BSeries.jl/branch/main/graph/badge.svg" alt="Codecov"/></a> <a href="https://opensource.org/licenses/MIT"><img src="https://img.shields.io/badge/License-MIT-success.svg" alt="License: MIT"/></a> <a href="https://doi.org/10.5281/zenodo.5534602"><img src="https://zenodo.org/badge/DOI/10.5281/zenodo.5534602.svg" alt="DOI"/></a></p><p>A collection of functionality around <a href="https://en.wikipedia.org/wiki/Butcher_group">B-series</a> in <a href="https://julialang.org/">Julia</a>. See</p><ul><li>Philippe Chartier, Ernst Hairer, Gilles Vilmart (2010) Algebraic Structures of B-series. Foundations of Computational Mathematics <a href="https://doi.org/10.1007/s10208-010-9065-1">DOI: 10.1007/s10208-010-9065-1</a></li></ul><p><strong>API Documentation</strong></p><p>The API of <a href="https://github.com/ranocha/BSeries.jl">BSeries.jl</a> is documented in the <a href="https://ranocha.de/BSeries.jl/stable">online documentation</a>. Information on each function is available in their docstrings.</p><p>BSeries.jl re-exports everything from <a href="https://github.com/SciML/RootedTrees.jl">RootedTrees.jl</a>. However, if you rely on functionality from that package, you should also include it explicitly in your project dependencies to track breaking changes, since the version numbers of RootedTrees.jl and BSeries.jl are not necessarily synchronized.</p><p>The main API of BSeries.jl consists of the following components.</p><ul><li>B-series behave like <code>AbstractDict</code>s mapping <code>RootedTree</code>s to coefficients.</li><li>The B-series of time integration methods such as Runge-Kutta methods can be constructed by the function <code>bseries</code>.</li><li>Vector space operations (addition/subtraction and multiplication by scalars) are available.</li><li>The algebraic structures of the composition law and the substitution law are implemented via <code>compose</code> and <code>substitute</code>.</li><li>Backward error analysis can be performed via <code>modified_equation</code>s and <code>modifying_integrator</code>s.</li></ul><p>Please consult the documentation or the docstrings for further information.</p><p>Please note that B-series analysis is most conveniently applied to the  autonomous form of ordinary differential equations (ODEs). Thus, BSeries.jl and RootedTrees.jl usually assume that time integration methods give the same result, independent of whether an ODE is written in an autonomous or a  non-autonomous form. For Runge-Kutta methods, this means that the usual row-sum assumption is used.</p><p><strong>Referencing</strong></p><p>If you use <a href="https://github.com/ranocha/BSeries.jl">BSeries.jl</a> for your research, please cite it using the bibtex entry</p><pre><code class="language-bibtex hljs">@online{ketcheson2021computing,
  title={Computing with {B}-series},
  author={Ketcheson, David I and Ranocha, Hendrik},
  year={2021},
  month={11},
  eprint={2111.11680},
  eprinttype={arXiv},
  eprintclass={math.NA}
}</code></pre><p>In addition, you can also refer to BSeries.jl directly as</p><pre><code class="language-bibtex hljs">@misc{ranocha2021bseries,
  title={{BSeries.jl}: {C}omputing with {B}-series in {J}ulia},
  author={Ranocha, Hendrik and Ketcheson, David I},
  year={2021},
  month={09},
  howpublished={\url{https://github.com/ranocha/BSeries.jl}},
  doi={10.5281/zenodo.5534602}
}</code></pre><p><strong>License and contributing</strong></p><p>This project is licensed under the MIT license (see <a href="LICENSE.md">LICENSE.md</a>). Since it is an open-source project, we are very happy to accept contributions from the community. Please refer to <a href="CONTRIBUTING.md">CONTRIBUTING.md</a> for more details.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ranocha/BSeries.jl/blob/807b3423609dc007f342d4b606fd4ea6cdf2726a/src/BSeries.jl#L3-L92">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BSeries.ExactSolution" href="#BSeries.ExactSolution"><code>BSeries.ExactSolution</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ExactSolution{V}()</code></pre><p>Lazy representation of the B-series of the exact solution of an ordinary differential equation using coefficients of type at least as representative as <code>V</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ranocha/BSeries.jl/blob/807b3423609dc007f342d4b606fd4ea6cdf2726a/src/BSeries.jl#L204-L210">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BSeries.ExactSolution-Tuple{Any}" href="#BSeries.ExactSolution-Tuple{Any}"><code>BSeries.ExactSolution</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ExactSolution(series_integrator)</code></pre><p>A representation of the B-series of the exact solution of an ODE using the same type of coefficients as the B-series <code>series_integrator</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ranocha/BSeries.jl/blob/807b3423609dc007f342d4b606fd4ea6cdf2726a/src/BSeries.jl#L243-L248">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BSeries.MultirateInfinitesimalSplitMethod" href="#BSeries.MultirateInfinitesimalSplitMethod"><code>BSeries.MultirateInfinitesimalSplitMethod</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">MultirateInfinitesimalSplitMethod(A, D, G, c)</code></pre><p><strong>References</strong></p><ul><li>Knoth, Oswald, and Joerg Wensch. &quot;Generalized split-explicit Runge-Kutta methods for the compressible Euler equations&quot;. Monthly Weather Review 142, no. 5 (2014): 2067-2081. <a href="https://doi.org/10.1175/MWR-D-13-00068.1">DOI: 10.1175/MWR-D-13-00068.1</a></li></ul><div class="admonition is-warning"><header class="admonition-header">Experimental code</header><div class="admonition-body"><p>This code is considered to be experimental at the moment and can change any time.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ranocha/BSeries.jl/blob/807b3423609dc007f342d4b606fd4ea6cdf2726a/src/BSeries.jl#L543-L557">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BSeries.TruncatedBSeries" href="#BSeries.TruncatedBSeries"><code>BSeries.TruncatedBSeries</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">TruncatedBSeries</code></pre><p>A struct that can describe B-series of both numerical integration methods (where the coefficient of the empty tree is unity) and right-hand sides of an ordinary differential equation and perturbations thereof (where the coefficient of the empty tree is zero) up to a prescribed <a href="#RootedTrees.order-Tuple{TruncatedBSeries}"><code>order</code></a>.</p><p>Generally, this kind of <code>struct</code> should be constructed via <a href="#BSeries.bseries"><code>bseries</code></a> or one of the other functions returning a B-series, e.g., <a href="#BSeries.modified_equation-NTuple{4, Any}"><code>modified_equation</code></a> or <a href="#BSeries.modifying_integrator-NTuple{4, Any}"><code>modifying_integrator</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ranocha/BSeries.jl/blob/807b3423609dc007f342d4b606fd4ea6cdf2726a/src/BSeries.jl#L48-L59">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BSeries.bseries" href="#BSeries.bseries"><code>BSeries.bseries</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">bseries(f::Function, order, iterator_type=RootedTreeIterator)</code></pre><p>Return a truncated B-series up to the specified <code>order</code> with coefficients determined by <code>f</code>. The type of rooted trees is determined by the <code>iterator_type</code>, which can be <code>RootedTreeIterator</code> or <code>BicoloredRootedTreeIterator</code>. Calling <code>f(t, series)</code> needs to return the coefficient of the rooted tree <code>t</code> of the desired series in a type-stable manner. For the empty tree, <code>f</code> is called as <code>f(t, nothing)</code>. Otherwise, the series constructed so far is passed as second argument, allowing one to access values of lower-order trees.</p><div class="admonition is-info"><header class="admonition-header">Normalization by elementary differentials</header><div class="admonition-body"><p>The coefficients of the B-series returned by this method need to be multiplied by a power of the time step divided by the <code>symmetry</code> of the rooted tree and multiplied by the corresponding elementary differential of the input vector field <span>$f$</span>. See also <a href="#BSeries.evaluate"><code>evaluate</code></a>.</p></div></div><p><strong>Examples</strong></p><p>The B-series of the average vector field (AVF) method is given by <span>$b(.) = 1$</span> and <span>$b([t_1, ..., t_n]) = b(t_1)...b(t_n) / (n + 1)$</span>, see</p><ul><li>Elena Celledoni, Robert I. McLachlan, David I. McLaren, Brynjulf Owren, G. Reinout W. Quispel, and William M. Wright. &quot;Energy-preserving runge-kutta methods.&quot; ESAIM: Mathematical Modelling and Numerical Analysis 43, no. 4 (2009): 645-649. <a href="https://doi.org/10.1051/m2an/2009020">DOI: 10.1051/m2an/2009020</a></li></ul><p>We can generate this as follows.</p><pre><code class="language-julia-repl hljs">julia&gt; series = bseries(3) do t, series
           if order(t) in (0, 1)
               return 1 // 1
           else
               v = 1 // 1
               n = 0
               for subtree in SubtreeIterator(t)
                   v *= series[subtree]
                   n += 1
               end
               return v / (n + 1)
           end
       end
TruncatedBSeries{RootedTree{Int64, Vector{Int64}}, Rational{Int64}} with 5 entries:
  RootedTree{Int64}: Int64[]   =&gt; 1//1
  RootedTree{Int64}: [1]       =&gt; 1//1
  RootedTree{Int64}: [1, 2]    =&gt; 1//2
  RootedTree{Int64}: [1, 2, 3] =&gt; 1//4
  RootedTree{Int64}: [1, 2, 2] =&gt; 1//3</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ranocha/BSeries.jl/blob/807b3423609dc007f342d4b606fd4ea6cdf2726a/src/BSeries.jl#L348-L398">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BSeries.bseries-Tuple{AdditiveRungeKuttaMethod, Any}" href="#BSeries.bseries-Tuple{AdditiveRungeKuttaMethod, Any}"><code>BSeries.bseries</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">bseries(ark::AdditiveRungeKuttaMethod, order)</code></pre><p>Compute the B-series of the additive Runge-Kutta method <code>ark</code> up to a prescribed integer <code>order</code>.</p><div class="admonition is-info"><header class="admonition-header">Normalization by elementary differentials</header><div class="admonition-body"><p>The coefficients of the B-series returned by this method need to be multiplied by a power of the time step divided by the <code>symmetry</code> of the colored rooted tree and multiplied by the corresponding elementary differential of the input vector fields <span>$f^\nu$</span>. See also <a href="#BSeries.evaluate"><code>evaluate</code></a>.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ranocha/BSeries.jl/blob/807b3423609dc007f342d4b606fd4ea6cdf2726a/src/BSeries.jl#L462-L474">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BSeries.bseries-Tuple{MultirateInfinitesimalSplitMethod, Any}" href="#BSeries.bseries-Tuple{MultirateInfinitesimalSplitMethod, Any}"><code>BSeries.bseries</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">bseries(mis::MultirateInfinitesimalSplitMethod, order)</code></pre><p>Compute the B-series of the multirate infinitesimal split method <code>mis</code> up to a prescribed integer <code>order</code>.</p><div class="admonition is-info"><header class="admonition-header">Normalization by elementary differentials</header><div class="admonition-body"><p>The coefficients of the B-series returned by this method need to be multiplied by a power of the time step divided by the <code>symmetry</code> of the colored rooted tree and multiplied by the corresponding elementary differential of the input vector fields <span>$f^\nu$</span>. See also <a href="#BSeries.evaluate"><code>evaluate</code></a>.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ranocha/BSeries.jl/blob/807b3423609dc007f342d4b606fd4ea6cdf2726a/src/BSeries.jl#L584-L596">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BSeries.bseries-Tuple{RosenbrockMethod, Any}" href="#BSeries.bseries-Tuple{RosenbrockMethod, Any}"><code>BSeries.bseries</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">bseries(ros::RosenbrockMethod, order)</code></pre><p>Compute the B-series of the Rosenbrock method <code>ros</code> up to a prescribed integer <code>order</code>.</p><div class="admonition is-info"><header class="admonition-header">Normalization by elementary differentials</header><div class="admonition-body"><p>The coefficients of the B-series returned by this method need to be multiplied by a power of the time step divided by the <code>symmetry</code> of the rooted tree and multiplied by the corresponding elementary differential of the input vector field <span>$f$</span>. See also <a href="#BSeries.evaluate"><code>evaluate</code></a>.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ranocha/BSeries.jl/blob/807b3423609dc007f342d4b606fd4ea6cdf2726a/src/BSeries.jl#L504-L516">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BSeries.bseries-Tuple{RungeKuttaMethod, Any}" href="#BSeries.bseries-Tuple{RungeKuttaMethod, Any}"><code>BSeries.bseries</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">bseries(rk::RungeKuttaMethod, order)
bseries(A::AbstractMatrix, b::AbstractVector, c::AbstractVector, order)</code></pre><p>Compute the B-series of the Runge-Kutta method <code>rk</code> with Butcher coefficients <code>A, b, c</code> up to a prescribed integer <code>order</code>.</p><div class="admonition is-info"><header class="admonition-header">Normalization by elementary differentials</header><div class="admonition-body"><p>The coefficients of the B-series returned by this method need to be multiplied by a power of the time step divided by the <code>symmetry</code> of the rooted tree and multiplied by the corresponding elementary differential of the input vector field <span>$f$</span>. See also <a href="#BSeries.evaluate"><code>evaluate</code></a>.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ranocha/BSeries.jl/blob/807b3423609dc007f342d4b606fd4ea6cdf2726a/src/BSeries.jl#L417-L430">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BSeries.compose-Tuple{Any, Any, RootedTree}" href="#BSeries.compose-Tuple{Any, Any, RootedTree}"><code>BSeries.compose</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">compose(b, a, t::RootedTree)</code></pre><p>Compute the coefficient correspoding to the tree <code>t</code> of the B-series that is formed by composing the B-series <code>a</code> with the B-series <code>b</code>. It is assumed that the B-series <code>b</code> has the coefficient unity of the empty tree.</p><p><strong>References</strong></p><p>Section 3.1 of</p><ul><li>Philippe Chartier, Ernst Hairer, Gilles Vilmart (2010) Algebraic Structures of B-series. Foundations of Computational Mathematics <a href="https://doi.org/10.1007/s10208-010-9065-1">DOI: 10.1007/s10208-010-9065-1</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ranocha/BSeries.jl/blob/807b3423609dc007f342d4b606fd4ea6cdf2726a/src/BSeries.jl#L739-L753">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BSeries.compose-Tuple{Any, Any}" href="#BSeries.compose-Tuple{Any, Any}"><code>BSeries.compose</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">compose(b, a; normalize_stepsize=false)</code></pre><p>Compose the B-series <code>a</code> with the B-series <code>b</code>. It is assumed that the B-series <code>b</code> has the coefficient unity of the empty tree.</p><p>In the notation of Chartier, Hairer and Vilmart (2010), we have <code>compose(b, a) = b ⋅ a</code>. Note that this means that method <code>b</code> is applied first, followed by method <code>a</code>.</p><p>If <code>normalize_stepsize = true</code>, the coefficients of the returned B-series are divided by <code>2^order(t)</code> for each rooted tree <code>t</code>. This normalizes the step size so that the resulting numerical integrator B-series uses the same step size as the input series (instead of a doubled step size).</p><p><strong>References</strong></p><p>Section 3.1 of</p><ul><li>Philippe Chartier, Ernst Hairer, Gilles Vilmart (2010) Algebraic Structures of B-series. Foundations of Computational Mathematics <a href="https://doi.org/10.1007/s10208-010-9065-1">DOI: 10.1007/s10208-010-9065-1</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ranocha/BSeries.jl/blob/807b3423609dc007f342d4b606fd4ea6cdf2726a/src/BSeries.jl#L769-L791">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BSeries.compose-Union{Tuple{N}, Tuple{Any, Any, Vararg{Any, N}}} where N" href="#BSeries.compose-Union{Tuple{N}, Tuple{Any, Any, Vararg{Any, N}}} where N"><code>BSeries.compose</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">compose(b1, b2, bs...; normalize_stepsize=false)</code></pre><p>Compose the B-series <code>b1</code>, <code>b2</code>, <code>bs...</code>. It is assumed that all B-series have the coefficient unity of the empty tree.</p><p>In the notation of Chartier, Hairer and Vilmart (2010), we have <code>compose(b1, b2, b3) = b1 ⋅ b2 ⋅ b3</code>. Note that this product is associative and has to be read from left to right, i.e., method <code>b1</code> is applied first, followed by <code>b2</code>, <code>bs...</code>.</p><p>If <code>normalize_stepsize = true</code>, the coefficients of the returned B-series are divided by <code>n^order(t)</code> for each rooted tree <code>t</code>, where <code>n</code> is the total number of composed B-series. This normalizes the step size so that the resulting numerical integrator B-series uses the same step size as the input series (instead of an <code>n</code>-fold step size).</p><p><strong>References</strong></p><p>Section 3.1 of</p><ul><li>Philippe Chartier, Ernst Hairer, Gilles Vilmart (2010) Algebraic Structures of B-series. Foundations of Computational Mathematics <a href="https://doi.org/10.1007/s10208-010-9065-1">DOI: 10.1007/s10208-010-9065-1</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ranocha/BSeries.jl/blob/807b3423609dc007f342d4b606fd4ea6cdf2726a/src/BSeries.jl#L807-L831">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BSeries.compute_derivative" href="#BSeries.compute_derivative"><code>BSeries.compute_derivative</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">compute_derivative(expression, variable)</code></pre><p>Internal function specialized on symbolic variables and expressions from</p><ul><li><a href="https://github.com/symengine/SymEngine.jl">SymEngine.jl</a>,</li><li><a href="https://github.com/JuliaPy/SymPy.jl">SymPy.jl</a>, and</li><li><a href="https://github.com/JuliaSymbolics/Symbolics.jl">Symbolics.jl</a></li></ul><p>if these packages are loaded (via Requires.jl).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ranocha/BSeries.jl/blob/807b3423609dc007f342d4b606fd4ea6cdf2726a/src/BSeries.jl#L1312-L1322">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BSeries.elementary_differentials-Tuple{AbstractVector, Any, Any}" href="#BSeries.elementary_differentials-Tuple{AbstractVector, Any, Any}"><code>BSeries.elementary_differentials</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">elementary_differentials(f::AbstractVector, u, order)</code></pre><p>Compute all elementary differentials of the vector field <code>f</code> with independent variables <code>u</code> up to the given <code>order</code>. The return value can be indexed by rooted trees to obtain the corresponding elementary differential.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ranocha/BSeries.jl/blob/807b3423609dc007f342d4b606fd4ea6cdf2726a/src/BSeries.jl#L1249-L1255">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BSeries.elementary_differentials-Tuple{Tuple{AbstractVector, AbstractVector}, Any, Any}" href="#BSeries.elementary_differentials-Tuple{Tuple{AbstractVector, AbstractVector}, Any, Any}"><code>BSeries.elementary_differentials</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">elementary_differentials(fs::NTuple{2, AbstractVector}, u, order)</code></pre><p>Compute all elementary differentials of the sum of the two vector fields <code>f</code> with independent variables <code>u</code> up to the given <code>order</code>. The return value can be indexed by (bi-) colored rooted trees to obtain the corresponding elementary differential.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ranocha/BSeries.jl/blob/807b3423609dc007f342d4b606fd4ea6cdf2726a/src/BSeries.jl#L1401-L1408">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BSeries.evaluate" href="#BSeries.evaluate"><code>BSeries.evaluate</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">evaluate(f, u, dt, series, reduce_order_by=0)</code></pre><p>Evaluate the B-series <code>series</code> specialized to the ordinary differential equation <span>$u&#39;(t) = f(u(t))$</span> with vector field <code>f</code> and dependent variables <code>u</code> for a time step size <code>dt</code>.</p><p>Here, <code>u</code> is assumed to be a vector of symbolic variables and <code>f</code> is assumed to be a vector of expressions in these variables for plain B-series. For B-series with colored trees, <code>f</code> must be a tuple of vectors of expressions in the variables <code>u</code>. Currently, symbolic variables from</p><ul><li><a href="https://github.com/symengine/SymEngine.jl">SymEngine.jl</a>,</li><li><a href="https://github.com/JuliaPy/SymPy.jl">SymPy.jl</a>, and</li><li><a href="https://github.com/JuliaSymbolics/Symbolics.jl">Symbolics.jl</a></li></ul><p>are supported.</p><p>The powers of <code>dt</code> can be controlled by <code>reduce_order_by</code> to make them different from the usual <code>order(t)</code> for a rooted tree <code>t</code>. This can be useful in the context of <a href="#BSeries.modified_equation-NTuple{4, Any}"><code>modified_equation</code></a>s or <a href="#BSeries.modifying_integrator-NTuple{4, Any}"><code>modifying_integrator</code></a>s, where the B-series coeffcients are those of <span>$h fₕ$</span>, i.e., they contain an additional power of <code>dt</code>. In this case, the B-series of the vector field can be obtained using <code>reduce_order_by = 1</code>.</p><p><strong>References</strong></p><p>Section 3.2 of</p><ul><li>Philippe Chartier, Ernst Hairer, Gilles Vilmart (2010) Algebraic Structures of B-series. Foundations of Computational Mathematics <a href="https://doi.org/10.1007/s10208-010-9065-1">DOI: 10.1007/s10208-010-9065-1</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ranocha/BSeries.jl/blob/807b3423609dc007f342d4b606fd4ea6cdf2726a/src/BSeries.jl#L848-L880">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BSeries.modified_equation-NTuple{4, Any}" href="#BSeries.modified_equation-NTuple{4, Any}"><code>BSeries.modified_equation</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">modified_equation(f, u, dt, series_integrator)</code></pre><p>Compute the B-series of the <a href="#BSeries.modified_equation-NTuple{4, Any}"><code>modified_equation</code></a> of the time integration method with B-series <code>series_integrator</code> with respect to the ordinary differential equation <span>$u&#39;(t) = f(u(t))$</span> with vector field <code>f</code> and dependent variables <code>u</code> for a time step size <code>dt</code>.</p><p>Here, <code>u</code> is assumed to be a vector of symbolic variables and <code>f</code> is assumed to be a vector of expressions in these variables for plain B-series. For B-series with colored trees, <code>f</code> must be a tuple of vectors of expressions in the variables <code>u</code>. Currently, symbolic variables from</p><ul><li><a href="https://github.com/symengine/SymEngine.jl">SymEngine.jl</a>,</li><li><a href="https://github.com/JuliaPy/SymPy.jl">SymPy.jl</a>, and</li><li><a href="https://github.com/JuliaSymbolics/Symbolics.jl">Symbolics.jl</a></li></ul><p>are supported.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ranocha/BSeries.jl/blob/807b3423609dc007f342d4b606fd4ea6cdf2726a/src/BSeries.jl#L1023-L1041">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BSeries.modified_equation-Tuple{Any, Any, Any, RungeKuttaMethod, Any}" href="#BSeries.modified_equation-Tuple{Any, Any, Any, RungeKuttaMethod, Any}"><code>BSeries.modified_equation</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">modified_equation(f, u, dt, rk::RungeKuttaMethod, order)
modified_equation(f, u, dt,
                  A::AbstractMatrix, b::AbstractVector, c::AbstractVector,
                  order)</code></pre><p>Compute the B-series of the <a href="#BSeries.modified_equation-NTuple{4, Any}"><code>modified_equation</code></a> of the Runge-Kutta method <code>rk</code> with Butcher coefficients <code>A, b, c</code> up to the prescribed <code>order</code> with respect to the ordinary differential equation <span>$u&#39;(t) = f(u(t))$</span> with vector field <code>f</code> and dependent variables <code>u</code> for a time step size <code>dt</code>.</p><p>Here, <code>u</code> is assumed to be a vector of symbolic variables and <code>f</code> is assumed to be a vector of expressions in these variables for plain B-series. For B-series with colored trees, <code>f</code> must be a tuple of vectors of expressions in the variables <code>u</code>. Currently, symbolic variables from</p><ul><li><a href="https://github.com/symengine/SymEngine.jl">SymEngine.jl</a>,</li><li><a href="https://github.com/JuliaPy/SymPy.jl">SymPy.jl</a>, and</li><li><a href="https://github.com/JuliaSymbolics/Symbolics.jl">Symbolics.jl</a></li></ul><p>are supported.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ranocha/BSeries.jl/blob/807b3423609dc007f342d4b606fd4ea6cdf2726a/src/BSeries.jl#L1049-L1070">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BSeries.modified_equation-Tuple{Any}" href="#BSeries.modified_equation-Tuple{Any}"><code>BSeries.modified_equation</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">modified_equation(series_integrator)</code></pre><p>Compute the B-series of the modified equation of the time integration method with B-series <code>series_integrator</code>.</p><p>Given an ordinary differential equation (ODE) <span>$u&#39;(t) = f(u(t))$</span> and a Runge-Kutta method, the idea is to interpret the numerical solution with given time step size as exact solution of a modified ODE <span>$u&#39;(t) = fₕ(u(t))$</span>. This method returns the B-series of <span>$h fₕ$</span>.</p><div class="admonition is-info"><header class="admonition-header">Normalization by elementary differentials</header><div class="admonition-body"><p>The coefficients of the B-series returned by this method need to be multiplied by a power of the time step divided by the <code>symmetry</code> of the rooted tree and multiplied by the corresponding elementary differential of the input vector field <span>$f$</span>. See also <a href="#BSeries.evaluate"><code>evaluate</code></a>.</p></div></div><p><strong>References</strong></p><p>Section 3.2 of</p><ul><li>Philippe Chartier, Ernst Hairer, Gilles Vilmart (2010) Algebraic Structures of B-series. Foundations of Computational Mathematics <a href="https://doi.org/10.1007/s10208-010-9065-1">DOI: 10.1007/s10208-010-9065-1</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ranocha/BSeries.jl/blob/807b3423609dc007f342d4b606fd4ea6cdf2726a/src/BSeries.jl#L915-L940">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BSeries.modified_equation-Tuple{RungeKuttaMethod, Any}" href="#BSeries.modified_equation-Tuple{RungeKuttaMethod, Any}"><code>BSeries.modified_equation</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">modified_equation(rk::RungeKuttaMethod, order)
modified_equation(A::AbstractMatrix, b::AbstractVector, c::AbstractVector,
                  order)</code></pre><p>Compute the B-series of the <a href="#BSeries.modified_equation-NTuple{4, Any}"><code>modified_equation</code></a> of the Runge-Kutta method <code>rk</code> with Butcher coefficients <code>A, b, c</code> up to the prescribed <code>order</code>.</p><div class="admonition is-info"><header class="admonition-header">Normalization by elementary differentials</header><div class="admonition-body"><p>The coefficients of the B-series returned by this method need to be multiplied by a power of the time step divided by the <code>symmetry</code> of the rooted tree and multiplied by the corresponding elementary differential of the input vector field <span>$f$</span>. See also <a href="#BSeries.evaluate"><code>evaluate</code></a>.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ranocha/BSeries.jl/blob/807b3423609dc007f342d4b606fd4ea6cdf2726a/src/BSeries.jl#L996-L1010">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BSeries.modifying_integrator-NTuple{4, Any}" href="#BSeries.modifying_integrator-NTuple{4, Any}"><code>BSeries.modifying_integrator</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">modifying_integrator(f, u, dt, series_integrator)</code></pre><p>Compute the B-series of the <a href="#BSeries.modifying_integrator-NTuple{4, Any}"><code>modifying_integrator</code></a> equation of the time integration method with B-series <code>series_integrator</code> with respect to the ordinary differential equation <span>$u&#39;(t) = f(u(t))$</span> with vector field <code>f</code> and dependent variables <code>u</code> for a time step size <code>dt</code>.</p><p>Here, <code>u</code> is assumed to be a vector of symbolic variables and <code>f</code> is assumed to be a vector of expressions in these variables for plain B-series. For B-series with colored trees, <code>f</code> must be a tuple of vectors of expressions in the variables <code>u</code>. Currently, symbolic variables from</p><ul><li><a href="https://github.com/symengine/SymEngine.jl">SymEngine.jl</a>,</li><li><a href="https://github.com/JuliaPy/SymPy.jl">SymPy.jl</a>, and</li><li><a href="https://github.com/JuliaSymbolics/Symbolics.jl">Symbolics.jl</a></li></ul><p>are supported.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ranocha/BSeries.jl/blob/807b3423609dc007f342d4b606fd4ea6cdf2726a/src/BSeries.jl#L1189-L1207">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BSeries.modifying_integrator-Tuple{Any, Any, Any, RungeKuttaMethod, Any}" href="#BSeries.modifying_integrator-Tuple{Any, Any, Any, RungeKuttaMethod, Any}"><code>BSeries.modifying_integrator</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">modifying_integrator(f, u, dt, rk::RungeKuttaMethod, order)
modifying_integrator(f, u, dt,
                     A::AbstractMatrix, b::AbstractVector, c::AbstractVector,
                     order)</code></pre><p>Compute the B-series of the <a href="#BSeries.modifying_integrator-NTuple{4, Any}"><code>modifying_integrator</code></a> equation of the Runge-Kutta method with Butcher coefficients <code>A, b, c</code> up to the prescribed <code>order</code> with respect to the ordinary differential equation <span>$u&#39;(t) = f(u(t))$</span> with vector field <code>f</code> and dependent variables <code>u</code> for a time step size <code>dt</code>.</p><p>Here, <code>u</code> is assumed to be a vector of symbolic variables and <code>f</code> is assumed to be a vector of expressions in these variables for plain B-series. For B-series with colored trees, <code>f</code> must be a tuple of vectors of expressions in the variables <code>u</code>. Currently, symbolic variables from</p><ul><li><a href="https://github.com/symengine/SymEngine.jl">SymEngine.jl</a>,</li><li><a href="https://github.com/JuliaPy/SymPy.jl">SymPy.jl</a>, and</li><li><a href="https://github.com/JuliaSymbolics/Symbolics.jl">Symbolics.jl</a></li></ul><p>are supported.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ranocha/BSeries.jl/blob/807b3423609dc007f342d4b606fd4ea6cdf2726a/src/BSeries.jl#L1215-L1236">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BSeries.modifying_integrator-Tuple{Any}" href="#BSeries.modifying_integrator-Tuple{Any}"><code>BSeries.modifying_integrator</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">modifying_integrator(series_integrator)</code></pre><p>Compute the B-series of a &quot;modifying integrator&quot; equation of the time integration method with B-series <code>series_integrator</code>.</p><p>Given an ordinary differential equation (ODE) <span>$u&#39;(t) = f(u(t))$</span> and a Runge-Kutta method, the idea is to find a modified ODE <span>$u&#39;(t) = fₕ(u(t))$</span> such that the numerical solution with given time step size is the exact solution of the original ODE. This method returns the B-series of <span>$h fₕ$</span>.</p><div class="admonition is-info"><header class="admonition-header">Normalization by elementary differentials</header><div class="admonition-body"><p>The coefficients of the B-series returned by this method need to be multiplied by a power of the time step divided by the <code>symmetry</code> of the rooted tree and multiplied by the corresponding elementary differential of the input vector field <span>$f$</span>. See also <a href="#BSeries.evaluate"><code>evaluate</code></a>.</p></div></div><p><strong>References</strong></p><p>Section 3.2 of</p><ul><li>Philippe Chartier, Ernst Hairer, Gilles Vilmart (2010) Algebraic Structures of B-series. Foundations of Computational Mathematics <a href="https://doi.org/10.1007/s10208-010-9065-1">DOI: 10.1007/s10208-010-9065-1</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ranocha/BSeries.jl/blob/807b3423609dc007f342d4b606fd4ea6cdf2726a/src/BSeries.jl#L1083-L1108">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BSeries.modifying_integrator-Tuple{RungeKuttaMethod, Any}" href="#BSeries.modifying_integrator-Tuple{RungeKuttaMethod, Any}"><code>BSeries.modifying_integrator</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">modifying_integrator(rk::RungeKuttaMethod, order)
modifying_integrator(A::AbstractMatrix, b::AbstractVector, c::AbstractVector,
                     order)</code></pre><p>Compute the B-series of the <a href="#BSeries.modifying_integrator-NTuple{4, Any}"><code>modifying_integrator</code></a> equation of the Runge-Kutta method with Butcher coefficients <code>A, b, c</code> up to the prescribed <code>order</code>.</p><div class="admonition is-info"><header class="admonition-header">Normalization by elementary differentials</header><div class="admonition-body"><p>The coefficients of the B-series returned by this method need to be multiplied by a power of the time step divided by the <code>symmetry</code> of the rooted tree and multiplied by the corresponding elementary differential of the input vector field <span>$f$</span>. See also <a href="#BSeries.evaluate"><code>evaluate</code></a>.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ranocha/BSeries.jl/blob/807b3423609dc007f342d4b606fd4ea6cdf2726a/src/BSeries.jl#L1161-L1176">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BSeries.order_of_accuracy-Tuple{TruncatedBSeries}" href="#BSeries.order_of_accuracy-Tuple{TruncatedBSeries}"><code>BSeries.order_of_accuracy</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">order_of_accuracy(series; kwargs...)</code></pre><p>Determine the order of accuracy of the B-series <code>series</code>. By default, the comparison with the coefficients of the exact solution is performed using <code>isequal</code>. If keyword arguments such as absolute/relative tolerances <code>atol</code>/<code>rtol</code> are given or floating point numbers are used, the comparison is perfomed using <code>isapprox</code> and the keyword arguments <code>kwargs...</code> are forwarded.</p><p>See also <a href="#RootedTrees.order-Tuple{TruncatedBSeries}"><code>order</code></a>, <a href="#BSeries.ExactSolution"><code>ExactSolution</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ranocha/BSeries.jl/blob/807b3423609dc007f342d4b606fd4ea6cdf2726a/src/BSeries.jl#L313-L323">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BSeries.substitute-Tuple{Any, Any, RootedTrees.AbstractRootedTree}" href="#BSeries.substitute-Tuple{Any, Any, RootedTrees.AbstractRootedTree}"><code>BSeries.substitute</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">substitute(b, a, t::AbstractRootedTree)</code></pre><p>Compute the coefficient correspoding to the tree <code>t</code> of the B-series that is formed by substituting the B-series <code>b</code> into the B-series <code>a</code>. It is assumed that the B-series <code>b</code> has the coefficient zero of the empty tree.</p><p><strong>References</strong></p><p>Section 3.2 of</p><ul><li>Philippe Chartier, Ernst Hairer, Gilles Vilmart (2010) Algebraic Structures of B-series. Foundations of Computational Mathematics <a href="https://doi.org/10.1007/s10208-010-9065-1">DOI: 10.1007/s10208-010-9065-1</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ranocha/BSeries.jl/blob/807b3423609dc007f342d4b606fd4ea6cdf2726a/src/BSeries.jl#L676-L690">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BSeries.substitute-Tuple{Any, Any}" href="#BSeries.substitute-Tuple{Any, Any}"><code>BSeries.substitute</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">substitute(b, a)</code></pre><p>Substitute the B-series <code>b</code> into the B-series <code>a</code>. It is assumed that the B-series <code>b</code> has the coefficient zero of the empty tree.</p><p>In the notation of Chartier, Hairer and Vilmart (2010), we have <code>substitute(b, a) = b ★ a</code>.</p><p><strong>References</strong></p><p>Section 3.2 of</p><ul><li>Philippe Chartier, Ernst Hairer, Gilles Vilmart (2010) Algebraic Structures of B-series. Foundations of Computational Mathematics <a href="https://doi.org/10.1007/s10208-010-9065-1">DOI: 10.1007/s10208-010-9065-1</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ranocha/BSeries.jl/blob/807b3423609dc007f342d4b606fd4ea6cdf2726a/src/BSeries.jl#L706-L722">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RootedTrees.order-Tuple{TruncatedBSeries}" href="#RootedTrees.order-Tuple{TruncatedBSeries}"><code>RootedTrees.order</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">order(series::TruncatedBSeries)</code></pre><p>The maximal <code>order</code> of a rooted tree with non-vanishing coefficient in the truncated B-series <code>series</code>.</p><p>See also <a href="#BSeries.order_of_accuracy-Tuple{TruncatedBSeries}"><code>order_of_accuracy</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ranocha/BSeries.jl/blob/807b3423609dc007f342d4b606fd4ea6cdf2726a/src/BSeries.jl#L120-L127">source</a></section></article><h2 id="RootedTrees.jl-API"><a class="docs-heading-anchor" href="#RootedTrees.jl-API">RootedTrees.jl API</a><a id="RootedTrees.jl-API-1"></a><a class="docs-heading-anchor-permalink" href="#RootedTrees.jl-API" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="RootedTrees.RootedTrees" href="#RootedTrees.RootedTrees"><code>RootedTrees.RootedTrees</code></a> — <span class="docstring-category">Module</span></header><section><div><p><strong>RootedTrees</strong></p><p><a href="https://SciML.github.io/RootedTrees.jl/stable"><img src="https://img.shields.io/badge/docs-stable-blue.svg" alt="Docs-stable"/></a> <a href="https://SciML.github.io/RootedTrees.jl/dev"><img src="https://img.shields.io/badge/docs-dev-blue.svg" alt="Docs-dev"/></a> <a href="https://github.com/SciML/RootedTrees.jl/actions?query=workflow%3ACI"><img src="https://github.com/SciML/RootedTrees.jl/workflows/CI/badge.svg" alt="Build Status"/></a> <a href="https://coveralls.io/github/SciML/RootedTrees.jl?branch=main"><img src="https://coveralls.io/repos/github/SciML/RootedTrees.jl/badge.svg?branch=main" alt="Coverage Status"/></a> <a href="https://codecov.io/gh/SciML/RootedTrees.jl"><img src="https://codecov.io/gh/SciML/RootedTrees.jl/branch/main/graph/badge.svg" alt="codecov"/></a> <a href="https://opensource.org/licenses/MIT"><img src="https://img.shields.io/badge/License-MIT-success.svg" alt="License: MIT"/></a> <a href="https://doi.org/10.5281/zenodo.5534590"><img src="https://zenodo.org/badge/DOI/10.5281/zenodo.5534590.svg" alt="DOI"/></a> <a href="https://pkgs.genieframework.com?packages=RootedTrees"><img src="https://shields.io/endpoint?url=https://pkgs.genieframework.com/api/v1/badge/RootedTrees" alt="Downloads"/></a></p><p>A collection of functionality around rooted trees to generate order conditions for Runge-Kutta methods in <a href="https://julialang.org/">Julia</a>. This package also provides basic functionality for <a href="https://github.com/ranocha/BSeries.jl">BSeries.jl</a>.</p><p><strong>API Documentation</strong></p><p>The API of RootedTrees.jl is documented in the following. Additional information on each function is available in their docstrings and in the <a href="https://SciML.github.io/RootedTrees.jl/stable">online documentation</a>.</p><p><strong>Construction</strong></p><p><code>RootedTree</code>s are represented using level sequences, i.e., <code>AbstractVector</code>s containing the distances of the nodes from the root, see</p><ul><li>Beyer, Terry, and Sandra Mitchell Hedetniemi. &quot;Constant time generation of rooted trees&quot;. SIAM Journal on Computing 9.4 (1980): 706-712. <a href="https://doi.org/10.1137/0209055">DOI: 10.1137/0209055</a></li></ul><p><code>RootedTree</code>s can be constructed from their level sequence using</p><pre><code class="language-julia hljs">julia&gt; t = rootedtree([1, 2, 3, 2])
RootedTree{Int64}: [1, 2, 3, 2]</code></pre><p>In the notation of <a href="https://doi.org/10.1002/9781119121534">Butcher (Numerical Methods for ODEs, 2016)</a>, this tree can be written as <code>[[τ] τ]</code> or <code>(τ ∘ τ) ∘ (τ ∘ τ)</code>, where <code>∘</code> is the non-associative Butcher product of <code>RootedTree</code>s, which is also implemented.</p><p>To get the representation of a <code>RootedTree</code> introduced by Butcher, use <code>butcher_representation</code>:</p><pre><code class="language-julia hljs">julia&gt; t = rootedtree([1, 2, 3, 4, 3, 3, 2, 2, 2, 2, 2])
RootedTree{Int64}: [1, 2, 3, 4, 3, 3, 2, 2, 2, 2, 2]

julia&gt; butcher_representation(t)
&quot;[[[τ]τ²]τ⁵]&quot;</code></pre><p>There are also some simple plot recipes for <a href="https://github.com/JuliaPlots/Plots.jl">Plots.jl</a>. Thus, you can visualize a rooted tree <code>t</code> using <code>plot(t)</code> when <code>using Plots</code>.</p><p>Additionally, there is an un-exported function <code>RootedTrees.latexify</code> that can generate LaTeX code for a rooted tree <code>t</code> based on the LaTeX package <a href="https://ctan.org/pkg/forest">forest</a>. The relevant code that needs to be included in the preamble can be obtained from the docstring of <code>RootedTrees.latexify</code> (type <code>?</code> and <code>RootedTrees.latexify</code> in the Julia REPL). The same format is used when you are <code>using Latexify</code> and their function <code>latexify</code>, see <a href="https://github.com/korsbo/Latexify.jl">Latexify.jl</a>.</p><p><strong>Iteration over <code>RootedTree</code>s</strong></p><p>A <code>RootedTreeIterator(order::Integer)</code> can be used to iterate efficiently over all <code>RootedTree</code>s of a given <code>order</code>.</p><p>Be careful that the iterator is stateful for efficiency reasons, so you might need to use <code>copy</code> appropriately, e.g.,</p><pre><code class="language-julia hljs">julia&gt; map(identity, RootedTreeIterator(4))
4-element Array{RootedTrees.RootedTree{Int64,Array{Int64,1}},1}:
 RootedTree{Int64}: [1, 2, 2, 2]
 RootedTree{Int64}: [1, 2, 2, 2]
 RootedTree{Int64}: [1, 2, 2, 2]
 RootedTree{Int64}: [1, 2, 2, 2]

julia&gt; map(copy, RootedTreeIterator(4))
4-element Array{RootedTrees.RootedTree{Int64,Array{Int64,1}},1}:
 RootedTree{Int64}: [1, 2, 3, 4]
 RootedTree{Int64}: [1, 2, 3, 3]
 RootedTree{Int64}: [1, 2, 3, 2]
 RootedTree{Int64}: [1, 2, 2, 2]</code></pre><p><strong>Functions on Trees</strong></p><p>The usual functions on <code>RootedTree</code>s are implemented, cf. <a href="https://doi.org/10.1002/9781119121534">Butcher (Numerical Methods for ODEs, 2016)</a>.</p><ul><li><code>order(t::RootedTree)</code>: The order of a <code>RootedTree</code>, i.e., the length of its level sequence.</li><li><code>σ(t::RootedTree)</code> or <code>symmetry(t)</code>: The symmetry <code>σ</code> of a rooted tree, i.e., the order of the group of automorphisms on a particular labelling (of the vertices) of <code>t</code>.</li><li><code>γ(t::RootedTree)</code> or <code>density(t)</code>: The density <code>γ(t)</code> of a rooted tree, i.e., the product over all vertices of <code>t</code> of the order of the subtree rooted at that vertex.</li><li><code>α(t::RootedTree)</code>: The number of monotonic labelings of <code>t</code> not equivalent under the symmetry group.</li><li><code>β(t::RootedTree)</code>: The total number of labelings of <code>t</code> not equivalent under the symmetry group.</li></ul><p>Additionally, functions on trees connected to Runge-Kutta methods are implemented.</p><ul><li><code>elementary_weight(t, A, b, c)</code>: Compute the elementary weight Φ(<code>t</code>) of <code>t::RootedTree</code> for the Butcher coefficients <code>A, b, c</code> of a Runge-Kutta method.</li><li><code>derivative_weight(t, A, b, c)</code>: Compute the derivative weight (ΦᵢD)(<code>t</code>) of <code>t</code> for the Butcher coefficients <code>A, b, c</code> of a Runge-Kutta method.</li><li><code>residual_order_condition(t, A, b, c)</code>: The residual of the order condition <code>(Φ(t) - 1/γ(t)) / σ(t)</code> with elementary weight <code>Φ(t)</code>, density <code>γ(t)</code>, and symmetry <code>σ(t)</code> of the rooted tree <code>t</code> for the Runge-Kutta method with Butcher coefficients <code>A, b, c</code>.</li></ul><p><strong>Brief Changelog</strong></p><ul><li>v2.0: Rooted trees are considered up to isomorphisms introduced by shifting each coefficient of their level sequence by the same number.</li></ul><p><strong>Referencing</strong></p><p>If you use <a href="https://github.com/SciML/RootedTrees.jl">RootedTrees.jl</a> for your research, please cite the paper</p><pre><code class="language-bibtex hljs">@online{ketcheson2021computing,
  title={Computing with {B}-series},
  author={Ketcheson, David I and Ranocha, Hendrik},
  year={2021},
  month={11},
  eprint={2111.11680},
  eprinttype={arXiv},
  eprintclass={math.NA}
}</code></pre><p>In addition, you can also refer to RootedTrees.jl directly as</p><pre><code class="language-bibtex hljs">@misc{ranocha2019rootedtrees,
  title={{RootedTrees.jl}: {A} collection of functionality around rooted trees
         to generate order conditions for {R}unge-{K}utta methods in {J}ulia
         for differential equations and scientific machine learning ({SciM}L)},
  author={Ranocha, Hendrik and contributors},
  year={2019},
  month={05},
  howpublished={\url{https://github.com/SciML/RootedTrees.jl}},
  doi={10.5281/zenodo.5534590}
}</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="RootedTrees.AdditiveRungeKuttaMethod" href="#RootedTrees.AdditiveRungeKuttaMethod"><code>RootedTrees.AdditiveRungeKuttaMethod</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AdditiveRungeKuttaMethod(rks)
AdditiveRungeKuttaMethod(As, bs, cs=map(A -&gt; vec(sum(A, dims=2)), As))</code></pre><p>Represent an additive Runge-Kutta method with collections of Butcher coefficients <code>As</code>, <code>bs</code>, and <code>cs</code>. Alternatively, you can pass a collection of <a href="#RootedTrees.RungeKuttaMethod"><code>RungeKuttaMethod</code></a>s to the constructor. If the <code>cs</code> are not provided, the usual &quot;row sum&quot; requirement of consistency with autonomous problems is applied.</p><p>An additive Runge-Kutta method applied to the ODE problem</p><p class="math-container">\[  u&#39;(t) = \sum_\nu f^\nu(t, u(t))\]</p><p>has the form</p><p class="math-container">\[\begin{aligned}
  y^i &amp;= u^n + \Delta t \sum_\nu \sum_j a^\nu_{i,j} f^\nu(y^i), \\
  u^{n+1} &amp;= u^n + \Delta t \sum_\nu \sum_i b^\nu_{i} f^\nu(y^i).
\end{aligned}\]</p><p>In particular, additive Runge-Kutta methods are a superset of partitioned RK methods, which are applied to partitioned problems of the form</p><p class="math-container">\[  (u^1)&#39;(t) = f^1(t, u^1, u^2),
  \quad
  (u^2)&#39;(t) = f^2(t, u^1, u^2).\]</p><p><strong>References</strong></p><ul><li>A. L. Araujo, A. Murua, and J. M. Sanz-Serna. &quot;Symplectic Methods Based on Decompositions&quot;. SIAM Journal on Numerical Analysis 34.5 (1997): 1926-1947. <a href="https://doi.org/10.1137/S0036142995292128">DOI: 10.1137/S0036142995292128</a></li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="RootedTrees.BicoloredRootedTree" href="#RootedTrees.BicoloredRootedTree"><code>RootedTrees.BicoloredRootedTree</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">BicoloredRootedTree{T&lt;:Integer}</code></pre><p>Representation of bicolored rooted trees.</p><p>See also <a href="#RootedTrees.ColoredRootedTree"><code>ColoredRootedTree</code></a>, <a href="#RootedTrees.RootedTree"><code>RootedTree</code></a>, <a href="#RootedTrees.rootedtree-Tuple{AbstractVector, AbstractVector}"><code>rootedtree</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="RootedTrees.BicoloredRootedTreeIterator" href="#RootedTrees.BicoloredRootedTreeIterator"><code>RootedTrees.BicoloredRootedTreeIterator</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">BicoloredRootedTreeIterator(order::Integer)</code></pre><p>Iterator over all bi-colored rooted trees of given <code>order</code>. The returned trees are views to an internal tree modified during the iteration. If the returned trees shall be stored or modified during the iteration, a <code>copy</code> has to be made.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="RootedTrees.ColoredRootedTree" href="#RootedTrees.ColoredRootedTree"><code>RootedTrees.ColoredRootedTree</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ColoredRootedTree(level_sequence, color_sequence, is_canonical::Bool=false)</code></pre><p>Represents a colored rooted tree using its level sequence. The single-colored version is <a href="#RootedTrees.RootedTree"><code>RootedTree</code></a>.</p><p>See also <a href="#RootedTrees.BicoloredRootedTree"><code>BicoloredRootedTree</code></a>, <a href="#RootedTrees.rootedtree-Tuple{AbstractVector, AbstractVector}"><code>rootedtree</code></a>.</p><p><strong>References</strong></p><ul><li>Terry Beyer and Sandra Mitchell Hedetniemi. &quot;Constant time generation of rooted trees&quot;. SIAM Journal on Computing 9.4 (1980): 706-712. <a href="https://doi.org/10.1137/0209055">DOI: 10.1137/0209055</a></li><li>A. L. Araujo, A. Murua, and J. M. Sanz-Serna. &quot;Symplectic Methods Based on Decompositions&quot;. SIAM Journal on Numerical Analysis 34.5 (1997): 1926–1947. <a href="https://doi.org/10.1137/S0036142995292128">DOI: 10.1137/S0036142995292128</a></li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="RootedTrees.PartitionForestIterator" href="#RootedTrees.PartitionForestIterator"><code>RootedTrees.PartitionForestIterator</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">PartitionForestIterator(t::AbstractRootedTree, edge_set)</code></pre><p>Lazy iterator representation of the <a href="#RootedTrees.partition_forest-Tuple{RootedTree, Any}"><code>partition_forest</code></a> of the rooted tree <code>t</code>. Similar to <a href="#RootedTrees.RootedTreeIterator"><code>RootedTreeIterator</code></a>, you should <code>copy</code> the iterates if you want to store or modify them during the iteration since they may be views to internal caches.</p><p>See also <a href="#RootedTrees.partition_forest-Tuple{RootedTree, Any}"><code>partition_forest</code></a>, <a href="#RootedTrees.partition_skeleton-Tuple{RootedTrees.AbstractRootedTree, Any}"><code>partition_skeleton</code></a>, and <a href="#RootedTrees.PartitionIterator"><code>PartitionIterator</code></a>.</p><p><strong>References</strong></p><p>Section 2.3 of</p><ul><li>Philippe Chartier, Ernst Hairer, Gilles Vilmart (2010) Algebraic Structures of B-series. Foundations of Computational Mathematics <a href="https://doi.org/10.1007/s10208-010-9065-1">DOI: 10.1007/s10208-010-9065-1</a></li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="RootedTrees.PartitionIterator" href="#RootedTrees.PartitionIterator"><code>RootedTrees.PartitionIterator</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">PartitionIterator(t::AbstractRootedTree)</code></pre><p>Iterator over all partition forests and skeletons of the rooted tree <code>t</code>. This is basically a pure iterator version of <a href="#RootedTrees.all_partitions-Tuple{RootedTree}"><code>all_partitions</code></a>. In particular, the partition forest may only be realized as an iterator. Similar to <a href="#RootedTrees.RootedTreeIterator"><code>RootedTreeIterator</code></a>, you should <code>copy</code> the iterates if you want to store or modify them during the iteration since they may be views to internal caches.</p><p>See also <a href="#RootedTrees.partition_forest-Tuple{RootedTree, Any}"><code>partition_forest</code></a>, <a href="#RootedTrees.partition_skeleton-Tuple{RootedTrees.AbstractRootedTree, Any}"><code>partition_skeleton</code></a>, and <a href="#RootedTrees.PartitionForestIterator"><code>PartitionForestIterator</code></a>.</p><p><strong>References</strong></p><p>Section 2.3 of</p><ul><li>Philippe Chartier, Ernst Hairer, Gilles Vilmart (2010) Algebraic Structures of B-series. Foundations of Computational Mathematics <a href="https://doi.org/10.1007/s10208-010-9065-1">DOI: 10.1007/s10208-010-9065-1</a></li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="RootedTrees.RootedTree" href="#RootedTrees.RootedTree"><code>RootedTrees.RootedTree</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">RootedTree(level_sequence, is_canonical::Bool=false)</code></pre><p>Represents a rooted tree using its level sequence.</p><p><strong>References</strong></p><ul><li>Terry Beyer and Sandra Mitchell Hedetniemi. &quot;Constant time generation of rooted trees&quot;. SIAM Journal on Computing 9.4 (1980): 706-712. <a href="https://doi.org/10.1137/0209055">DOI: 10.1137/0209055</a></li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="RootedTrees.RootedTreeIterator" href="#RootedTrees.RootedTreeIterator"><code>RootedTrees.RootedTreeIterator</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">RootedTreeIterator(order::Integer)</code></pre><p>Iterator over all rooted trees of given <code>order</code>. The returned trees are views to an internal tree modified during the iteration. If the returned trees shall be stored or modified during the iteration, a <code>copy</code> has to be made.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="RootedTrees.RosenbrockMethod" href="#RootedTrees.RosenbrockMethod"><code>RootedTrees.RosenbrockMethod</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">RosenbrockMethod(γ, A, b, c=vec(sum(A, dims=2)))</code></pre><p>Represent a Rosenbrock (or Rosenbrock-Wanner, ROW) method with coefficients <code>γ</code>, <code>A</code>, <code>b</code>, and <code>c</code>. If <code>c</code> is not provided, the usual &quot;row sum&quot; requirement of consistency with autonomous problems is applied.</p><p><strong>Reference</strong></p><ul><li>Ernst Hairer, Gerhard Wanner. Solving ordinary differential equations II: Stiff and differential-algebraic problems. Springer, 2010. Section IV.7</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="RootedTrees.RungeKuttaMethod" href="#RootedTrees.RungeKuttaMethod"><code>RootedTrees.RungeKuttaMethod</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">RungeKuttaMethod(A, b, c=vec(sum(A, dims=2)))</code></pre><p>Represent a Runge-Kutta method with Butcher coefficients <code>A</code>, <code>b</code>, and <code>c</code>. If <code>c</code> is not provided, the usual &quot;row sum&quot; requirement of consistency with autonomous problems is applied.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="RootedTrees.SplittingIterator" href="#RootedTrees.SplittingIterator"><code>RootedTrees.SplittingIterator</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SplittingIterator(t::RootedTree)</code></pre><p>Iterator over all splitting forests and subtrees of the rooted tree <code>t</code>. This is basically an iterator version of <a href="#RootedTrees.all_splittings-Tuple{RootedTree}"><code>all_splittings</code></a>.</p><p>See also <a href="#RootedTrees.partition_forest-Tuple{RootedTree, Any}"><code>partition_forest</code></a> and <a href="#RootedTrees.partition_skeleton-Tuple{RootedTrees.AbstractRootedTree, Any}"><code>partition_skeleton</code></a>.</p><p><strong>References</strong></p><p>Section 2.2 of</p><ul><li>Philippe Chartier, Ernst Hairer, Gilles Vilmart (2010) Algebraic Structures of B-series. Foundations of Computational Mathematics <a href="https://doi.org/10.1007/s10208-010-9065-1">DOI: 10.1007/s10208-010-9065-1</a></li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="RootedTrees.SubtreeIterator" href="#RootedTrees.SubtreeIterator"><code>RootedTrees.SubtreeIterator</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SubtreeIterator(t::AbstractRootedTree)</code></pre><p>Lazy iterator representation of the <a href="#RootedTrees.subtrees-Tuple{ColoredRootedTree}"><code>subtrees</code></a> of the rooted tree <code>t</code>. Similar to <a href="#RootedTrees.RootedTreeIterator"><code>RootedTreeIterator</code></a>, you should <code>copy</code> the iterates if you want to store or modify them during the iteration since they may be views to internal caches.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:==-Tuple{ColoredRootedTree, ColoredRootedTree}" href="#Base.:==-Tuple{ColoredRootedTree, ColoredRootedTree}"><code>Base.:==</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">==(t1::ColoredRootedTree, t2::ColoredRootedTree)</code></pre><p>Compares two rooted trees based on their level (first) and color (second) sequences while considering equivalence classes given by different root indices.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:==-Tuple{RootedTree, RootedTree}" href="#Base.:==-Tuple{RootedTree, RootedTree}"><code>Base.:==</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">==(t1::RootedTree, t2::RootedTree)</code></pre><p>Compares two rooted trees based on their level sequences while considering equivalence classes given by different root indices.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; t1 = rootedtree([1, 2, 3]);

julia&gt; t2 = rootedtree([2, 3, 4]);

julia&gt; t3 = rootedtree([1, 2, 2]);

julia&gt; t1 == t2
true

julia&gt; t1 == t3
false</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:∘-Tuple{RootedTree, RootedTree}" href="#Base.:∘-Tuple{RootedTree, RootedTree}"><code>Base.:∘</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">t1 ∘ t2</code></pre><p>The non-associative Butcher product of rooted trees. It is formed by adding an edge from the root of <code>t1</code> to the root of <code>t2</code>.</p><p>Reference: Section 301 of</p><ul><li>Butcher, John Charles. Numerical methods for ordinary differential equations. John Wiley &amp; Sons, 2016.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.isless-Tuple{ColoredRootedTree, ColoredRootedTree}" href="#Base.isless-Tuple{ColoredRootedTree, ColoredRootedTree}"><code>Base.isless</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">isless(t1::ColoredRootedTree, t2::ColoredRootedTree)</code></pre><p>Compares two colored rooted trees using a lexicographical comparison of their level (first) and color (second) sequences while considering equivalence classes given by different root indices.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.isless-Tuple{RootedTree, RootedTree}" href="#Base.isless-Tuple{RootedTree, RootedTree}"><code>Base.isless</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">isless(t1::RootedTree, t2::RootedTree)</code></pre><p>Compares two rooted trees using a lexicographical comparison of their level sequences while considering equivalence classes given by different root indices.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="RootedTrees.all_partitions-Tuple{RootedTree}" href="#RootedTrees.all_partitions-Tuple{RootedTree}"><code>RootedTrees.all_partitions</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">all_partitions(t::RootedTree)</code></pre><p>Create all partition forests and skeletons of a rooted tree <code>t</code>. This returns vectors of the return values of <a href="#RootedTrees.partition_forest-Tuple{RootedTree, Any}"><code>partition_forest</code></a> and <a href="#RootedTrees.partition_skeleton-Tuple{RootedTrees.AbstractRootedTree, Any}"><code>partition_skeleton</code></a> when looping over all possible edge sets.</p><p>See also <a href="#RootedTrees.PartitionIterator"><code>PartitionIterator</code></a>.</p><p><strong>References</strong></p><p>Section 2.3 of</p><ul><li>Philippe Chartier, Ernst Hairer, Gilles Vilmart (2010) Algebraic Structures of B-series. Foundations of Computational Mathematics <a href="https://doi.org/10.1007/s10208-010-9065-1">DOI: 10.1007/s10208-010-9065-1</a></li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="RootedTrees.all_splittings-Tuple{RootedTree}" href="#RootedTrees.all_splittings-Tuple{RootedTree}"><code>RootedTrees.all_splittings</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">all_splittings(t::RootedTree)</code></pre><p>Create all splitting forests and subtrees associated to ordered subtrees of a rooted tree <code>t</code>.</p><p>Seee also <a href="#RootedTrees.SplittingIterator"><code>SplittingIterator</code></a>.</p><p><strong>References</strong></p><p>Section 2.2 of</p><ul><li>Philippe Chartier, Ernst Hairer, Gilles Vilmart (2010) Algebraic Structures of B-series. Foundations of Computational Mathematics <a href="https://doi.org/10.1007/s10208-010-9065-1">DOI: 10.1007/s10208-010-9065-1</a></li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="RootedTrees.butcher_representation" href="#RootedTrees.butcher_representation"><code>RootedTrees.butcher_representation</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">butcher_representation(t::RootedTree)</code></pre><p>Returns the representation of <code>t::RootedTree</code> introduced by Butcher as a string. Thus, the rooted tree consisting whose only vertex is the root itself is represented as <code>τ</code>. The representation of other trees is defined recursively; if <code>t₁, t₂, ... tₙ</code> are the <a href="#RootedTrees.subtrees-Tuple{ColoredRootedTree}"><code>subtrees</code></a> of the rooted tree <code>t</code>, it is represented as <code>t = [t₁ t₂ ... tₙ]</code>. If multiple subtrees are the same, their number of occurences is written as a power.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; rootedtree([1, 2, 3, 2]) |&gt; butcher_representation
&quot;[[τ]τ]&quot;

julia&gt; rootedtree([1, 2, 3, 3, 2]) |&gt; butcher_representation
&quot;[[τ²]τ]&quot;</code></pre><p><strong>References</strong></p><p>Section 300 of</p><ul><li>Butcher, John Charles. Numerical methods for ordinary differential equations. John Wiley &amp; Sons, 2008.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="RootedTrees.canonical_representation!" href="#RootedTrees.canonical_representation!"><code>RootedTrees.canonical_representation!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">canonical_representation!(t::AbstractRootedTree)</code></pre><p>Change the representation of the rooted tree <code>t</code> to the canonical one, i.e., the one with lexicographically biggest level sequence.</p><p>See also <a href="#RootedTrees.canonical_representation-Tuple{RootedTrees.AbstractRootedTree}"><code>canonical_representation</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="RootedTrees.canonical_representation-Tuple{RootedTrees.AbstractRootedTree}" href="#RootedTrees.canonical_representation-Tuple{RootedTrees.AbstractRootedTree}"><code>RootedTrees.canonical_representation</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">canonical_representation(t::AbstractRootedTree)</code></pre><p>Returns a new tree using the canonical representation of the rooted tree <code>t</code>, i.e., the one with lexicographically biggest level sequence.</p><p>See also <a href="#RootedTrees.canonical_representation!"><code>canonical_representation!</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="RootedTrees.check_canonical-Tuple{RootedTrees.AbstractRootedTree}" href="#RootedTrees.check_canonical-Tuple{RootedTrees.AbstractRootedTree}"><code>RootedTrees.check_canonical</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">check_canonical(t::AbstractRootedTree)</code></pre><p>Check whether <code>t</code> is in canonical representation.</p><div class="admonition is-warning"><header class="admonition-header">Internal interface</header><div class="admonition-body"><p>This function is considered to be an internal implementation detail and will not necessarily be stable.</p></div></div></div></section></article><article class="docstring"><header><a class="docstring-binding" id="RootedTrees.count_trees-Tuple{Any}" href="#RootedTrees.count_trees-Tuple{Any}"><code>RootedTrees.count_trees</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">count_trees(order)</code></pre><p>Counts all rooted trees of <code>order</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="RootedTrees.density-Tuple{RootedTrees.AbstractRootedTree}" href="#RootedTrees.density-Tuple{RootedTrees.AbstractRootedTree}"><code>RootedTrees.density</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">γ(t::AbstractRootedTree)
density(t::AbstractRootedTree)</code></pre><p>The density <code>γ(t)</code> of a rooted tree, i.e., the product over all vertices of <code>t</code> of the order of the subtree rooted at that vertex.</p><p>Reference: Section 301 of</p><ul><li>Butcher, John Charles. Numerical methods for ordinary differential equations. John Wiley &amp; Sons, 2008.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="RootedTrees.derivative_weight-Tuple{ColoredRootedTree, AdditiveRungeKuttaMethod}" href="#RootedTrees.derivative_weight-Tuple{ColoredRootedTree, AdditiveRungeKuttaMethod}"><code>RootedTrees.derivative_weight</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">derivative_weight(t::ColoredRootedTree, ark::AdditiveRungeKuttaMethod)</code></pre><p>Compute the derivative weight (ΦᵢD)(<code>t</code>) of the <a href="#RootedTrees.AdditiveRungeKuttaMethod"><code>AdditiveRungeKuttaMethod</code></a> <code>ark</code> for the colored rooted tree <code>t</code>.</p><p><strong>References</strong></p><ul><li>A. L. Araujo, A. Murua, and J. M. Sanz-Serna. &quot;Symplectic Methods Based on Decompositions&quot;. SIAM Journal on Numerical Analysis 34.5 (1997): 1926–1947. <a href="https://doi.org/10.1137/S0036142995292128">DOI: 10.1137/S0036142995292128</a></li><li>Butcher, John Charles. Numerical methods for ordinary differential equations. John Wiley &amp; Sons, 2008. Section 312</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="RootedTrees.derivative_weight-Tuple{RootedTree, RosenbrockMethod}" href="#RootedTrees.derivative_weight-Tuple{RootedTree, RosenbrockMethod}"><code>RootedTrees.derivative_weight</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">derivative_weight(t::RootedTree, ros::RosenbrockMethod)</code></pre><p>Compute the derivative weight (ΦᵢD)(<code>t</code>) of the <a href="#RootedTrees.RosenbrockMethod"><code>RosenbrockMethod</code></a> <code>ros</code> for the rooted tree <code>t</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="RootedTrees.derivative_weight-Tuple{RootedTree, RungeKuttaMethod}" href="#RootedTrees.derivative_weight-Tuple{RootedTree, RungeKuttaMethod}"><code>RootedTrees.derivative_weight</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">derivative_weight(t::RootedTree, rk::RungeKuttaMethod)</code></pre><p>Compute the derivative weight (ΦᵢD)(<code>t</code>) of the <a href="#RootedTrees.RungeKuttaMethod"><code>RungeKuttaMethod</code></a> <code>rk</code> with Butcher coefficients <code>A, b, c</code> for the rooted tree <code>t</code>.</p><p>Reference: Section 312 of</p><ul><li>Butcher, John Charles. Numerical methods for ordinary differential equations. John Wiley &amp; Sons, 2008.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="RootedTrees.elementary_weight-Tuple{ColoredRootedTree, AdditiveRungeKuttaMethod}" href="#RootedTrees.elementary_weight-Tuple{ColoredRootedTree, AdditiveRungeKuttaMethod}"><code>RootedTrees.elementary_weight</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">elementary_weight(t::ColoredRootedTree, ark::AdditiveRungeKuttaMethod)</code></pre><p>Compute the elementary weight Φ(<code>t</code>) of the <a href="#RootedTrees.AdditiveRungeKuttaMethod"><code>AdditiveRungeKuttaMethod</code></a> <code>ark</code> for a colored rooted tree <code>t</code>`.</p><p><strong>References</strong></p><ul><li>A. L. Araujo, A. Murua, and J. M. Sanz-Serna. &quot;Symplectic Methods Based on Decompositions&quot;. SIAM Journal on Numerical Analysis 34.5 (1997): 1926–1947. <a href="https://doi.org/10.1137/S0036142995292128">DOI: 10.1137/S0036142995292128</a></li><li>Butcher, John Charles. Numerical methods for ordinary differential equations. John Wiley &amp; Sons, 2008. Section 312</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="RootedTrees.elementary_weight-Tuple{RootedTree, RosenbrockMethod}" href="#RootedTrees.elementary_weight-Tuple{RootedTree, RosenbrockMethod}"><code>RootedTrees.elementary_weight</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">elementary_weight(t::RootedTree, ros::RosenbrockMethod)</code></pre><p>Compute the elementary weight Φ(<code>t</code>) of the <a href="#RootedTrees.RosenbrockMethod"><code>RosenbrockMethod</code></a> <code>ros</code> for a rooted tree <code>t</code>`.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="RootedTrees.elementary_weight-Tuple{RootedTree, RungeKuttaMethod}" href="#RootedTrees.elementary_weight-Tuple{RootedTree, RungeKuttaMethod}"><code>RootedTrees.elementary_weight</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">elementary_weight(t::RootedTree, rk::RungeKuttaMethod)
elementary_weight(t::RootedTree, A::AbstractMatrix, b::AbstractVector, c::AbstractVector)</code></pre><p>Compute the elementary weight Φ(<code>t</code>) of the <a href="#RootedTrees.RungeKuttaMethod"><code>RungeKuttaMethod</code></a> <code>rk</code> with Butcher coefficients <code>A, b, c</code> for a rooted tree <code>t</code>`.</p><p>Reference: Section 312 of</p><ul><li>Butcher, John Charles. Numerical methods for ordinary differential equations. John Wiley &amp; Sons, 2008.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="RootedTrees.latexify-Tuple{RootedTree}" href="#RootedTrees.latexify-Tuple{RootedTree}"><code>RootedTrees.latexify</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">latexify(t::RootedTree)</code></pre><p>Return a LaTeX representation of the rooted tree <code>t</code>. This makes use of the LaTeX package <a href="https://ctan.org/pkg/forest">forest</a> and assumes that you use the following LaTeX code in the preamble.</p><pre><code class="nohighlight hljs">% Butcher trees, cf. https://tex.stackexchange.com/questions/283343/butcher-trees-in-tikz
\usepackage{forest}
\forestset{
  */.style={
    delay+={append={[]},}
  },
  rooted tree/.style={
    for tree={
      grow&#39;=90,
      parent anchor=center,
      child anchor=center,
      s sep=2.5pt,
      if level=0{
        baseline
      }{},
      delay={
        if content={*}{
          content=,
          append={[]}
        }{}
      }
    },
    before typesetting nodes={
      for tree={
        circle,
        fill,
        minimum width=3pt,
        inner sep=0pt,
        child anchor=center,
      },
    },
    before computing xy={
      for tree={
        l=5pt,
      }
    }
  }
}
\DeclareDocumentCommand\rootedtree{o}{\Forest{rooted tree [#1]}}</code></pre><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; rootedtree([1, 2, 2]) |&gt; RootedTrees.latexify |&gt; println
\rootedtree[[][]]

julia&gt; rootedtree([1, 2, 3, 3, 2]) |&gt; RootedTrees.latexify |&gt; println
\rootedtree[[[][]][]]</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="RootedTrees.normalize_root!" href="#RootedTrees.normalize_root!"><code>RootedTrees.normalize_root!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">normalize_root!(t::AbstractRootedTree, root=one(eltype(t.level_sequence)))</code></pre><p>Normalize the level sequence of the rooted tree <code>t</code> such that the root is set to <code>root</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="RootedTrees.order-Tuple{RootedTrees.AbstractRootedTree}" href="#RootedTrees.order-Tuple{RootedTrees.AbstractRootedTree}"><code>RootedTrees.order</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">order(t::AbstractRootedTree)</code></pre><p>The <code>order</code> of a rooted tree <code>t</code>, i.e., the length of its level sequence.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="RootedTrees.partition_forest-Tuple{RootedTree, Any}" href="#RootedTrees.partition_forest-Tuple{RootedTree, Any}"><code>RootedTrees.partition_forest</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">partition_forest(t::RootedTree, edge_set)</code></pre><p>Form the partition forest of the rooted tree <code>t</code> where edges marked with <code>false</code> in the <code>edge_set</code> are removed. The ith value in the Boolean iterable <code>edge_set</code> corresponds to the edge connecting node <code>i+1</code> in the level sequence to its parent.</p><p>See also <a href="#RootedTrees.partition_skeleton-Tuple{RootedTrees.AbstractRootedTree, Any}"><code>partition_skeleton</code></a>, <a href="#RootedTrees.PartitionIterator"><code>PartitionIterator</code></a>, and <a href="#RootedTrees.PartitionForestIterator"><code>PartitionForestIterator</code></a>.</p><p><strong>References</strong></p><p>Section 2.3 of</p><ul><li>Philippe Chartier, Ernst Hairer, Gilles Vilmart (2010) Algebraic Structures of B-series. Foundations of Computational Mathematics <a href="https://doi.org/10.1007/s10208-010-9065-1">DOI: 10.1007/s10208-010-9065-1</a></li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="RootedTrees.partition_skeleton-Tuple{RootedTrees.AbstractRootedTree, Any}" href="#RootedTrees.partition_skeleton-Tuple{RootedTrees.AbstractRootedTree, Any}"><code>RootedTrees.partition_skeleton</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">partition_skeleton(t::AbstractRootedTree, edge_set)</code></pre><p>Form the partition skeleton of the rooted tree <code>t</code>, i.e., the rooted tree obtained by contracting each tree of the partition forest to a single vertex and re-establishing the edges removed to obtain the partition forest.</p><p>See also <a href="#RootedTrees.partition_forest-Tuple{RootedTree, Any}"><code>partition_forest</code></a> and <a href="#RootedTrees.PartitionIterator"><code>PartitionIterator</code></a>.</p><p><strong>References</strong></p><p>Section 2.3 (and Section 6.1 for colored trees) of</p><ul><li>Philippe Chartier, Ernst Hairer, Gilles Vilmart (2010) Algebraic Structures of B-series. Foundations of Computational Mathematics <a href="https://doi.org/10.1007/s10208-010-9065-1">DOI: 10.1007/s10208-010-9065-1</a></li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="RootedTrees.residual_order_condition-Tuple{ColoredRootedTree, AdditiveRungeKuttaMethod}" href="#RootedTrees.residual_order_condition-Tuple{ColoredRootedTree, AdditiveRungeKuttaMethod}"><code>RootedTrees.residual_order_condition</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">residual_order_condition(t::ColoredRootedTree, ark::AdditiveRungeKuttaMethod)</code></pre><p>The residual of the order condition   <code>(Φ(t) - 1/γ(t)) / σ(t)</code> with <a href="#RootedTrees.elementary_weight-Tuple{ColoredRootedTree, AdditiveRungeKuttaMethod}"><code>elementary_weight</code></a> <code>Φ(t)</code>, <a href="#RootedTrees.density-Tuple{RootedTrees.AbstractRootedTree}"><code>density</code></a> <code>γ(t)</code>, and <a href="#RootedTrees.symmetry-Tuple{RootedTrees.AbstractRootedTree}"><code>symmetry</code></a> <code>σ(t)</code> of the <a href="#RootedTrees.AdditiveRungeKuttaMethod"><code>AdditiveRungeKuttaMethod</code></a> <code>ark</code> for the colored rooted tree <code>t</code>.</p><p><strong>References</strong></p><ul><li>A. L. Araujo, A. Murua, and J. M. Sanz-Serna. &quot;Symplectic Methods Based on Decompositions&quot;. SIAM Journal on Numerical Analysis 34.5 (1997): 1926–1947. <a href="https://doi.org/10.1137/S0036142995292128">DOI: 10.1137/S0036142995292128</a></li><li>Butcher, John Charles. Numerical methods for ordinary differential equations. John Wiley &amp; Sons, 2008. Section 312</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="RootedTrees.residual_order_condition-Tuple{RootedTree, RosenbrockMethod}" href="#RootedTrees.residual_order_condition-Tuple{RootedTree, RosenbrockMethod}"><code>RootedTrees.residual_order_condition</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">residual_order_condition(t::RootedTree, ros::RosenbrockMethod)</code></pre><p>The residual of the order condition   <code>(Φ(t) - 1/γ(t)) / σ(t)</code> with <a href="#RootedTrees.elementary_weight-Tuple{ColoredRootedTree, AdditiveRungeKuttaMethod}"><code>elementary_weight</code></a> <code>Φ(t)</code>, <a href="#RootedTrees.density-Tuple{RootedTrees.AbstractRootedTree}"><code>density</code></a> <code>γ(t)</code>, and <a href="#RootedTrees.symmetry-Tuple{RootedTrees.AbstractRootedTree}"><code>symmetry</code></a> <code>σ(t)</code> of the <a href="#RootedTrees.RosenbrockMethod"><code>RosenbrockMethod</code></a> <code>ros</code> for the rooted tree <code>t</code>.</p><p><strong>Reference</strong></p><ul><li>Ernst Hairer, Gerhard Wanner. Solving ordinary differential equations II: Stiff and differential-algebraic problems. Springer, 2010. Section IV.7</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="RootedTrees.residual_order_condition-Tuple{RootedTree, RungeKuttaMethod}" href="#RootedTrees.residual_order_condition-Tuple{RootedTree, RungeKuttaMethod}"><code>RootedTrees.residual_order_condition</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">residual_order_condition(t::RootedTree, rk::RungeKuttaMethod)</code></pre><p>The residual of the order condition   <code>(Φ(t) - 1/γ(t)) / σ(t)</code> with <a href="#RootedTrees.elementary_weight-Tuple{ColoredRootedTree, AdditiveRungeKuttaMethod}"><code>elementary_weight</code></a> <code>Φ(t)</code>, <a href="#RootedTrees.density-Tuple{RootedTrees.AbstractRootedTree}"><code>density</code></a> <code>γ(t)</code>, and <a href="#RootedTrees.symmetry-Tuple{RootedTrees.AbstractRootedTree}"><code>symmetry</code></a> <code>σ(t)</code> of the <a href="#RootedTrees.RungeKuttaMethod"><code>RungeKuttaMethod</code></a> <code>rk</code> with Butcher coefficients <code>A, b, c</code> for the rooted tree <code>t</code>.</p><p>Reference: Section 315 of</p><ul><li>Butcher, John Charles. Numerical methods for ordinary differential equations. John Wiley &amp; Sons, 2008.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="RootedTrees.root_color-Tuple{ColoredRootedTree}" href="#RootedTrees.root_color-Tuple{ColoredRootedTree}"><code>RootedTrees.root_color</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">root_color(t::ColoredRootedTree)</code></pre><p>Return the color of the root of <code>t</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="RootedTrees.rootedtree!-Tuple{AbstractVector, AbstractVector}" href="#RootedTrees.rootedtree!-Tuple{AbstractVector, AbstractVector}"><code>RootedTrees.rootedtree!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">rootedtree!(level_sequence, color_sequence)</code></pre><p>Construct a canonical <a href="#RootedTrees.ColoredRootedTree"><code>ColoredRootedTree</code></a> object from a <code>level_sequence</code> and a <code>color_sequence</code> which may be modified in this process. See also <a href="#RootedTrees.rootedtree-Tuple{AbstractVector, AbstractVector}"><code>rootedtree</code></a>.</p><p><strong>References</strong></p><ul><li>Terry Beyer and Sandra Mitchell Hedetniemi. &quot;Constant time generation of rooted trees&quot;. SIAM Journal on Computing 9.4 (1980): 706-712. <a href="https://doi.org/10.1137/0209055">DOI: 10.1137/0209055</a></li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="RootedTrees.rootedtree!-Tuple{AbstractVector}" href="#RootedTrees.rootedtree!-Tuple{AbstractVector}"><code>RootedTrees.rootedtree!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">rootedtree!(level_sequence)</code></pre><p>Construct a canonical <code>RootedTree</code> object from a <code>level_sequence</code> which may be modified in this process. See also <a href="#RootedTrees.rootedtree-Tuple{AbstractVector, AbstractVector}"><code>rootedtree</code></a>.</p><p><strong>References</strong></p><ul><li>Terry Beyer and Sandra Mitchell Hedetniemi. &quot;Constant time generation of rooted trees&quot;. SIAM Journal on Computing 9.4 (1980): 706-712. <a href="https://doi.org/10.1137/0209055">DOI: 10.1137/0209055</a></li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="RootedTrees.rootedtree-Tuple{AbstractVector, AbstractVector}" href="#RootedTrees.rootedtree-Tuple{AbstractVector, AbstractVector}"><code>RootedTrees.rootedtree</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">rootedtree(level_sequence, color_sequence)</code></pre><p>Construct a canonical <a href="#RootedTrees.ColoredRootedTree"><code>ColoredRootedTree</code></a> object from a <code>level_sequence</code> and a <code>color_sequence</code>, i.e., a vector of integers representing the levels of each node of the tree and a vector of associated colors (e.g., <code>Bool</code>s or <code>Integers</code>).</p><p><strong>References</strong></p><ul><li>Terry Beyer and Sandra Mitchell Hedetniemi. &quot;Constant time generation of rooted trees&quot;. SIAM Journal on Computing 9.4 (1980): 706-712. <a href="https://doi.org/10.1137/0209055">DOI: 10.1137/0209055</a></li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="RootedTrees.rootedtree-Tuple{AbstractVector}" href="#RootedTrees.rootedtree-Tuple{AbstractVector}"><code>RootedTrees.rootedtree</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">rootedtree(level_sequence)</code></pre><p>Construct a canonical <a href="#RootedTrees.RootedTree"><code>RootedTree</code></a> object from a <code>level_sequence</code>, i.e., a vector of integers representing the levels of each node of the tree.</p><p><strong>References</strong></p><ul><li>Terry Beyer and Sandra Mitchell Hedetniemi. &quot;Constant time generation of rooted trees&quot;. SIAM Journal on Computing 9.4 (1980): 706-712. <a href="https://doi.org/10.1137/0209055">DOI: 10.1137/0209055</a></li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="RootedTrees.set_printing_style-Tuple{String}" href="#RootedTrees.set_printing_style-Tuple{String}"><code>RootedTrees.set_printing_style</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">RootedTrees.set_printing_style(style::String)</code></pre><p>Set the printing style of rooted trees. Possible options are</p><ul><li>&quot;butcher&quot;: print the <a href="#RootedTrees.butcher_representation"><code>butcher_representation</code></a> of rooted trees</li><li>&quot;sequence&quot;: print the level sequence representation</li></ul><p>This system is based on <a href="https://github.com/JuliaPackaging/Preferences.jl">Preferences.jl</a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="RootedTrees.subtrees-Tuple{ColoredRootedTree}" href="#RootedTrees.subtrees-Tuple{ColoredRootedTree}"><code>RootedTrees.subtrees</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">subtrees(t::ColoredRootedTree)</code></pre><p>Returns a vector of all subtrees of <code>t</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="RootedTrees.subtrees-Tuple{RootedTree}" href="#RootedTrees.subtrees-Tuple{RootedTree}"><code>RootedTrees.subtrees</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">subtrees(t::RootedTree)</code></pre><p>Returns a vector of all subtrees of <code>t</code>.</p><p>See also <a href="#RootedTrees.SubtreeIterator"><code>SubtreeIterator</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="RootedTrees.symmetry-Tuple{RootedTrees.AbstractRootedTree}" href="#RootedTrees.symmetry-Tuple{RootedTrees.AbstractRootedTree}"><code>RootedTrees.symmetry</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">σ(t::AbstractRootedTree)
symmetry(t::AbstractRootedTree)</code></pre><p>The symmetry <code>σ</code> of a rooted tree <code>t</code>, i.e., the order of the group of automorphisms on a particular labelling (of the vertices) of <code>t</code>.</p><p>Reference: Section 301 of</p><ul><li>Butcher, John Charles. Numerical methods for ordinary differential equations. John Wiley &amp; Sons, 2008.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="RootedTrees.unsafe_copyto!-Tuple{RootedTree, Any, RootedTree, Any, Any}" href="#RootedTrees.unsafe_copyto!-Tuple{RootedTree, Any, RootedTree, Any, Any}"><code>RootedTrees.unsafe_copyto!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">unsafe_copyto!(t_dst::AbstractRootedTree, dst_offset,
               t_src::AbstractRootedTree, src_offset, N)</code></pre><p>Copy <code>N</code> nodes from <code>t_src</code> starting at offset <code>src_offset</code> to <code>t_dst</code> starting at offset <code>dst_offset</code>. The types of the rooted trees must match. For example, you cannot copy a <a href="#RootedTrees.ColoredRootedTree"><code>ColoredRootedTree</code></a> to a <a href="#RootedTrees.RootedTree"><code>RootedTree</code></a>.</p><p>This is an unsafe operation since the rooted tree <code>t_dst</code> will not necessarily be in canonical representation afterwards, even if the corresponding flag of <code>t_dst</code> is set. Use with caution!</p><div class="admonition is-warning"><header class="admonition-header">Internal interface</header><div class="admonition-body"><p>This function is considered to be an internal implementation detail and will not necessarily be stable.</p></div></div></div></section></article><article class="docstring"><header><a class="docstring-binding" id="RootedTrees.unsafe_deleteat!-Tuple{RootedTree, Any}" href="#RootedTrees.unsafe_deleteat!-Tuple{RootedTree, Any}"><code>RootedTrees.unsafe_deleteat!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">unsafe_deleteat!(t::AbstractRootedTree, i)</code></pre><p>Delete the node <code>i</code> from the rooted tree <code>t</code>. This is an unsafe operation since the rooted tree will not necessarily be in canonical representation afterwards, even if the corresponding flag of <code>t</code> is set. Use with caution!</p><div class="admonition is-warning"><header class="admonition-header">Internal interface</header><div class="admonition-body"><p>This function is considered to be an internal implementation detail and will not necessarily be stable.</p></div></div></div></section></article><article class="docstring"><header><a class="docstring-binding" id="RootedTrees.unsafe_resize!-Tuple{RootedTree, Integer}" href="#RootedTrees.unsafe_resize!-Tuple{RootedTree, Integer}"><code>RootedTrees.unsafe_resize!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">unsafe_resize!(t::AbstractRootedTree, n::Integer)</code></pre><p>Resize the rooted tree <code>t</code> to <code>n</code> nodes. This is an unsafe operation since the rooted tree will not necessarily be in canonical representation afterwards, even if the corresponding flag of <code>t</code> is set. Use with caution!</p><div class="admonition is-warning"><header class="admonition-header">Internal interface</header><div class="admonition-body"><p>This function is considered to be an internal implementation detail and will not necessarily be stable.</p></div></div></div></section></article><article class="docstring"><header><a class="docstring-binding" id="RootedTrees.α-Tuple{RootedTrees.AbstractRootedTree}" href="#RootedTrees.α-Tuple{RootedTrees.AbstractRootedTree}"><code>RootedTrees.α</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">α(t::AbstractRootedTree)</code></pre><p>The number of monotonic labelings of <code>t</code> not equivalent under the symmetry group.</p><p>Reference: Section 302 of</p><ul><li>Butcher, John Charles. Numerical methods for ordinary differential equations. John Wiley &amp; Sons, 2008.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="RootedTrees.β-Tuple{RootedTrees.AbstractRootedTree}" href="#RootedTrees.β-Tuple{RootedTrees.AbstractRootedTree}"><code>RootedTrees.β</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">β(t::AbstractRootedTree)</code></pre><p>The total number of labelings of <code>t</code> not equivalent under the symmetry group.</p><p>Reference: Section 302 of</p><ul><li>Butcher, John Charles. Numerical methods for ordinary differential equations. John Wiley &amp; Sons, 2008.</li></ul></div></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../benchmarks/">« Benchmarks</a><a class="docs-footer-nextpage" href="../contributing/">Contributing »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.23 on <span class="colophon-date" title="Sunday 2 October 2022 13:29">Sunday 2 October 2022</span>. Using Julia version 1.8.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
