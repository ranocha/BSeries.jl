var documenterSearchIndex = {"docs":
[{"location":"benchmarks/#benchmarks","page":"Benchmarks","title":"Benchmarks","text":"","category":"section"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"Here, we collect some simple benchmarks of BSeries.jl. Take them with a grain of salt since they run on virtual machines in the cloud to generate the documentation automatically. You can of course also copy the code and run the benchmarks locally yourself.","category":"page"},{"location":"benchmarks/#benchmarks-symbolic-computations","page":"Benchmarks","title":"Comparing different symbolic packages","text":"","category":"section"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"Symbolic computations of modified_equations and modifying_integrators in BSeries.jl support","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"SymEngine.jl,\nSymPy.jl, and\nSymbolics.jl","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"as symbolic backends. Here, we compare them in the context of the explicit midpoint method and the nonlinear oscillator ODE","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"u(t) = frac1 u(t) ^2 beginpmatrix -u_2(t)  u_1(t) endpmatrix","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"This particular combination of explicit Runge-Kutta method and ODE is special since the explicit midpoint method is unconditionally energy-conserving for this problem[RanochaKetcheson2020].","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"First, we set up some code to perform the benchmarks. Here, we use a very naive approach, run the code twice (to see the effect of compilation) and use @time to print the runtime. More sophisticated approaches should of course use something like @benchmark from BenchmarkTools.jl. However, this simple and cheap version suffices to compare the orders of magnitude.","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"using BSeries, StaticArrays\n\nfunction benchmark(u, dt, subs, order)\n  # explicit midpoint method\n  A = @SArray [0 0; 1//2 0]\n  b = @SArray [0, 1//1]\n  c = @SArray [0, 1//2]\n\n  # nonlinear oscillator\n  f = [-u[2], u[1]] / (u[1]^2 + u[2]^2)\n\n  println(\"\\n Computing the series coefficients:\")\n  @time coefficients = modifying_integrator(A, b, c, order)\n  @time coefficients = modifying_integrator(A, b, c, order)\n\n  println(\"\\n Computing the series including elementary differentials:\")\n  @time series = modifying_integrator(f, u, dt, A, b, c, order)\n  @time series = modifying_integrator(f, u, dt, A, b, c, order)\n\n  substitution_variables = Dict(u[1] => 1//1, u[2] => 0//1)\n\n  println(\"\\n Substituting the initial condition:\")\n  @time subs.(series, (substitution_variables, ))\n  @time subs.(series, (substitution_variables, ))\n\n  println(\"\\n\")\nend","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"Next, we load the symbolic packages and run the benchmarks.","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"using SymPy # generates annoying output online when conda installs sympy","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"using SymEngine: SymEngine\nusing SymPy: SymPy\nusing Symbolics: Symbolics\n\nprintln(\"SymEngine\")\ndt   = SymEngine.symbols(\"dt\")\nu    = SymEngine.symbols(\"u1, u2\")\nsubs = SymEngine.subs\nbenchmark(u, dt, subs, 8)\n\nprintln(\"SymPy\")\ndt   = SymPy.symbols(\"dt\")\nu    = SymPy.symbols(\"u1, u2\")\nsubs = SymPy.subs\nbenchmark(u, dt, subs, 8)\n\nprintln(\"Symbolics\")\nSymbolics.@variables dt\nu = Symbolics.@variables u1 u2\nsubs = Symbolics.substitute\nbenchmark(u, dt, subs, 8)","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"These results were obtained using the following versions.","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"using InteractiveUtils\nversioninfo()\n\nusing Pkg\nPkg.status([\"BSeries\", \"RootedTrees\", \"SymEngine\", \"SymPy\", \"Symbolics\"],\n           mode=PKGMODE_MANIFEST)\nnothing # hide","category":"page"},{"location":"benchmarks/#benchmarks-other-packages","page":"Benchmarks","title":"Comparison with other packages","text":"","category":"section"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"There are also other open source packages for B-series. Currently, we are aware of the Python packages","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"BSeries\npybs","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"If you know about similar open source packages out there, please inform us, e.g., by creating an issue on GitHub.","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"The packages listed above and BSeries.jl all use different approaches and have different features. Thus, comparisons must be restricted to their common subset of features. Here, we present some simple performance comparisons. Again, we just use (the equivalent of) @time twice to get an idea of the performance after compilation, allowing us to compare orders of magnitude.","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"First, we start with the Python package BSeries and the following benchmark script.","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"using BSeries, Markdown                                                   # hide\nfilename = joinpath(pathof(BSeries) |> dirname |> dirname, \"docs\", \"src\", # hide\n  \"benchmark_python_bseries.py\")                                          # hide\nscript = \"```python\\n\"                                                    # hide\nfor line in Iterators.drop(readlines(filename), 4)                        # hide\n  startswith(line, \"with\") && continue                                    # hide\n  line = replace(line, \"  print\" => \"print\")                              # hide\n  global script                                                           # hide\n  script = script * replace(line, \", file=io\" => \"\") * \"\\n\"               # hide\nend                                                                       # hide\nscript = script * \"```\\n\"                                                 # hide\nMarkdown.parse(script)                                                    # hide","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"The results are as follows.","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"using BSeries, Markdown                                                   # hide\nfilename = joinpath(pathof(BSeries) |> dirname |> dirname, \"docs\", \"src\", # hide\n  \"benchmark_python_bseries.txt\")                                         # hide\nresults = \"```\\n\" * read(filename, String) * \"```\\n\"                      # hide\nMarkdown.parse(results)                                                   # hide","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"Next, we look at the Python package pybs and the following benchmark script. Note that this package does not provide functionality for modifying integrators.","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"using BSeries, Markdown                                                   # hide\nfilename = joinpath(pathof(BSeries) |> dirname |> dirname, \"docs\", \"src\", # hide\n  \"benchmark_python_pybs.py\")                                             # hide\nscript = \"```python\\n\"                                                    # hide\nfor line in Iterators.drop(readlines(filename), 4)                        # hide\n  startswith(line, \"with\") && continue                                    # hide\n  line = replace(line, \"  print\" => \"print\")                              # hide\n  global script                                                           # hide\n  script = script * replace(line, \", file=io\" => \"\") * \"\\n\"               # hide\nend                                                                       # hide\nscript = script * \"```\\n\"                                                 # hide\nMarkdown.parse(script)                                                    # hide","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"The results are as follows.","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"using BSeries, Markdown                                                   # hide\nfilename = joinpath(pathof(BSeries) |> dirname |> dirname, \"docs\", \"src\", # hide\n  \"benchmark_python_pybs.txt\")                                            # hide\nresults = \"```\\n\" * read(filename, String) * \"```\\n\"                      # hide\nMarkdown.parse(results)                                                   # hide","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"Finally, we perform the same task using BSeries.jl in Julia.","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"using BSeries, StaticArrays\n\nA = @SArray [0 0; 1//2 0]\nb = @SArray [0, 1//1]\nc = @SArray [0, 1//2]\nup_to_order = 9\n\n\nprintln(\"Modified equation\")\n@time begin\n  series = modified_equation(A, b, c, up_to_order)\n  println(sum(values(series)))\nend\n\n@time begin\n  series = modified_equation(A, b, c, up_to_order)\n  println(sum(values(series)))\nend\n\n\nprintln(\"\\nModifying integrator\")\n@time begin\n  series = modifying_integrator(A, b, c, up_to_order)\n  println(sum(values(series)))\nend\n\n@time begin\n  series = modifying_integrator(A, b, c, up_to_order)\n  println(sum(values(series)))\nend","category":"page"},{"location":"benchmarks/#References","page":"Benchmarks","title":"References","text":"","category":"section"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"[RanochaKetcheson2020]: ","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"Hendrik Ranocha and David Ketcheson (2020)   Energy Stability of Explicit Runge-Kutta Methods for Nonautonomous or   Nonlinear Problems.   SIAM Journal on Numerical Analysis   DOI: 10.1137/19M1290346","category":"page"},{"location":"api_reference/#API-reference","page":"API reference","title":"API reference","text":"","category":"section"},{"location":"api_reference/#BSeries.jl-API","page":"API reference","title":"BSeries.jl API","text":"","category":"section"},{"location":"api_reference/","page":"API reference","title":"API reference","text":"CurrentModule = BSeries","category":"page"},{"location":"api_reference/","page":"API reference","title":"API reference","text":"Modules = [BSeries]","category":"page"},{"location":"api_reference/#BSeries.BSeries","page":"API reference","title":"BSeries.BSeries","text":"BSeries\n\n(Image: Docs-stable) (Image: Docs-dev) (Image: Build Status) (Image: Coveralls) (Image: Codecov) (Image: License: MIT) (Image: DOI)\n\nA collection of functionality around B-series in Julia. See\n\nPhilippe Chartier, Ernst Hairer, Gilles Vilmart (2010) Algebraic Structures of B-series. Foundations of Computational Mathematics DOI: 10.1007/s10208-010-9065-1\n\nAPI Documentation\n\nThe API of BSeries.jl is documented in the online documentation. Information on each function is available in their docstrings.\n\nBSeries.jl re-exports everything from RootedTrees.jl. However, if you rely on functionality from that package, you should also include it explicitly in your project dependencies to track breaking changes, since the version numbers of RootedTrees.jl and BSeries.jl are not necessarily synchronized.\n\nThe main API of BSeries.jl consists of the following components.\n\nB-series behave like AbstractDicts mapping RootedTrees to coefficients.\nThe B-series of a Runge-Kutta method can be constructed by the function bseries.\nThe algebraic structures of the composition law and the substitution law are implemented via compose and substitute.\nBackward error analysis can be performed via modified_equations and modifying_integrators.\n\nPlease consult the documentation or the docstrings for further information.\n\nReferencing\n\nIf you use BSeries.jl for your research, please cite it using the bibtex entry\n\n@online{ketcheson2021computing,\n  title={Computing with {B}-series},\n  author={Ketcheson, David I and Ranocha, Hendrik},\n  year={2021},\n  month={11},\n  eprint={2111.11680},\n  eprinttype={arXiv},\n  eprintclass={math.NA}\n}\n\nIn addition, you can also refer to BSeries.jl directly as\n\n@misc{ranocha2021bseries,\n  title={{BSeries.jl}: {C}omputing with {B}-series in {J}ulia},\n  author={Ranocha, Hendrik and Ketcheson, David I},\n  year={2021},\n  month={09},\n  howpublished={\\url{https://github.com/ranocha/BSeries.jl}},\n  doi={10.5281/zenodo.5534602}\n}\n\nLicense and contributing\n\nThis project is licensed under the MIT license (see LICENSE.md). Since it is an open-source project, we are very happy to accept contributions from the community. Please refer to CONTRIBUTING.md for more details.\n\n\n\n\n\n","category":"module"},{"location":"api_reference/#BSeries.ExactSolution","page":"API reference","title":"BSeries.ExactSolution","text":"ExactSolution{V}()\n\nLazy representation of the B-series of the exact solution of an ordinary differential equation using coefficients of type at least as representative as V.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#BSeries.ExactSolution-Tuple{Any}","page":"API reference","title":"BSeries.ExactSolution","text":"ExactSolution(series_integrator)\n\nA representation of the B-series of the exact solution of an ODE using the same type of coefficients as the B-series series_integrator.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#BSeries.MultirateInfinitesimalSplitMethod","page":"API reference","title":"BSeries.MultirateInfinitesimalSplitMethod","text":"MultirateInfinitesimalSplitMethod(A, D, G, c)\n\nReferences\n\nKnoth, Oswald, and Joerg Wensch. \"Generalized split-explicit Runge-Kutta methods for the compressible Euler equations\". Monthly Weather Review 142, no. 5 (2014): 2067-2081. DOI: 10.1175/MWR-D-13-00068.1\n\nwarning: Experimental code\nThis code is considered to be experimental at the moment and can change any time.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#BSeries.TruncatedBSeries","page":"API reference","title":"BSeries.TruncatedBSeries","text":"TruncatedBSeries\n\nA struct that can describe B-series of both numerical integration methods (where the coefficient of the empty tree is unity) and right-hand sides of an ordinary differential equation and perturbations thereof (where the coefficient of the empty tree is zero) up to a prescribed order.\n\nGenerally, this kind of struct should be constructed via bseries or one of the other functions returning a B-series, e.g., modified_equation or modifying_integrator.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#BSeries.bseries-Tuple{AdditiveRungeKuttaMethod, Any}","page":"API reference","title":"BSeries.bseries","text":"bseries(ark::AdditiveRungeKuttaMethod, order)\n\nCompute the B-series of the additive Runge-Kutta method ark up to a prescribed integer order.\n\nnote: Normalization by elementary differentials\nThe coefficients of the B-series returned by this method need to be multiplied by a power of the time step divided by the symmetry of the colored rooted tree and multiplied by the corresponding elementary differential of the input vector fields f^nu. See also evaluate.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#BSeries.bseries-Tuple{MultirateInfinitesimalSplitMethod, Any}","page":"API reference","title":"BSeries.bseries","text":"bseries(mis::MultirateInfinitesimalSplitMethod, order)\n\nCompute the B-series of the multirate infinitesimal split method mis up to a prescribed integer order.\n\nnote: Normalization by elementary differentials\nThe coefficients of the B-series returned by this method need to be multiplied by a power of the time step divided by the symmetry of the colored rooted tree and multiplied by the corresponding elementary differential of the input vector fields f^nu. See also evaluate.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#BSeries.bseries-Tuple{RungeKuttaMethod, Any}","page":"API reference","title":"BSeries.bseries","text":"bseries(rk::RungeKuttaMethod, order)\nbseries(A::AbstractMatrix, b::AbstractVector, c::AbstractVector, order)\n\nCompute the B-series of the Runge-Kutta method rk with Butcher coefficients A, b, c up to a prescribed integer order.\n\nnote: Normalization by elementary differentials\nThe coefficients of the B-series returned by this method need to be multiplied by a power of the time step divided by the symmetry of the rooted tree and multiplied by the corresponding elementary differential of the input vector field f. See also evaluate.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#BSeries.compose-Tuple{Any, Any, RootedTree}","page":"API reference","title":"BSeries.compose","text":"compose(b, a, t::RootedTree)\n\nCompute the coefficient correspoding to the tree t of the B-series that is formed by composing the B-series a with the B-series b. It is assumed that the B-series b has the coefficient unity of the empty tree.\n\nReferences\n\nSection 3.1 of\n\nPhilippe Chartier, Ernst Hairer, Gilles Vilmart (2010) Algebraic Structures of B-series. Foundations of Computational Mathematics DOI: 10.1007/s10208-010-9065-1\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#BSeries.compose-Tuple{Any, Any}","page":"API reference","title":"BSeries.compose","text":"compose(b, a; normalize_stepsize=false)\n\nCompose the B-series a with the B-series b. It is assumed that the B-series b has the coefficient unity of the empty tree.\n\nIn the notation of Chartier, Hairer and Vilmart (2010), we have compose(b, a) = b ⋅ a.\n\nIf normalize_stepsize = true, the coefficients of the returned B-series will are divied by 2^order(t) for each rooted tree t. This normalizes the step size so that the resulting numerical integrator B-series uses the same step size as the input series (instead of a doubled step size).\n\nReferences\n\nSection 3.1 of\n\nPhilippe Chartier, Ernst Hairer, Gilles Vilmart (2010) Algebraic Structures of B-series. Foundations of Computational Mathematics DOI: 10.1007/s10208-010-9065-1\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#BSeries.compute_derivative","page":"API reference","title":"BSeries.compute_derivative","text":"compute_derivative(expression, variable)\n\nInternal function specialized on symbolic variables and expressions from\n\nSymEngine.jl,\nSymPy.jl, and\nSymbolics.jl\n\nif these packages are loaded (via Requires.jl).\n\n\n\n\n\n","category":"function"},{"location":"api_reference/#BSeries.elementary_differentials-Tuple{Any, Any, Any}","page":"API reference","title":"BSeries.elementary_differentials","text":"elementary_differentials(f, u, order)\n\nCompute all elementary differentials of the vector field f with independent variables u up to the given order. The return value can be indexed by rooted trees to obtain the corresponding elementary differential.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#BSeries.evaluate","page":"API reference","title":"BSeries.evaluate","text":"evaluate(f, u, dt, series, reduce_order_by=0)\n\nEvaluate the B-series series specialized to the ordinary differential equation u(t) = f(u(t)) with vector field f and dependent variables u for a time step size dt.\n\nHere, u is assumed to be a vector of symbolic variables and f is assumed to be a vector of expressions in these variables. Currently, symbolic variables from\n\nSymEngine.jl,\nSymPy.jl, and\nSymbolics.jl\n\nare supported.\n\nThe powers of dt can be controlled by reduce_order_by to make them different from the usual order(t) for a rooted tree t. This can be useful in the context of modified_equations or modifying_integrators, where the B-series coeffcients are those of h fₕ, i.e., they contain an additional power of dt. In this case, the B-series of the vector field can be obtained using reduce_order_by = 1.\n\nReferences\n\nSection 3.2 of\n\nPhilippe Chartier, Ernst Hairer, Gilles Vilmart (2010) Algebraic Structures of B-series. Foundations of Computational Mathematics DOI: 10.1007/s10208-010-9065-1\n\n\n\n\n\n","category":"function"},{"location":"api_reference/#BSeries.modified_equation-NTuple{4, Any}","page":"API reference","title":"BSeries.modified_equation","text":"modified_equation(f, u, dt, series_integrator)\n\nCompute the B-series of the modified_equation of the time integration method with B-series series_integrator with respect to the ordinary differential equation u(t) = f(u(t)) with vector field f and dependent variables u for a time step size dt.\n\nHere, u is assumed to be a vector of symbolic variables and f is assumed to be a vector of expressions in these variables. Currently, symbolic variables from\n\nSymEngine.jl,\nSymPy.jl, and\nSymbolics.jl\n\nare supported.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#BSeries.modified_equation-Tuple{Any, Any, Any, RungeKuttaMethod, Any}","page":"API reference","title":"BSeries.modified_equation","text":"modified_equation(f, u, dt, rk::RungeKuttaMethod, order)\nmodified_equation(f, u, dt,\n                  A::AbstractMatrix, b::AbstractVector, c::AbstractVector,\n                  order)\n\nCompute the B-series of the modified_equation of the Runge-Kutta method rk with Butcher coefficients A, b, c up to the prescribed order with respect to the ordinary differential equation u(t) = f(u(t)) with vector field f and dependent variables u for a time step size dt.\n\nHere, u is assumed to be a vector of symbolic variables and f is assumed to be a vector of expressions in these variables. Currently, symbolic variables from\n\nSymEngine.jl,\nSymPy.jl, and\nSymbolics.jl\n\nare supported.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#BSeries.modified_equation-Tuple{Any}","page":"API reference","title":"BSeries.modified_equation","text":"modified_equation(series_integrator)\n\nCompute the B-series of the modified equation of the time integration method with B-series series_integrator.\n\nGiven an ordinary differential equation (ODE) u(t) = f(u(t)) and a Runge-Kutta method, the idea is to interpret the numerical solution with given time step size as exact solution of a modified ODE u(t) = fₕ(u(t)). This method returns the B-series of h fₕ.\n\nnote: Normalization by elementary differentials\nThe coefficients of the B-series returned by this method need to be multiplied by a power of the time step divided by the symmetry of the rooted tree and multiplied by the corresponding elementary differential of the input vector field f. See also evaluate.\n\nReferences\n\nSection 3.2 of\n\nPhilippe Chartier, Ernst Hairer, Gilles Vilmart (2010) Algebraic Structures of B-series. Foundations of Computational Mathematics DOI: 10.1007/s10208-010-9065-1\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#BSeries.modified_equation-Tuple{RungeKuttaMethod, Any}","page":"API reference","title":"BSeries.modified_equation","text":"modified_equation(rk::RungeKuttaMethod, order)\nmodified_equation(A::AbstractMatrix, b::AbstractVector, c::AbstractVector,\n                  order)\n\nCompute the B-series of the modified_equation of the Runge-Kutta method rk with Butcher coefficients A, b, c up to the prescribed order.\n\nnote: Normalization by elementary differentials\nThe coefficients of the B-series returned by this method need to be multiplied by a power of the time step divided by the symmetry of the rooted tree and multiplied by the corresponding elementary differential of the input vector field f. See also evaluate.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#BSeries.modifying_integrator-NTuple{4, Any}","page":"API reference","title":"BSeries.modifying_integrator","text":"modifying_integrator(f, u, dt, series_integrator)\n\nCompute the B-series of the modifying_integrator equation of the time integration method with B-series series_integrator with respect to the ordinary differential equation u(t) = f(u(t)) with vector field f and dependent variables u for a time step size dt.\n\nHere, u is assumed to be a vector of symbolic variables and f is assumed to be a vector of expressions in these variables. Currently, symbolic variables from\n\nSymEngine.jl,\nSymPy.jl, and\nSymbolics.jl\n\nare supported.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#BSeries.modifying_integrator-Tuple{Any, Any, Any, RungeKuttaMethod, Any}","page":"API reference","title":"BSeries.modifying_integrator","text":"modifying_integrator(f, u, dt, rk::RungeKuttaMethod, order)\nmodifying_integrator(f, u, dt,\n                     A::AbstractMatrix, b::AbstractVector, c::AbstractVector,\n                     order)\n\nCompute the B-series of the modifying_integrator equation of the Runge-Kutta method with Butcher coefficients A, b, c up to the prescribed order with respect to the ordinary differential equation u(t) = f(u(t)) with vector field f and dependent variables u for a time step size dt.\n\nHere, u is assumed to be a vector of symbolic variables and f is assumed to be a vector of expressions in these variables. Currently, symbolic variables from\n\nSymEngine.jl,\nSymPy.jl, and\nSymbolics.jl\n\nare supported.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#BSeries.modifying_integrator-Tuple{Any}","page":"API reference","title":"BSeries.modifying_integrator","text":"modifying_integrator(series_integrator)\n\nCompute the B-series of a \"modifying integrator\" equation of the time integration method with B-series series_integrator.\n\nGiven an ordinary differential equation (ODE) u(t) = f(u(t)) and a Runge-Kutta method, the idea is to find a modified ODE u(t) = fₕ(u(t)) such that the numerical solution with given time step size is the exact solution of the original ODE. This method returns the B-series of h fₕ.\n\nnote: Normalization by elementary differentials\nThe coefficients of the B-series returned by this method need to be multiplied by a power of the time step divided by the symmetry of the rooted tree and multiplied by the corresponding elementary differential of the input vector field f. See also evaluate.\n\nReferences\n\nSection 3.2 of\n\nPhilippe Chartier, Ernst Hairer, Gilles Vilmart (2010) Algebraic Structures of B-series. Foundations of Computational Mathematics DOI: 10.1007/s10208-010-9065-1\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#BSeries.modifying_integrator-Tuple{RungeKuttaMethod, Any}","page":"API reference","title":"BSeries.modifying_integrator","text":"modifying_integrator(rk::RungeKuttaMethod, order)\nmodifying_integrator(A::AbstractMatrix, b::AbstractVector, c::AbstractVector,\n                     order)\n\nCompute the B-series of the modifying_integrator equation of the Runge-Kutta method with Butcher coefficients A, b, c up to the prescribed order.\n\nnote: Normalization by elementary differentials\nThe coefficients of the B-series returned by this method need to be multiplied by a power of the time step divided by the symmetry of the rooted tree and multiplied by the corresponding elementary differential of the input vector field f. See also evaluate.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#BSeries.substitute-Tuple{Any, Any, RootedTrees.AbstractRootedTree}","page":"API reference","title":"BSeries.substitute","text":"substitute(b, a, t::AbstractRootedTree)\n\nCompute the coefficient correspoding to the tree t of the B-series that is formed by substituting the B-series b into the B-series a. It is assumed that the B-series b has the coefficient zero of the empty tree.\n\nReferences\n\nSection 3.2 of\n\nPhilippe Chartier, Ernst Hairer, Gilles Vilmart (2010) Algebraic Structures of B-series. Foundations of Computational Mathematics DOI: 10.1007/s10208-010-9065-1\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#BSeries.substitute-Tuple{Any, Any}","page":"API reference","title":"BSeries.substitute","text":"substitute(b, a)\n\nSubstitute the B-series b into the B-series a. It is assumed that the B-series b has the coefficient zero of the empty tree.\n\nIn the notation of Chartier, Hairer and Vilmart (2010), we have substitute(b, a) = b ★ a.\n\nReferences\n\nSection 3.2 of\n\nPhilippe Chartier, Ernst Hairer, Gilles Vilmart (2010) Algebraic Structures of B-series. Foundations of Computational Mathematics DOI: 10.1007/s10208-010-9065-1\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#RootedTrees.order-Tuple{TruncatedBSeries}","page":"API reference","title":"RootedTrees.order","text":"order(series::TruncatedBSeries)\n\nThe maximal order of a rooted tree with non-vanishing coefficient in the truncated B-series series.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#RootedTrees.jl-API","page":"API reference","title":"RootedTrees.jl API","text":"","category":"section"},{"location":"api_reference/","page":"API reference","title":"API reference","text":"CurrentModule = RootedTrees","category":"page"},{"location":"api_reference/","page":"API reference","title":"API reference","text":"Modules = [RootedTrees]","category":"page"},{"location":"api_reference/#RootedTrees.RootedTrees","page":"API reference","title":"RootedTrees.RootedTrees","text":"RootedTrees\n\n(Image: Docs-stable) (Image: Docs-dev) (Image: Build Status) (Image: Coverage Status) (Image: codecov) (Image: License: MIT) (Image: DOI)\n\nA collection of functionality around rooted trees to generate order conditions for Runge-Kutta methods in Julia. This package also provides basic functionality for BSeries.jl.\n\nAPI Documentation\n\nThe API of RootedTrees.jl is documented in the following. Additional information on each function is available in their docstrings and in the online documentation.\n\nConstruction\n\nRootedTrees are represented using level sequences, i.e., AbstractVectors containing the distances of the nodes from the root, see\n\nBeyer, Terry, and Sandra Mitchell Hedetniemi. \"Constant time generation of rooted trees\". SIAM Journal on Computing 9.4 (1980): 706-712. DOI: 10.1137/0209055\n\nRootedTrees can be constructed from their level sequence using\n\njulia> t = rootedtree([1, 2, 3, 2])\nRootedTree{Int64}: [1, 2, 3, 2]\n\nIn the notation of Butcher (Numerical Methods for ODEs, 2016), this tree can be written as [[τ] τ] or (τ ∘ τ) ∘ (τ ∘ τ), where ∘ is the non-associative Butcher product of RootedTrees, which is also implemented.\n\nTo get the representation of a RootedTree introduced by Butcher, use butcher_representation:\n\njulia> t = rootedtree([1, 2, 3, 4, 3, 3, 2, 2, 2, 2, 2])\nRootedTree{Int64}: [1, 2, 3, 4, 3, 3, 2, 2, 2, 2, 2]\n\njulia> butcher_representation(t)\n\"[[[τ]τ²]τ⁵]\"\n\nThere are also some simple plot recipes for Plots.jl. Thus, you can visualize a rooted tree t using plot(t) when using Plots.\n\nAdditionally, there is an un-exported function RootedTrees.latexify that can generate LaTeX code for a rooted tree t based on the LaTeX package forest. The relevant code that needs to be included in the preamble can be obtained from the docstring of RootedTrees.latexify (type ? and RootedTrees.latexify in the Julia REPL). The same format is used when you are using Latexify and their function latexify, see Latexify.jl.\n\nIteration over RootedTrees\n\nA RootedTreeIterator(order::Integer) can be used to iterate efficiently over all RootedTrees of a given order.\n\nBe careful that the iterator is stateful for efficiency reasons, so you might need to use copy appropriately, e.g.,\n\njulia> map(identity, RootedTreeIterator(4))\n4-element Array{RootedTrees.RootedTree{Int64,Array{Int64,1}},1}:\n RootedTree{Int64}: [1, 2, 2, 2]\n RootedTree{Int64}: [1, 2, 2, 2]\n RootedTree{Int64}: [1, 2, 2, 2]\n RootedTree{Int64}: [1, 2, 2, 2]\n\njulia> map(copy, RootedTreeIterator(4))\n4-element Array{RootedTrees.RootedTree{Int64,Array{Int64,1}},1}:\n RootedTree{Int64}: [1, 2, 3, 4]\n RootedTree{Int64}: [1, 2, 3, 3]\n RootedTree{Int64}: [1, 2, 3, 2]\n RootedTree{Int64}: [1, 2, 2, 2]\n\nFunctions on Trees\n\nThe usual functions on RootedTrees are implemented, cf. Butcher (Numerical Methods for ODEs, 2016).\n\norder(t::RootedTree): The order of a RootedTree, i.e., the length of its level sequence.\nσ(t::RootedTree) or symmetry(t): The symmetry σ of a rooted tree, i.e., the order of the group of automorphisms on a particular labelling (of the vertices) of t.\nγ(t::RootedTree) or density(t): The density γ(t) of a rooted tree, i.e., the product over all vertices of t of the order of the subtree rooted at that vertex.\nα(t::RootedTree): The number of monotonic labelings of t not equivalent under the symmetry group.\nβ(t::RootedTree): The total number of labelings of t not equivalent under the symmetry group.\n\nAdditionally, functions on trees connected to Runge-Kutta methods are implemented.\n\nelementary_weight(t, A, b, c): Compute the elementary weight Φ(t) of t::RootedTree for the Butcher coefficients A, b, c of a Runge-Kutta method.\nderivative_weight(t, A, b, c): Compute the derivative weight (ΦᵢD)(t) of t for the Butcher coefficients A, b, c of a Runge-Kutta method.\nresidual_order_condition(t, A, b, c): The residual of the order condition (Φ(t) - 1/γ(t)) / σ(t) with elementary weight Φ(t), density γ(t), and symmetry σ(t) of the rooted tree t for the Runge-Kutta method with Butcher coefficients A, b, c.\n\nBrief Changelog\n\nv2.0: Rooted trees are considered up to isomorphisms introduced by shifting each coefficient of their level sequence by the same number.\n\nReferencing\n\nIf you use RootedTrees.jl for your research, please cite the paper\n\n@online{ketcheson2021computing,\n  title={Computing with {B}-series},\n  author={Ketcheson, David I and Ranocha, Hendrik},\n  year={2021},\n  month={11},\n  eprint={2111.11680},\n  eprinttype={arXiv},\n  eprintclass={math.NA}\n}\n\nIn addition, you can also refer to RootedTrees.jl directly as\n\n@misc{ranocha2019rootedtrees,\n  title={{RootedTrees.jl}: {A} collection of functionality around rooted trees\n         to generate order conditions for {R}unge-{K}utta methods in {J}ulia\n         for differential equations and scientific machine learning ({SciM}L)},\n  author={Ranocha, Hendrik and contributors},\n  year={2019},\n  month={05},\n  howpublished={\\url{https://github.com/SciML/RootedTrees.jl}},\n  doi={10.5281/zenodo.5534590}\n}\n\n\n\n\n\n","category":"module"},{"location":"api_reference/#RootedTrees.AdditiveRungeKuttaMethod","page":"API reference","title":"RootedTrees.AdditiveRungeKuttaMethod","text":"AdditiveRungeKuttaMethod(rks)\nAdditiveRungeKuttaMethod(As, bs, cs=map(A -> vec(sum(A, dims=2)), As))\n\nRepresent an additive Runge-Kutta method with collections of Butcher coefficients As, bs, and cs. Alternatively, you can pass a collection of RungeKuttaMethods to the constructor. If the cs are not provided, the usual \"row sum\" requirement of consistency with autonomous problems is applied.\n\nAn additive Runge-Kutta method applied to the ODE problem\n\n  u(t) = sum_nu f^nu(t u(t))\n\nhas the form\n\nbeginaligned\n  y^i = u^n + Delta t sum_nu sum_j a^nu_ij f^nu(y^i) \n  u^n+1 = u^n + Delta t sum_nu sum_i b^nu_i f^nu(y^i)\nendaligned\n\nIn particular, additive Runge-Kutta methods are a superset of partitioned RK methods, which are applied to partitioned problems of the form\n\n  u^1(t) = f^1(t u^1 u^2)\n  quad\n  u^2(t) = f^2(t u^1 u^2)\n\nReferences\n\nA. L. Araujo, A. Murua, and J. M. Sanz-Serna. \"Symplectic Methods Based on Decompositions\". SIAM Journal on Numerical Analysis 34.5 (1997): 1926-1947. DOI: 10.1137/S0036142995292128\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#RootedTrees.BicoloredRootedTree","page":"API reference","title":"RootedTrees.BicoloredRootedTree","text":"BicoloredRootedTree{T<:Integer}\n\nRepresentation of bicolored rooted trees.\n\nSee also ColoredRootedTree, RootedTree, rootedtree.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#RootedTrees.BicoloredRootedTreeIterator","page":"API reference","title":"RootedTrees.BicoloredRootedTreeIterator","text":"BicoloredRootedTreeIterator(order::Integer)\n\nIterator over all bi-colored rooted trees of given order. The returned trees are views to an internal tree modified during the iteration. If the returned trees shall be stored or modified during the iteration, a copy has to be made.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#RootedTrees.ColoredRootedTree","page":"API reference","title":"RootedTrees.ColoredRootedTree","text":"ColoredRootedTree(level_sequence, color_sequence, is_canonical::Bool=false)\n\nRepresents a colored rooted tree using its level sequence. The single-colored version is RootedTree.\n\nSee also BicoloredRootedTree, rootedtree.\n\nReferences\n\nTerry Beyer and Sandra Mitchell Hedetniemi. \"Constant time generation of rooted trees\". SIAM Journal on Computing 9.4 (1980): 706-712. DOI: 10.1137/0209055\nA. L. Araujo, A. Murua, and J. M. Sanz-Serna. \"Symplectic Methods Based on Decompositions\". SIAM Journal on Numerical Analysis 34.5 (1997): 1926–1947. DOI: 10.1137/S0036142995292128\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#RootedTrees.PartitionForestIterator","page":"API reference","title":"RootedTrees.PartitionForestIterator","text":"PartitionForestIterator(t::AbstractRootedTree, edge_set)\n\nLazy iterator representation of the partition_forest of the rooted tree t. Similar to RootedTreeIterator, you should copy the iterates if you want to store or modify them during the iteration since they may be views to internal caches.\n\nSee also partition_forest, partition_skeleton, and PartitionIterator.\n\nReferences\n\nSection 2.3 of\n\nPhilippe Chartier, Ernst Hairer, Gilles Vilmart (2010) Algebraic Structures of B-series. Foundations of Computational Mathematics DOI: 10.1007/s10208-010-9065-1\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#RootedTrees.PartitionIterator","page":"API reference","title":"RootedTrees.PartitionIterator","text":"PartitionIterator(t::AbstractRootedTree)\n\nIterator over all partition forests and skeletons of the rooted tree t. This is basically a pure iterator version of all_partitions. In particular, the partition forest may only be realized as an iterator. Similar to RootedTreeIterator, you should copy the iterates if you want to store or modify them during the iteration since they may be views to internal caches.\n\nSee also partition_forest, partition_skeleton, and PartitionForestIterator.\n\nReferences\n\nSection 2.3 of\n\nPhilippe Chartier, Ernst Hairer, Gilles Vilmart (2010) Algebraic Structures of B-series. Foundations of Computational Mathematics DOI: 10.1007/s10208-010-9065-1\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#RootedTrees.RootedTree","page":"API reference","title":"RootedTrees.RootedTree","text":"RootedTree(level_sequence, is_canonical::Bool=false)\n\nRepresents a rooted tree using its level sequence.\n\nReferences\n\nTerry Beyer and Sandra Mitchell Hedetniemi. \"Constant time generation of rooted trees\". SIAM Journal on Computing 9.4 (1980): 706-712. DOI: 10.1137/0209055\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#RootedTrees.RootedTreeIterator","page":"API reference","title":"RootedTrees.RootedTreeIterator","text":"RootedTreeIterator(order::Integer)\n\nIterator over all rooted trees of given order. The returned trees are views to an internal tree modified during the iteration. If the returned trees shall be stored or modified during the iteration, a copy has to be made.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#RootedTrees.RungeKuttaMethod","page":"API reference","title":"RootedTrees.RungeKuttaMethod","text":"RungeKuttaMethod(A, b, c=vec(sum(A, dims=2)))\n\nRepresent a Runge-Kutta method with Butcher coefficients A, b, and c. If c is not provided, the usual \"row sum\" requirement of consistency with autonomous problems is applied.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#RootedTrees.SplittingIterator","page":"API reference","title":"RootedTrees.SplittingIterator","text":"SplittingIterator(t::RootedTree)\n\nIterator over all splitting forests and subtrees of the rooted tree t. This is basically an iterator version of all_splittings.\n\nSee also partition_forest and partition_skeleton.\n\nReferences\n\nSection 2.2 of\n\nPhilippe Chartier, Ernst Hairer, Gilles Vilmart (2010) Algebraic Structures of B-series. Foundations of Computational Mathematics DOI: 10.1007/s10208-010-9065-1\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#Base.:==-Tuple{ColoredRootedTree, ColoredRootedTree}","page":"API reference","title":"Base.:==","text":"==(t1::ColoredRootedTree, t2::ColoredRootedTree)\n\nCompares two rooted trees based on their level (first) and color (second) sequences while considering equivalence classes given by different root indices. ```\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Base.:==-Tuple{RootedTree, RootedTree}","page":"API reference","title":"Base.:==","text":"==(t1::RootedTree, t2::RootedTree)\n\nCompares two rooted trees based on their level sequences while considering equivalence classes given by different root indices.\n\nExamples\n\njulia> t1 = rootedtree([1, 2, 3]);\n\njulia> t2 = rootedtree([2, 3, 4]);\n\njulia> t3 = rootedtree([1, 2, 2]);\n\njulia> t1 == t2\ntrue\n\njulia> t1 == t3\nfalse\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Base.:∘-Tuple{RootedTree, RootedTree}","page":"API reference","title":"Base.:∘","text":"t1 ∘ t2\n\nThe non-associative Butcher product of rooted trees. It is formed by adding an edge from the root of t1 to the root of t2.\n\nReference: Section 301 of\n\nButcher, John Charles. Numerical methods for ordinary differential equations. John Wiley & Sons, 2016.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Base.isless-Tuple{ColoredRootedTree, ColoredRootedTree}","page":"API reference","title":"Base.isless","text":"isless(t1::ColoredRootedTree, t2::ColoredRootedTree)\n\nCompares two colored rooted trees using a lexicographical comparison of their level (first) and color (second) sequences while considering equivalence classes given by different root indices.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Base.isless-Tuple{RootedTree, RootedTree}","page":"API reference","title":"Base.isless","text":"isless(t1::RootedTree, t2::RootedTree)\n\nCompares two rooted trees using a lexicographical comparison of their level sequences while considering equivalence classes given by different root indices.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#RootedTrees.all_partitions-Tuple{RootedTree}","page":"API reference","title":"RootedTrees.all_partitions","text":"all_partitions(t::RootedTree)\n\nCreate all partition forests and skeletons of a rooted tree t. This returns vectors of the return values of partition_forest and partition_skeleton when looping over all possible edge sets.\n\nSee also PartitionIterator.\n\nReferences\n\nSection 2.3 of\n\nPhilippe Chartier, Ernst Hairer, Gilles Vilmart (2010) Algebraic Structures of B-series. Foundations of Computational Mathematics DOI: 10.1007/s10208-010-9065-1\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#RootedTrees.all_splittings-Tuple{RootedTree}","page":"API reference","title":"RootedTrees.all_splittings","text":"all_splittings(t::RootedTree)\n\nCreate all splitting forests and subtrees associated to ordered subtrees of a rooted tree t.\n\nSeee also SplittingIterator.\n\nReferences\n\nSection 2.2 of\n\nPhilippe Chartier, Ernst Hairer, Gilles Vilmart (2010) Algebraic Structures of B-series. Foundations of Computational Mathematics DOI: 10.1007/s10208-010-9065-1\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#RootedTrees.butcher_representation","page":"API reference","title":"RootedTrees.butcher_representation","text":"butcher_representation(t::RootedTree)\n\nReturns the representation of t::RootedTree introduced by Butcher as a string. Thus, the rooted tree consisting whose only vertex is the root itself is represented as τ. The representation of other trees is defined recursively; if t₁, t₂, ... tₙ are the subtrees of the rooted tree t, it is represented as t = [t₁ t₂ ... tₙ]. If multiple subtrees are the same, their number of occurences is written as a power.\n\nExamples\n\njulia> rootedtree([1, 2, 3, 2]) |> butcher_representation\n\"[[τ]τ]\"\n\njulia> rootedtree([1, 2, 3, 3, 2]) |> butcher_representation\n\"[[τ²]τ]\"\n\nReferences\n\nSection 300 of\n\nButcher, John Charles. Numerical methods for ordinary differential equations. John Wiley & Sons, 2008.\n\n\n\n\n\n","category":"function"},{"location":"api_reference/#RootedTrees.canonical_representation!","page":"API reference","title":"RootedTrees.canonical_representation!","text":"canonical_representation!(t::AbstractRootedTree)\n\nChange the representation of the rooted tree t to the canonical one, i.e., the one with lexicographically biggest level sequence.\n\nSee also canonical_representation.\n\n\n\n\n\n","category":"function"},{"location":"api_reference/#RootedTrees.canonical_representation-Tuple{RootedTrees.AbstractRootedTree}","page":"API reference","title":"RootedTrees.canonical_representation","text":"canonical_representation(t::AbstractRootedTree)\n\nReturns a new tree using the canonical representation of the rooted tree t, i.e., the one with lexicographically biggest level sequence.\n\nSee also canonical_representation!.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#RootedTrees.check_canonical-Tuple{RootedTrees.AbstractRootedTree}","page":"API reference","title":"RootedTrees.check_canonical","text":"check_canonical(t::AbstractRootedTree)\n\nCheck whether t is in canonical representation.\n\nwarn: Internal interface\nThis function is considered to be an internal implementation detail and will not necessarily be stable.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#RootedTrees.count_trees-Tuple{Any}","page":"API reference","title":"RootedTrees.count_trees","text":"count_trees(order)\n\nCounts all rooted trees of order.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#RootedTrees.density-Tuple{RootedTrees.AbstractRootedTree}","page":"API reference","title":"RootedTrees.density","text":"γ(t::AbstractRootedTree)\ndensity(t::AbstractRootedTree)\n\nThe density γ(t) of a rooted tree, i.e., the product over all vertices of t of the order of the subtree rooted at that vertex.\n\nReference: Section 301 of\n\nButcher, John Charles. Numerical methods for ordinary differential equations. John Wiley & Sons, 2008.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#RootedTrees.derivative_weight-Tuple{ColoredRootedTree, AdditiveRungeKuttaMethod}","page":"API reference","title":"RootedTrees.derivative_weight","text":"derivative_weight(t::ColoredRootedTree, ark::AdditiveRungeKuttaMethod)\n\nCompute the derivative weight (ΦᵢD)(t) of the AdditiveRungeKuttaMethod ark for the colored rooted tree t.\n\nReferences\n\nA. L. Araujo, A. Murua, and J. M. Sanz-Serna. \"Symplectic Methods Based on Decompositions\". SIAM Journal on Numerical Analysis 34.5 (1997): 1926–1947. DOI: 10.1137/S0036142995292128\nButcher, John Charles. Numerical methods for ordinary differential equations. John Wiley & Sons, 2008. Section 312\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#RootedTrees.derivative_weight-Tuple{RootedTree, RungeKuttaMethod}","page":"API reference","title":"RootedTrees.derivative_weight","text":"derivative_weight(t::RootedTree, rk::RungeKuttaMethod)\n\nCompute the derivative weight (ΦᵢD)(t) of the RungeKuttaMethod rk with Butcher coefficients A, b, c for the rooted tree t.\n\nReference: Section 312 of\n\nButcher, John Charles. Numerical methods for ordinary differential equations. John Wiley & Sons, 2008.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#RootedTrees.elementary_weight-Tuple{ColoredRootedTree, AdditiveRungeKuttaMethod}","page":"API reference","title":"RootedTrees.elementary_weight","text":"elementary_weight(t::ColoredRootedTree, ark::AdditiveRungeKuttaMethod)\n\nCompute the elementary weight Φ(t) of the AdditiveRungeKuttaMethod ark for a colored rooted tree t`.\n\nReferences\n\nA. L. Araujo, A. Murua, and J. M. Sanz-Serna. \"Symplectic Methods Based on Decompositions\". SIAM Journal on Numerical Analysis 34.5 (1997): 1926–1947. DOI: 10.1137/S0036142995292128\nButcher, John Charles. Numerical methods for ordinary differential equations. John Wiley & Sons, 2008. Section 312\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#RootedTrees.elementary_weight-Tuple{RootedTree, RungeKuttaMethod}","page":"API reference","title":"RootedTrees.elementary_weight","text":"elementary_weight(t::RootedTree, rk::RungeKuttaMethod)\nelementary_weight(t::RootedTree, A::AbstractMatrix, b::AbstractVector, c::AbstractVector)\n\nCompute the elementary weight Φ(t) of the RungeKuttaMethod rk with Butcher coefficients A, b, c for a rooted tree t`.\n\nReference: Section 312 of\n\nButcher, John Charles. Numerical methods for ordinary differential equations. John Wiley & Sons, 2008.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#RootedTrees.latexify-Tuple{RootedTree}","page":"API reference","title":"RootedTrees.latexify","text":"latexify(t::RootedTree)\n\nReturn a LaTeX representation of the rooted tree t. This makes use of the LaTeX package forest and assumes that you use the following LaTeX code in the preamble.\n\n% Butcher trees, cf. https://tex.stackexchange.com/questions/283343/butcher-trees-in-tikz\n\\usepackage{forest}\n\\forestset{\n  */.style={\n    delay+={append={[]},}\n  },\n  rooted tree/.style={\n    for tree={\n      grow'=90,\n      parent anchor=center,\n      child anchor=center,\n      s sep=2.5pt,\n      if level=0{\n        baseline\n      }{},\n      delay={\n        if content={*}{\n          content=,\n          append={[]}\n        }{}\n      }\n    },\n    before typesetting nodes={\n      for tree={\n        circle,\n        fill,\n        minimum width=3pt,\n        inner sep=0pt,\n        child anchor=center,\n      },\n    },\n    before computing xy={\n      for tree={\n        l=5pt,\n      }\n    }\n  }\n}\n\\DeclareDocumentCommand\\rootedtree{o}{\\Forest{rooted tree [#1]}}\n\nExamples\n\njulia> rootedtree([1, 2, 2]) |> RootedTrees.latexify |> println\n\\rootedtree[[][]]\n\njulia> rootedtree([1, 2, 3, 3, 2]) |> RootedTrees.latexify |> println\n\\rootedtree[[[][]][]]\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#RootedTrees.normalize_root!","page":"API reference","title":"RootedTrees.normalize_root!","text":"normalize_root!(t::AbstractRootedTree, root=one(eltype(t.level_sequence)))\n\nNormalize the level sequence of the rooted tree t such that the root is set to root.\n\n\n\n\n\n","category":"function"},{"location":"api_reference/#RootedTrees.order-Tuple{RootedTrees.AbstractRootedTree}","page":"API reference","title":"RootedTrees.order","text":"order(t::AbstractRootedTree)\n\nThe order of a rooted tree t, i.e., the length of its level sequence.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#RootedTrees.partition_forest-Tuple{RootedTree, Any}","page":"API reference","title":"RootedTrees.partition_forest","text":"partition_forest(t::RootedTree, edge_set)\n\nForm the partition forest of the rooted tree t where edges marked with false in the edge_set are removed. The ith value in the Boolean iterable edge_set corresponds to the edge connecting node i+1 in the level sequence to its parent.\n\nSee also partition_skeleton, PartitionIterator, and PartitionForestIterator.\n\nReferences\n\nSection 2.3 of\n\nPhilippe Chartier, Ernst Hairer, Gilles Vilmart (2010) Algebraic Structures of B-series. Foundations of Computational Mathematics DOI: 10.1007/s10208-010-9065-1\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#RootedTrees.partition_skeleton-Tuple{RootedTrees.AbstractRootedTree, Any}","page":"API reference","title":"RootedTrees.partition_skeleton","text":"partition_skeleton(t::AbstractRootedTree, edge_set)\n\nForm the partition skeleton of the rooted tree t, i.e., the rooted tree obtained by contracting each tree of the partition forest to a single vertex and re-establishing the edges removed to obtain the partition forest.\n\nSee also partition_forest and PartitionIterator.\n\nReferences\n\nSection 2.3 (and Section 6.1 for colored trees) of\n\nPhilippe Chartier, Ernst Hairer, Gilles Vilmart (2010) Algebraic Structures of B-series. Foundations of Computational Mathematics DOI: 10.1007/s10208-010-9065-1\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#RootedTrees.residual_order_condition-Tuple{ColoredRootedTree, AdditiveRungeKuttaMethod}","page":"API reference","title":"RootedTrees.residual_order_condition","text":"residual_order_condition(t::ColoredRootedTree, ark::AdditiveRungeKuttaMethod)\n\nThe residual of the order condition   (Φ(t) - 1/γ(t)) / σ(t) with elementary_weight Φ(t), density γ(t), and symmetry σ(t) of the AdditiveRungeKuttaMethod ark for the colored rooted tree t.\n\nReferences\n\nA. L. Araujo, A. Murua, and J. M. Sanz-Serna. \"Symplectic Methods Based on Decompositions\". SIAM Journal on Numerical Analysis 34.5 (1997): 1926–1947. DOI: 10.1137/S0036142995292128\nButcher, John Charles. Numerical methods for ordinary differential equations. John Wiley & Sons, 2008. Section 312\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#RootedTrees.residual_order_condition-Tuple{RootedTree, RungeKuttaMethod}","page":"API reference","title":"RootedTrees.residual_order_condition","text":"residual_order_condition(t::RootedTree, rk::RungeKuttaMethod)\n\nThe residual of the order condition   (Φ(t) - 1/γ(t)) / σ(t) with elementary_weight Φ(t), density γ(t), and symmetry σ(t) of the RungeKuttaMethod rk with Butcher coefficients A, b, c for the rooted tree t.\n\nReference: Section 315 of\n\nButcher, John Charles. Numerical methods for ordinary differential equations. John Wiley & Sons, 2008.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#RootedTrees.rootedtree!-Tuple{AbstractVector, AbstractVector}","page":"API reference","title":"RootedTrees.rootedtree!","text":"rootedtree!(level_sequence, color_sequence)\n\nConstruct a canonical ColoredRootedTree object from a level_sequence and a color_sequence which may be modified in this process. See also rootedtree.\n\nReferences\n\nTerry Beyer and Sandra Mitchell Hedetniemi. \"Constant time generation of rooted trees\". SIAM Journal on Computing 9.4 (1980): 706-712. DOI: 10.1137/0209055\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#RootedTrees.rootedtree!-Tuple{AbstractVector}","page":"API reference","title":"RootedTrees.rootedtree!","text":"rootedtree!(level_sequence)\n\nConstruct a canonical RootedTree object from a level_sequence which may be modified in this process. See also rootedtree.\n\nReferences\n\nTerry Beyer and Sandra Mitchell Hedetniemi. \"Constant time generation of rooted trees\". SIAM Journal on Computing 9.4 (1980): 706-712. DOI: 10.1137/0209055\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#RootedTrees.rootedtree-Tuple{AbstractVector, AbstractVector}","page":"API reference","title":"RootedTrees.rootedtree","text":"rootedtree(level_sequence, color_sequence)\n\nConstruct a canonical ColoredRootedTree object from a level_sequence and a color_sequence, i.e., a vector of integers representing the levels of each node of the tree and a vector of associated colors (e.g., Bools or Integers).\n\nReferences\n\nTerry Beyer and Sandra Mitchell Hedetniemi. \"Constant time generation of rooted trees\". SIAM Journal on Computing 9.4 (1980): 706-712. DOI: 10.1137/0209055\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#RootedTrees.rootedtree-Tuple{AbstractVector}","page":"API reference","title":"RootedTrees.rootedtree","text":"rootedtree(level_sequence)\n\nConstruct a canonical RootedTree object from a level_sequence, i.e., a vector of integers representing the levels of each node of the tree.\n\nReferences\n\nTerry Beyer and Sandra Mitchell Hedetniemi. \"Constant time generation of rooted trees\". SIAM Journal on Computing 9.4 (1980): 706-712. DOI: 10.1137/0209055\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#RootedTrees.subtrees-Tuple{ColoredRootedTree}","page":"API reference","title":"RootedTrees.subtrees","text":"subtrees(t::ColoredRootedTree)\n\nReturns a vector of all subtrees of t.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#RootedTrees.subtrees-Tuple{RootedTree}","page":"API reference","title":"RootedTrees.subtrees","text":"subtrees(t::RootedTree)\n\nReturns a vector of all subtrees of t.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#RootedTrees.symmetry-Tuple{RootedTrees.AbstractRootedTree}","page":"API reference","title":"RootedTrees.symmetry","text":"σ(t::AbstractRootedTree)\nsymmetry(t::AbstractRootedTree)\n\nThe symmetry σ of a rooted tree t, i.e., the order of the group of automorphisms on a particular labelling (of the vertices) of t.\n\nReference: Section 301 of\n\nButcher, John Charles. Numerical methods for ordinary differential equations. John Wiley & Sons, 2008.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#RootedTrees.unsafe_copyto!-Tuple{RootedTree, Any, RootedTree, Any, Any}","page":"API reference","title":"RootedTrees.unsafe_copyto!","text":"unsafe_copyto!(t_dst::AbstractRootedTree, dst_offset,\n               t_src::AbstractRootedTree, src_offset, N)\n\nCopy Nnodes fromtsrcstarting at offsetsrcoffsettotdststarting at offsetdstoffset. The types of the rooted trees must match. For example, you cannot copy a [ColoredRootedTree](@ref) to a [RootedTree`](@ref).\n\nThis is an unsafe operation since the rooted tree t_dst will not necessarily be in canonical representation afterwards, even if the corresponding flag of t_dst is set. Use with caution!\n\nwarn: Internal interface\nThis function is considered to be an internal implementation detail and will not necessarily be stable.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#RootedTrees.unsafe_deleteat!-Tuple{RootedTree, Any}","page":"API reference","title":"RootedTrees.unsafe_deleteat!","text":"unsafe_deleteat!(t::AbstractRootedTree, i)\n\nDelete the node i from the rooted tree t. This is an unsafe operation since the rooted tree will not necessarily be in canonical representation afterwards, even if the corresponding flag of t is set. Use with caution!\n\nwarn: Internal interface\nThis function is considered to be an internal implementation detail and will not necessarily be stable.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#RootedTrees.unsafe_resize!-Tuple{RootedTree, Integer}","page":"API reference","title":"RootedTrees.unsafe_resize!","text":"unsafe_resize!(t::AbstractRootedTree, n::Integer)\n\nResize the rooted tree t to n nodes. This is an unsafe operation since the rooted tree will not necessarily be in canonical representation afterwards, even if the corresponding flag of t is set. Use with caution!\n\nwarn: Internal interface\nThis function is considered to be an internal implementation detail and will not necessarily be stable.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#RootedTrees.α-Tuple{RootedTrees.AbstractRootedTree}","page":"API reference","title":"RootedTrees.α","text":"α(t::AbstractRootedTree)\n\nThe number of monotonic labelings of t not equivalent under the symmetry group.\n\nReference: Section 302 of\n\nButcher, John Charles. Numerical methods for ordinary differential equations. John Wiley & Sons, 2008.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#RootedTrees.β-Tuple{RootedTrees.AbstractRootedTree}","page":"API reference","title":"RootedTrees.β","text":"β(t::AbstractRootedTree)\n\nThe total number of labelings of t not equivalent under the symmetry group.\n\nReference: Section 302 of\n\nButcher, John Charles. Numerical methods for ordinary differential equations. John Wiley & Sons, 2008.\n\n\n\n\n\n","category":"method"},{"location":"license/","page":"License","title":"License","text":"EditURL = \"https://github.com/ranocha/BSeries.jl/blob/main/LICENSE.md\"","category":"page"},{"location":"license/#License","page":"License","title":"License","text":"","category":"section"},{"location":"license/","page":"License","title":"License","text":"MIT LicenseCopyright (c) 2021-present Hendrik RanochaPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","category":"page"},{"location":"tutorials/modifying_integrators/#tutorial-modifying-integrator","page":"Modifying integrators","title":"Modifying integrators","text":"","category":"section"},{"location":"tutorials/modifying_integrators/","page":"Modifying integrators","title":"Modifying integrators","text":"This tutorial describes the API of BSeries.jl related to the notion of modifying integrators. The main API entry point is modifying_integrator.","category":"page"},{"location":"tutorials/modifying_integrators/","page":"Modifying integrators","title":"Modifying integrators","text":"Given a first-order autonomous ordinary differential equation (ODE)","category":"page"},{"location":"tutorials/modifying_integrators/","page":"Modifying integrators","title":"Modifying integrators","text":"u(t) = f(u(t))","category":"page"},{"location":"tutorials/modifying_integrators/","page":"Modifying integrators","title":"Modifying integrators","text":"and a B-series time integration method, the idea is to find a modified ODE","category":"page"},{"location":"tutorials/modifying_integrators/","page":"Modifying integrators","title":"Modifying integrators","text":"u(t) = f_h(u(t))","category":"page"},{"location":"tutorials/modifying_integrators/","page":"Modifying integrators","title":"Modifying integrators","text":"such that the numerical solution with given time step size h of the original ODE is the exact solution of the modified ODE, see [ChartierHairerVilmart2007] and [ChartierHairerVilmart2010].","category":"page"},{"location":"tutorials/modifying_integrators/#Lotka-Volterra-model","page":"Modifying integrators","title":"Lotka-Volterra model","text":"","category":"section"},{"location":"tutorials/modifying_integrators/","page":"Modifying integrators","title":"Modifying integrators","text":"Here, we consider the explicit Euler method to solve the classical Lotka-Volterra model","category":"page"},{"location":"tutorials/modifying_integrators/","page":"Modifying integrators","title":"Modifying integrators","text":"p(t) = (2 - q) p\nquad\nq(t) = (p - 1) q","category":"page"},{"location":"tutorials/modifying_integrators/","page":"Modifying integrators","title":"Modifying integrators","text":"First, we set up the ODE and compute some numerical solutions using OrdinaryDiffEq.jl.","category":"page"},{"location":"tutorials/modifying_integrators/","page":"Modifying integrators","title":"Modifying integrators","text":"using OrdinaryDiffEq\n\nfunction f(du, u, params, t)\n  p, q = u\n  dp = (2 - q) * p\n  dq = (p - 1) * q\n  du[1] = dp; du[2] = dq\n  return nothing\nend\n\nu0 = [1.5, 2.25]\ntspan = (0.0, 15.0)\node = ODEProblem(f, u0, tspan)\n\ndt = 0.35\nsol_euler = solve(ode, Euler(), dt=dt)\nsol_ref = solve(ode, Tsit5())\nnothing # hide","category":"page"},{"location":"tutorials/modifying_integrators/","page":"Modifying integrators","title":"Modifying integrators","text":"Next, we look at some phase space plots of the numerical solution.","category":"page"},{"location":"tutorials/modifying_integrators/","page":"Modifying integrators","title":"Modifying integrators","text":"using LaTeXStrings, Plots\n\nfig = plot(xguide=L\"$q$\", yguide=L\"$p$\")\ndefault(linewidth=2)\nplot!(fig, sol_ref, vars=(2, 1), label=\"Reference solution\")\nscatter!(fig, last.(sol_euler.u), first.(sol_euler.u),\n         label=\"Explicit Euler, dt = $dt\")\nplot!(fig, xlims=(0.0, 4.0), ylims=(0.0, 2.5))\n\nsavefig(fig, \"lotka_volterra_original.svg\"); nothing # hide","category":"page"},{"location":"tutorials/modifying_integrators/","page":"Modifying integrators","title":"Modifying integrators","text":"(Image: )","category":"page"},{"location":"tutorials/modifying_integrators/","page":"Modifying integrators","title":"Modifying integrators","text":"The exact solution of this problem is periodic, but the explicit Euler method produces an unstable trajectory. Here, we used an especially large time step to more clearly illustrate what will follow, but the qualitative behavior is the same for any time step size.","category":"page"},{"location":"tutorials/modifying_integrators/","page":"Modifying integrators","title":"Modifying integrators","text":"Next, we will derive a \"modifying integrator\". What this means is that we will determine a perturbed ODE right-hand side (RHS) such that when Euler's method is applied to the perturbed RHS, the result is the exact solution to the original Lotka-Volterra system. The perturbed system takes the form of a power series in the time step size dt, and in order to compute with it we will truncate it at a certain order. We can compare the accuracy (and qualitative behavior) obtained by truncating at different orders.","category":"page"},{"location":"tutorials/modifying_integrators/","page":"Modifying integrators","title":"Modifying integrators","text":"Here, we use Symbolics.jl for the symbolic computations.","category":"page"},{"location":"tutorials/modifying_integrators/","page":"Modifying integrators","title":"Modifying integrators","text":"using BSeries, StaticArrays, Symbolics\n\n# Explicit Euler method\nA = @SArray [0//1;]\nb = @SArray [1//1]\nc = @SArray [0//1]\n\n# Setup of symbolic variables\n@variables dt_sym\nu_sym = @variables p q\nf_sym = similar(u_sym); f(f_sym, u_sym, nothing, nothing)\n\nfor truncation_order in 2:4\n  series = modifying_integrator(f_sym, u_sym, dt_sym, A, b, c, truncation_order)\n  series = Symbolics.substitute.(series, dt_sym => dt)\n  modified_f, _ = build_function(series, u_sym, expression=Val(false))\n  modified_ode = ODEProblem((u, params, t) -> modified_f(u), ode.u0, tspan)\n  modified_sol_euler = solve(modified_ode, Euler(), dt=dt)\n  plot!(fig, modified_sol_euler, vars=(2, 1),\n        label=\"Euler, modified ODE order $(truncation_order-1)\")\nend\nplot!(fig, xlims=(0.0, 4.0), ylims=(0.0, 2.5))\n\nsavefig(fig, \"lotka_volterra_modified.svg\"); nothing # hide","category":"page"},{"location":"tutorials/modifying_integrators/","page":"Modifying integrators","title":"Modifying integrators","text":"(Image: )","category":"page"},{"location":"tutorials/modifying_integrators/","page":"Modifying integrators","title":"Modifying integrators","text":"We see that if we include one additional term, the resulting trajectory still grows, while with two additional terms the solution appears to be dissipative. With each additional term, the solution gets closer to the exact solution of the original problem, and with three added terms it is hard to see the difference between them at this scale.","category":"page"},{"location":"tutorials/modifying_integrators/#References","page":"Modifying integrators","title":"References","text":"","category":"section"},{"location":"tutorials/modifying_integrators/","page":"Modifying integrators","title":"Modifying integrators","text":"[ChartierHairerVilmart2007]: ","category":"page"},{"location":"tutorials/modifying_integrators/","page":"Modifying integrators","title":"Modifying integrators","text":"Philippe Chartier, Ernst Hairer and Gilles Vilmart (2007)   Numerical integrators based on modified differential equations   DOI: 10.1090/S0025-5718-07-01967-9","category":"page"},{"location":"tutorials/modifying_integrators/","page":"Modifying integrators","title":"Modifying integrators","text":"[ChartierHairerVilmart2010]: ","category":"page"},{"location":"tutorials/modifying_integrators/","page":"Modifying integrators","title":"Modifying integrators","text":"Philippe Chartier, Ernst Hairer, Gilles Vilmart (2010)   Algebraic Structures of B-series.   Foundations of Computational Mathematics   DOI: 10.1007/s10208-010-9065-1","category":"page"},{"location":"tutorials/symbolic_computations/#tutorial-symbolic-computations","page":"Symbolic computations","title":"Symbolic computations","text":"","category":"section"},{"location":"tutorials/symbolic_computations/","page":"Symbolic computations","title":"Symbolic computations","text":"This tutorial describes some possibilities for symbolic computations based on BSeries.jl. Currently, symbolic computations in BSeries.jl support at least","category":"page"},{"location":"tutorials/symbolic_computations/","page":"Symbolic computations","title":"Symbolic computations","text":"SymEngine.jl,\nSymPy.jl, and\nSymbolics.jl","category":"page"},{"location":"tutorials/symbolic_computations/","page":"Symbolic computations","title":"Symbolic computations","text":"as symbolic backends. You can find some performance comparisons of them in the benchmarks.","category":"page"},{"location":"tutorials/symbolic_computations/#Generating-LaTeX-code","page":"Symbolic computations","title":"Generating LaTeX code","text":"","category":"section"},{"location":"tutorials/symbolic_computations/","page":"Symbolic computations","title":"Symbolic computations","text":"BSeries.jl allow fully symbolic computations of modified_equations and modifying_integrators. More information about these features are available in the respective tutorials. Here, we will also demonstrate how LaTeX code can be generated via Latexify.jl.","category":"page"},{"location":"tutorials/symbolic_computations/","page":"Symbolic computations","title":"Symbolic computations","text":"At the core, BSeries.jl is based on the representation of rooted trees via RootedTrees.jl. Thus, you need to use the setup described in the docstring of RootedTrees.latexify.","category":"page"},{"location":"tutorials/symbolic_computations/#LaTeX-code-of-a-general-modified-equation","page":"Symbolic computations","title":"LaTeX code of a general modified equation","text":"","category":"section"},{"location":"tutorials/symbolic_computations/","page":"Symbolic computations","title":"Symbolic computations","text":"An explicit two-stage, second-order Runge-Kutta method is given by the Butcher tableau","category":"page"},{"location":"tutorials/symbolic_computations/","page":"Symbolic computations","title":"Symbolic computations","text":"beginarrayccc\n  0                  0                    \n  frac12alpha  frac12alpha  0 \n  hline\n                     1 - alpha         alpha\nendarray","category":"page"},{"location":"tutorials/symbolic_computations/","page":"Symbolic computations","title":"Symbolic computations","text":"with real parameter alpha. We can compute the B-series of its modified equation symbolically as follows.","category":"page"},{"location":"tutorials/symbolic_computations/","page":"Symbolic computations","title":"Symbolic computations","text":"using BSeries, SymEngine\n\nα = SymEngine.symbols(\"α\")\nA = [0 0; 1/(2α) 0]\nb = [1-α, α]\nc = [0, 1/(2α)]\n\nseries = modified_equation(A, b, c, 3)","category":"page"},{"location":"tutorials/symbolic_computations/","page":"Symbolic computations","title":"Symbolic computations","text":"To generate the appropriate LaTeX code, we need to remember that the B-series coefficients shown above represent the modified vector field multiplied by the time step size. Thus, we need to pass reduce_order_by = 1 to latexify. Other keyword arguments implemented for B-series are","category":"page"},{"location":"tutorials/symbolic_computations/","page":"Symbolic computations","title":"Symbolic computations","text":"f = \"f\": The symbol used for the indices of the elementary differentials.\ndt = \"h\": The symbol used for the time step size. Alternatively, symbolic variables can also be used.\nreduce_order_by = 0: Reduce the power of the time step size accordingly.","category":"page"},{"location":"tutorials/symbolic_computations/","page":"Symbolic computations","title":"Symbolic computations","text":"using Latexify\nlatexify(series, reduce_order_by=1, dt=SymEngine.symbols(\"h\"), cdot=false) |> println","category":"page"},{"location":"tutorials/symbolic_computations/","page":"Symbolic computations","title":"Symbolic computations","text":"We can also use other packages for the symbolic computations, of course. SymPy.jl often provides very clean expressions.","category":"page"},{"location":"tutorials/symbolic_computations/","page":"Symbolic computations","title":"Symbolic computations","text":"using BSeries, SymPy\n\nα = SymPy.symbols(\"α\", real=true)\nA = [0 0; 1/(2α) 0]\nb = [1-α, α]\nc = [0, 1/(2α)]\n\nseries = modified_equation(A, b, c, 3)","category":"page"},{"location":"tutorials/symbolic_computations/","page":"Symbolic computations","title":"Symbolic computations","text":"We can also generate LaTeX code as follows, using the same approach as for SymEngine.jl.","category":"page"},{"location":"tutorials/symbolic_computations/","page":"Symbolic computations","title":"Symbolic computations","text":"using Latexify\nlatexify(series, reduce_order_by=1, dt=SymPy.symbols(\"h\"), cdot=false) |> println","category":"page"},{"location":"tutorials/symbolic_computations/","page":"Symbolic computations","title":"Symbolic computations","text":"Alternatively, we can also use Symbolics.jl.","category":"page"},{"location":"tutorials/symbolic_computations/","page":"Symbolic computations","title":"Symbolic computations","text":"using BSeries, Symbolics\n\nSymbolics.@variables α h\nA = [0 0; 1/(2α) 0]\nb = [1-α, α]\nc = [0, 1/(2α)]\n\nseries = modified_equation(A, b, c, 3)","category":"page"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"EditURL = \"https://github.com/ranocha/BSeries.jl/blob/main/CONTRIBUTING.md\"","category":"page"},{"location":"contributing/#Contributing","page":"Contributing","title":"Contributing","text":"","category":"section"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"ContributingBSeries.jl is an open-source project and we are very happy to accept contributions from the community. Please feel free to open issues or submit patches (preferably as pull requests) any time. For planned larger contributions, it is often beneficial to get in contact first, for example via issues.BSeries.jl and its contributions are licensed under the MIT license (see License). As a contributor, you certify that all your contributions are in conformance with the Developer Certificate of Origin (Version 1.1), which is reproduced below.Developer Certificate of Origin (Version 1.1)The following text was taken from https://developercertificate.org:Developer Certificate of Origin\nVersion 1.1\n\nCopyright (C) 2004, 2006 The Linux Foundation and its contributors.\n1 Letterman Drive\nSuite D4700\nSan Francisco, CA, 94129\n\nEveryone is permitted to copy and distribute verbatim copies of this\nlicense document, but changing it is not allowed.\n\n\nDeveloper's Certificate of Origin 1.1\n\nBy making a contribution to this project, I certify that:\n\n(a) The contribution was created in whole or in part by me and I\n    have the right to submit it under the open source license\n    indicated in the file; or\n\n(b) The contribution is based upon previous work that, to the best\n    of my knowledge, is covered under an appropriate open source\n    license and I have the right under that license to submit that\n    work with modifications, whether created in whole or in part\n    by me, under the same open source license (unless I am\n    permitted to submit under a different license), as indicated\n    in the file; or\n\n(c) The contribution was provided directly to me by some other\n    person who certified (a), (b) or (c) and I have not modified\n    it.\n\n(d) I understand and agree that this project and the contribution\n    are public and that a record of the contribution (including all\n    personal information I submit with it, including my sign-off) is\n    maintained indefinitely and may be redistributed consistent with\n    this project or the open source license(s) involved.","category":"page"},{"location":"#BSeries.jl","page":"Home","title":"BSeries.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"BSeries.jl is a collection of functionality around B-series in Julia. See for example","category":"page"},{"location":"","page":"Home","title":"Home","text":"Philippe Chartier, Ernst Hairer, Gilles Vilmart (2010) Algebraic Structures of B-series. Foundations of Computational Mathematics DOI: 10.1007/s10208-010-9065-1","category":"page"},{"location":"","page":"Home","title":"Home","text":"BSeries.jl re-exports everything from RootedTrees.jl. However, if you rely on functionality from that package, you should also include it explicitly in your project dependencies to track breaking changes, since the version numbers of RootedTrees.jl and BSeries.jl are not necessarily synchronized.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The main API of BSeries.jl consists of the following components.","category":"page"},{"location":"","page":"Home","title":"Home","text":"B-series behave like AbstractDicts mapping (abstract) RootedTrees to coefficients.\nThe B-series of time integration methods such as Runge-Kutta methods can be constructed by the function bseries.\nThe algebraic structures of the composition law and the substitution law are implemented via compose and substitute.\nBackward error analysis can be performed via modified_equations and modifying_integrators.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Further information is provided in the following tutorials and API documentation.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"BSeries.jl is a registered Julia package. Thus, you can install it from the Julia REPL via","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> using Pkg; Pkg.add(\"BSeries\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"If you want to update BSeries.jl, you can use","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> using Pkg; Pkg.update(\"BSeries\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"As usual, if you want to update BSeries.jl and all other packages in your current project, you can execute","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> using Pkg; Pkg.update()","category":"page"},{"location":"#Referencing","page":"Home","title":"Referencing","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"If you use BSeries.jl for your research, please cite it using the bibtex entry","category":"page"},{"location":"","page":"Home","title":"Home","text":"@online{ketcheson2021computing,\n  title={Computing with {B}-series},\n  author={Ketcheson, David I and Ranocha, Hendrik},\n  year={2021},\n  month={11},\n  eprint={2111.11680},\n  eprinttype={arXiv},\n  eprintclass={math.NA}\n}","category":"page"},{"location":"","page":"Home","title":"Home","text":"In addition, you can also refer to BSeries.jl directly as","category":"page"},{"location":"","page":"Home","title":"Home","text":"@misc{ranocha2021bseries,\n  title={{BSeries.jl}: {C}omputing with {B}-series in {J}ulia},\n  author={Ranocha, Hendrik and Ketcheson, David I},\n  year={2021},\n  month={09},\n  howpublished={\\url{https://github.com/ranocha/BSeries.jl}},\n  doi={10.5281/zenodo.5534602}\n}","category":"page"},{"location":"","page":"Home","title":"Home","text":"Please also cite the appropriate references for specific functions you use, which can be obtained from their docstrings.","category":"page"},{"location":"#License-and-contributing","page":"Home","title":"License and contributing","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This project is licensed under the MIT license (see License). Since it is an open-source project, we are very happy to accept contributions from the community. Please refer to the section Contributing for more details.","category":"page"},{"location":"tutorials/modified_equations/#tutorial-modified-equation","page":"Modified equations","title":"Modified equations","text":"","category":"section"},{"location":"tutorials/modified_equations/","page":"Modified equations","title":"Modified equations","text":"This tutorial describes the API of BSeries.jl related to the notion of modified equations. The main API entry point is modified_equation.","category":"page"},{"location":"tutorials/modified_equations/","page":"Modified equations","title":"Modified equations","text":"Given a first-order autonomous ordinary differential equation (ODE)","category":"page"},{"location":"tutorials/modified_equations/","page":"Modified equations","title":"Modified equations","text":"u(t) = f(u(t))","category":"page"},{"location":"tutorials/modified_equations/","page":"Modified equations","title":"Modified equations","text":"and a B-series time integration method, the idea is to interpret the numerical solution with given time step size h of the original ODE as the exact solution of the modified ODE","category":"page"},{"location":"tutorials/modified_equations/","page":"Modified equations","title":"Modified equations","text":"u(t) = f_h(u(t))","category":"page"},{"location":"tutorials/modified_equations/","page":"Modified equations","title":"Modified equations","text":"see for example [ChartierHairerVilmart2010].","category":"page"},{"location":"tutorials/modified_equations/#Lotka-Volterra-model","page":"Modified equations","title":"Lotka-Volterra model","text":"","category":"section"},{"location":"tutorials/modified_equations/","page":"Modified equations","title":"Modified equations","text":"Here, we reproduce the example on p. 340 of [HairerLubichWanner2006]. Thus, we consider the explicit Euler method to solve the classical Lotka-Volterra model","category":"page"},{"location":"tutorials/modified_equations/","page":"Modified equations","title":"Modified equations","text":"p(t) = (2 - q) p\nquad\nq(t) = (p - 1) q","category":"page"},{"location":"tutorials/modified_equations/","page":"Modified equations","title":"Modified equations","text":"First, we set up the ODE and compute some numerical solutions using OrdinaryDiffEq.jl.","category":"page"},{"location":"tutorials/modified_equations/","page":"Modified equations","title":"Modified equations","text":"using OrdinaryDiffEq\n\nfunction f(du, u, params, t)\n  p, q = u\n  dp = (2 - q) * p\n  dq = (p - 1) * q\n  du[1] = dp; du[2] = dq\n  return nothing\nend\n\nu0 = [1.5, 2.25]\ntspan = (0.0, 15.0)\node = ODEProblem(f, u0, tspan)\n\ndt = 0.1\nsol_euler = solve(ode, Euler(), dt=dt)\nsol_ref = solve(ode, Tsit5())\nnothing # hide","category":"page"},{"location":"tutorials/modified_equations/","page":"Modified equations","title":"Modified equations","text":"Next, we look at some phase space plots of the numerical solution.","category":"page"},{"location":"tutorials/modified_equations/","page":"Modified equations","title":"Modified equations","text":"using LaTeXStrings, Plots\n\nfig = plot(xguide=L\"$q$\", yguide=L\"$p$\")\ndefault(linewidth=2)\nplot!(fig, sol_ref, vars=(2, 1), label=\"Reference solution\")\nscatter!(fig, last.(sol_euler.u), first.(sol_euler.u),\n         label=\"Explicit Euler, dt = $dt\")\nplot!(fig, xlims=(0.0, 9.0), ylims=(0.0, 5.0))\n\nsavefig(fig, \"lotka_volterra_original.svg\"); nothing # hide","category":"page"},{"location":"tutorials/modified_equations/","page":"Modified equations","title":"Modified equations","text":"(Image: )","category":"page"},{"location":"tutorials/modified_equations/","page":"Modified equations","title":"Modified equations","text":"The exact solution of this problem is periodic, but the explicit Euler method produces an unstable trajectory. Here, we used an especially large time step to more clearly illustrate what will follow, but the qualitative behavior is the same for any time step size.","category":"page"},{"location":"tutorials/modified_equations/","page":"Modified equations","title":"Modified equations","text":"Next, we will derive the \"modified equation\" of the explicit Euler method and solve this new ODE to high accuracy. The perturbed system takes the form of a power series in the time step size dt, and in order to compute with it we will truncate it at a certain order.","category":"page"},{"location":"tutorials/modified_equations/","page":"Modified equations","title":"Modified equations","text":"Here, we use Symbolics.jl for the symbolic computations.","category":"page"},{"location":"tutorials/modified_equations/","page":"Modified equations","title":"Modified equations","text":"using BSeries, StaticArrays, Symbolics\n\nfunction solve_modified_equation(ode, truncation_orders, dt)\n  # Explicit Euler method\n  A = @SArray [0//1;]\n  b = @SArray [1//1]\n  c = @SArray [0//1]\n\n  # Setup of symbolic variables\n  @variables dt_sym\n  u_sym = @variables p q\n  f_sym = similar(u_sym); f(f_sym, u_sym, nothing, nothing)\n\n  sol_euler = solve(ode, Euler(), dt=dt)\n\n  fig = plot(xguide=L\"$q$\", yguide=L\"$p$\")\n  default(linewidth=2)\n  scatter!(fig, last.(sol_euler.u), first.(sol_euler.u),\n          label=\"Explicit Euler, dt = $dt\")\n\n  for truncation_order in truncation_orders\n    series = modified_equation(f_sym, u_sym, dt_sym, A, b, c, truncation_order)\n    series = Symbolics.substitute.(series, dt_sym => dt)\n    modified_f, _ = build_function(series, u_sym, expression=Val(false))\n    modified_ode = ODEProblem((u, params, t) -> modified_f(u), ode.u0, tspan)\n    modified_sol = solve(modified_ode, Tsit5())\n    plot!(fig, modified_sol, vars=(2, 1),\n          label=\"Modified ODE, order $(truncation_order-1)\")\n  end\n  fig\nend\n\nfig = solve_modified_equation(ode, 2, dt)\n\nsavefig(fig, \"lotka_volterra_modified1.svg\"); nothing # hide","category":"page"},{"location":"tutorials/modified_equations/","page":"Modified equations","title":"Modified equations","text":"(Image: )","category":"page"},{"location":"tutorials/modified_equations/","page":"Modified equations","title":"Modified equations","text":"The exact solution of the Lotka-Volterra model is periodic, but Euler's method generates a solution with growing amplitude. The modified equations accurately predict this.","category":"page"},{"location":"tutorials/modified_equations/","page":"Modified equations","title":"Modified equations","text":"Now we go to the next order and increase the time step size dt slightly.","category":"page"},{"location":"tutorials/modified_equations/","page":"Modified equations","title":"Modified equations","text":"fig = solve_modified_equation(ode, 2:3, 0.11)\n\nsavefig(fig, \"lotka_volterra_modified2.svg\"); nothing # hide","category":"page"},{"location":"tutorials/modified_equations/","page":"Modified equations","title":"Modified equations","text":"(Image: )","category":"page"},{"location":"tutorials/modified_equations/","page":"Modified equations","title":"Modified equations","text":"Using a larger step size, we see that the first-order modified equations are not fully accurate, but by including the O(h^2) terms we get much better accuracy at late times. Let's keep going.","category":"page"},{"location":"tutorials/modified_equations/","page":"Modified equations","title":"Modified equations","text":"fig = solve_modified_equation(ode, 2:4, 0.12)\n\nsavefig(fig, \"lotka_volterra_modified3.svg\"); nothing # hide","category":"page"},{"location":"tutorials/modified_equations/","page":"Modified equations","title":"Modified equations","text":"(Image: )","category":"page"},{"location":"tutorials/modified_equations/#References","page":"Modified equations","title":"References","text":"","category":"section"},{"location":"tutorials/modified_equations/","page":"Modified equations","title":"Modified equations","text":"[HairerLubichWanner2006]: ","category":"page"},{"location":"tutorials/modified_equations/","page":"Modified equations","title":"Modified equations","text":"Ernst Hairer, Christian Lubich, Gerhard Wanner (2006)   Geometric Numerical Integration.   DOI: 10.1007/3-540-30666-8","category":"page"},{"location":"tutorials/modified_equations/","page":"Modified equations","title":"Modified equations","text":"[ChartierHairerVilmart2010]: ","category":"page"},{"location":"tutorials/modified_equations/","page":"Modified equations","title":"Modified equations","text":"Philippe Chartier, Ernst Hairer, Gilles Vilmart (2010)   Algebraic Structures of B-series.   Foundations of Computational Mathematics   DOI: 10.1007/s10208-010-9065-1","category":"page"}]
}
