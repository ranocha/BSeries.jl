var documenterSearchIndex = {"docs":
[{"location":"tutorials/symbolic_computations/#tutorial-symbolic-computations","page":"Symbolic computations","title":"Symbolic computations","text":"","category":"section"},{"location":"tutorials/symbolic_computations/","page":"Symbolic computations","title":"Symbolic computations","text":"This tutorial describes some possibilities for symbolic computations based on BSeries.jl. Currently, symbolic computations in BSeries.jl support at least","category":"page"},{"location":"tutorials/symbolic_computations/","page":"Symbolic computations","title":"Symbolic computations","text":"SymEngine.jl,\nSymPy.jl, and\nSymbolics.jl","category":"page"},{"location":"tutorials/symbolic_computations/","page":"Symbolic computations","title":"Symbolic computations","text":"as symbolic backends. You can find some performance comparisons of them in the benchmarks.","category":"page"},{"location":"tutorials/symbolic_computations/#Generating-LaTeX-code","page":"Symbolic computations","title":"Generating LaTeX code","text":"","category":"section"},{"location":"tutorials/symbolic_computations/","page":"Symbolic computations","title":"Symbolic computations","text":"BSeries.jl allow fully symbolic computations of modified_equations and modifying_integrators. More information about these features are available in the respective tutorials. Here, we will also demonstrate how LaTeX code can be generated via Latexify.jl.","category":"page"},{"location":"tutorials/symbolic_computations/","page":"Symbolic computations","title":"Symbolic computations","text":"At the core, BSeries.jl is based on the representation of rooted trees via RootedTrees.jl. Thus, you need to use the setup described in the docstring of RootedTrees.latexify.","category":"page"},{"location":"tutorials/symbolic_computations/#LaTeX-code-of-a-general-modified-equation","page":"Symbolic computations","title":"LaTeX code of a general modified equation","text":"","category":"section"},{"location":"tutorials/symbolic_computations/","page":"Symbolic computations","title":"Symbolic computations","text":"An explicit two-stage, second-order Runge-Kutta method is given by the Butcher tableau","category":"page"},{"location":"tutorials/symbolic_computations/","page":"Symbolic computations","title":"Symbolic computations","text":"beginarrayccc\n  0                  0                    \n  frac12alpha  frac12alpha  0 \n  hline\n                     1 - alpha         alpha\nendarray","category":"page"},{"location":"tutorials/symbolic_computations/","page":"Symbolic computations","title":"Symbolic computations","text":"with real parameter alpha. We can compute the B-series of its modified equation symbolically as follows.","category":"page"},{"location":"tutorials/symbolic_computations/","page":"Symbolic computations","title":"Symbolic computations","text":"using BSeries, SymEngine\n\nα = SymEngine.symbols(\"α\")\nA = [0 0; 1/(2α) 0]\nb = [1-α, α]\nc = [0, 1/(2α)]\n\nseries = modified_equation(A, b, c, 3)","category":"page"},{"location":"tutorials/symbolic_computations/","page":"Symbolic computations","title":"Symbolic computations","text":"To generate the appropriate LaTeX code, we need to remember that the B-series coefficients shown above represent the modified vector field multiplied by the time step size. Thus, we need to pass reduce_order_by = 1 to latexify. Other keyword arguments implemented for B-series are","category":"page"},{"location":"tutorials/symbolic_computations/","page":"Symbolic computations","title":"Symbolic computations","text":"f = \"f\": The symbol used for the indices of the elementary differentials.\ndt = \"h\": The symbol used for the time step size. Alternatively, symbolic variables can also be used.\nreduce_order_by = 0: Reduce the power of the time step size accordingly.","category":"page"},{"location":"tutorials/symbolic_computations/","page":"Symbolic computations","title":"Symbolic computations","text":"using Latexify\nlatexify(series, reduce_order_by=1, dt=SymEngine.symbols(\"h\"), cdot=false) |> println","category":"page"},{"location":"tutorials/symbolic_computations/","page":"Symbolic computations","title":"Symbolic computations","text":"The argument dt=SymEngine.symbols(\"h\") is not required here.","category":"page"},{"location":"tutorials/symbolic_computations/","page":"Symbolic computations","title":"Symbolic computations","text":"using Latexify\nlatexify(series, reduce_order_by=1, cdot=false) |> println","category":"page"},{"location":"tutorials/symbolic_computations/","page":"Symbolic computations","title":"Symbolic computations","text":"We can obtain basically the same result (up to other notations of the coefficients) by dividing the B-series series by a symbolic variable for the time step size as follows.","category":"page"},{"location":"tutorials/symbolic_computations/","page":"Symbolic computations","title":"Symbolic computations","text":"using Latexify\nh = SymEngine.symbols(\"h\")\nlatexify(series / h, cdot=false) |> println","category":"page"},{"location":"tutorials/symbolic_computations/","page":"Symbolic computations","title":"Symbolic computations","text":"We can also use other packages for the symbolic computations, of course. SymPy.jl often provides very clean expressions.","category":"page"},{"location":"tutorials/symbolic_computations/","page":"Symbolic computations","title":"Symbolic computations","text":"using BSeries, SymPy\n\nα = SymPy.symbols(\"α\", real=true)\nA = [0 0; 1/(2α) 0]\nb = [1-α, α]\nc = [0, 1/(2α)]\n\nseries = modified_equation(A, b, c, 3)","category":"page"},{"location":"tutorials/symbolic_computations/","page":"Symbolic computations","title":"Symbolic computations","text":"We can also generate LaTeX code as follows, using the same approach as for SymEngine.jl.","category":"page"},{"location":"tutorials/symbolic_computations/","page":"Symbolic computations","title":"Symbolic computations","text":"using Latexify\nlatexify(series, reduce_order_by=1, dt=SymPy.symbols(\"h\"), cdot=false) |> println","category":"page"},{"location":"tutorials/symbolic_computations/","page":"Symbolic computations","title":"Symbolic computations","text":"We can also use the simplified versions.","category":"page"},{"location":"tutorials/symbolic_computations/","page":"Symbolic computations","title":"Symbolic computations","text":"using Latexify\nlatexify(series, reduce_order_by=1, cdot=false) |> println","category":"page"},{"location":"tutorials/symbolic_computations/","page":"Symbolic computations","title":"Symbolic computations","text":"using Latexify\nh = SymPy.symbols(\"h\", real=true)\nlatexify(series / h, cdot=false) |> println","category":"page"},{"location":"tutorials/symbolic_computations/","page":"Symbolic computations","title":"Symbolic computations","text":"Alternatively, we can also use Symbolics.jl.","category":"page"},{"location":"tutorials/symbolic_computations/","page":"Symbolic computations","title":"Symbolic computations","text":"using BSeries, Symbolics\n\nSymbolics.@variables α\nA = [0 0; 1/(2α) 0]\nb = [1-α, α]\nc = [0, 1/(2α)]\n\nseries = modified_equation(A, b, c, 3)","category":"page"},{"location":"tutorials/symbolic_computations/","page":"Symbolic computations","title":"Symbolic computations","text":"using Latexify\nSymbolics.@variables h\nlatexify(series / h, cdot=false) |> println","category":"page"},{"location":"tutorials/symbolic_computations/#Working-with-rational-coefficients","page":"Symbolic computations","title":"Working with rational coefficients","text":"","category":"section"},{"location":"tutorials/symbolic_computations/","page":"Symbolic computations","title":"Symbolic computations","text":"High-order Runge-Kutta methods are often given in terms of rational coefficients that have large denominators. It's often best to use the rational coefficients in calculations, rather than converting to floating-point, since otherwise terms that ought to cancel may not cancel exactly.  Rational coefficients can be entered by using // for the division operation.","category":"page"},{"location":"tutorials/symbolic_computations/","page":"Symbolic computations","title":"Symbolic computations","text":"By default, Julia uses 64-bit integers for the numerator and denominator of a rational on 64-bit systems.  In practical calculations with high-order RK methods, the denominators may become too large to be represented with 64 bits, leading to overflow.  This can be remedied by specifying higher precision when entering the coefficients:","category":"page"},{"location":"tutorials/symbolic_computations/","page":"Symbolic computations","title":"Symbolic computations","text":"b = Rational{Int128}[(1081252805//134140608),(2639189439//74522560),(33646441//4191894),(-7873511875//210792384),(-504040617//14904512),(2110843561//115277085),(13//7),(1//2)]","category":"page"},{"location":"tutorials/symbolic_computations/","page":"Symbolic computations","title":"Symbolic computations","text":"If even Int128 is not enough, one can specify the type BigInt, which has adjustable precision.","category":"page"},{"location":"tutorials/symbolic_computations/#Setting-up-symbolic-B-series","page":"Symbolic computations","title":"Setting up symbolic B-series","text":"","category":"section"},{"location":"tutorials/symbolic_computations/","page":"Symbolic computations","title":"Symbolic computations","text":"You can also create purely symbolic B-series as starting point of exploratory research, e.g.,","category":"page"},{"location":"tutorials/symbolic_computations/","page":"Symbolic computations","title":"Symbolic computations","text":"using BSeries, SymPy\n\nseries = bseries(5) do t, series\n    return symbols(\"a_$(butcher_representation(t))\", real=true)\nend","category":"page"},{"location":"tutorials/symbolic_computations/","page":"Symbolic computations","title":"Symbolic computations","text":"This B-series can be used as any other B-series, e.g., to compute a  modified equation:","category":"page"},{"location":"tutorials/symbolic_computations/","page":"Symbolic computations","title":"Symbolic computations","text":"modified_equation(series)","category":"page"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"EditURL = \"https://github.com/ranocha/BSeries.jl/blob/main/CONTRIBUTING.md\"","category":"page"},{"location":"contributing/#Contributing","page":"Contributing","title":"Contributing","text":"","category":"section"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"ContributingBSeries.jl is an open-source project and we are very happy to accept contributions from the community. Please feel free to open issues or submit patches (preferably as pull requests) any time. For planned larger contributions, it is often beneficial to get in contact first, for example via issues.BSeries.jl and its contributions are licensed under the MIT license (see License). As a contributor, you certify that all your contributions are in conformance with the Developer Certificate of Origin (Version 1.1), which is reproduced below.Developer Certificate of Origin (Version 1.1)The following text was taken from https://developercertificate.org:Developer Certificate of Origin\nVersion 1.1\n\nCopyright (C) 2004, 2006 The Linux Foundation and its contributors.\n1 Letterman Drive\nSuite D4700\nSan Francisco, CA, 94129\n\nEveryone is permitted to copy and distribute verbatim copies of this\nlicense document, but changing it is not allowed.\n\n\nDeveloper's Certificate of Origin 1.1\n\nBy making a contribution to this project, I certify that:\n\n(a) The contribution was created in whole or in part by me and I\n    have the right to submit it under the open source license\n    indicated in the file; or\n\n(b) The contribution is based upon previous work that, to the best\n    of my knowledge, is covered under an appropriate open source\n    license and I have the right under that license to submit that\n    work with modifications, whether created in whole or in part\n    by me, under the same open source license (unless I am\n    permitted to submit under a different license), as indicated\n    in the file; or\n\n(c) The contribution was provided directly to me by some other\n    person who certified (a), (b) or (c) and I have not modified\n    it.\n\n(d) I understand and agree that this project and the contribution\n    are public and that a record of the contribution (including all\n    personal information I submit with it, including my sign-off) is\n    maintained indefinitely and may be redistributed consistent with\n    this project or the open source license(s) involved.","category":"page"},{"location":"benchmarks/#benchmarks","page":"Benchmarks","title":"Benchmarks","text":"","category":"section"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"Here, we collect some simple benchmarks of BSeries.jl. Take them with a grain of salt since they run on virtual machines in the cloud to generate the documentation automatically. You can of course also copy the code and run the benchmarks locally yourself.","category":"page"},{"location":"benchmarks/#benchmarks-symbolic-computations","page":"Benchmarks","title":"Comparing different symbolic packages","text":"","category":"section"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"Symbolic computations of modified_equations and modifying_integrators in BSeries.jl support","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"SymEngine.jl,\nSymPy.jl, and\nSymbolics.jl","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"as symbolic backends. Here, we compare them in the context of the explicit midpoint method and the nonlinear oscillator ODE","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"u(t) = frac1 u(t) ^2 beginpmatrix -u_2(t)  u_1(t) endpmatrix","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"This particular combination of explicit Runge-Kutta method and ODE is special since the explicit midpoint method is unconditionally energy-conserving for this problem[RanochaKetcheson2020].","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"First, we set up some code to perform the benchmarks. Here, we use a very naive approach, run the code twice (to see the effect of compilation) and use @time to print the runtime. More sophisticated approaches should of course use something like @benchmark from BenchmarkTools.jl. However, this simple and cheap version suffices to compare the orders of magnitude.","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"using BSeries, StaticArrays\n\nfunction benchmark(u, dt, subs, order)\n  # explicit midpoint method\n  A = @SArray [0 0; 1//2 0]\n  b = @SArray [0, 1//1]\n  c = @SArray [0, 1//2]\n\n  # nonlinear oscillator\n  f = [-u[2], u[1]] / (u[1]^2 + u[2]^2)\n\n  println(\"\\n Computing the series coefficients:\")\n  @time coefficients = modifying_integrator(A, b, c, order)\n  @time coefficients = modifying_integrator(A, b, c, order)\n\n  println(\"\\n Computing the series including elementary differentials:\")\n  @time series = modifying_integrator(f, u, dt, A, b, c, order)\n  @time series = modifying_integrator(f, u, dt, A, b, c, order)\n\n  substitution_variables = Dict(u[1] => 1//1, u[2] => 0//1)\n\n  println(\"\\n Substituting the initial condition:\")\n  @time subs.(series, (substitution_variables, ))\n  @time subs.(series, (substitution_variables, ))\n\n  println(\"\\n\")\nend","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"Next, we load the symbolic packages and run the benchmarks.","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"using SymPy # generates annoying output online when conda installs sympy","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"using SymEngine: SymEngine\nusing SymPy: SymPy\nusing Symbolics: Symbolics\n\nprintln(\"SymEngine\")\ndt   = SymEngine.symbols(\"dt\")\nu    = SymEngine.symbols(\"u1, u2\")\nsubs = SymEngine.subs\nbenchmark(u, dt, subs, 8)\n\nprintln(\"SymPy\")\ndt   = SymPy.symbols(\"dt\")\nu    = SymPy.symbols(\"u1, u2\")\nsubs = SymPy.subs\nbenchmark(u, dt, subs, 8)\n\nprintln(\"Symbolics\")\nSymbolics.@variables dt\nu = Symbolics.@variables u1 u2\nsubs = Symbolics.substitute\nbenchmark(u, dt, subs, 8)","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"These results were obtained using the following versions.","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"using InteractiveUtils\nversioninfo()\n\nusing Pkg\nPkg.status([\"BSeries\", \"RootedTrees\", \"SymEngine\", \"SymPy\", \"Symbolics\"],\n           mode=PKGMODE_MANIFEST)\nnothing # hide","category":"page"},{"location":"benchmarks/#benchmarks-other-packages","page":"Benchmarks","title":"Comparison with other packages","text":"","category":"section"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"There are also other open source packages for B-series. Currently, we are aware of the Python packages","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"BSeries\npybs","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"If you know about similar open source packages out there, please inform us, e.g., by creating an issue on GitHub.","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"The packages listed above and BSeries.jl all use different approaches and have different features. Thus, comparisons must be restricted to their common subset of features. Here, we present some simple performance comparisons. Again, we just use (the equivalent of) @time twice to get an idea of the performance after compilation, allowing us to compare orders of magnitude.","category":"page"},{"location":"benchmarks/#Python-package-BSeries","page":"Benchmarks","title":"Python package BSeries","text":"","category":"section"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"First, we start with the Python package BSeries and the following benchmark script.","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"using BSeries, Markdown                                                   # hide\nfilename = joinpath(pathof(BSeries) |> dirname |> dirname, \"docs\", \"src\", # hide\n  \"benchmark_python_bseries.py\")                                          # hide\nscript = \"```python\\n\"                                                    # hide\nfor line in Iterators.drop(readlines(filename), 4)                        # hide\n  startswith(line, \"with\") && continue                                    # hide\n  line = replace(line, \"  print\" => \"print\")                              # hide\n  global script                                                           # hide\n  script = script * replace(line, \", file=io\" => \"\") * \"\\n\"               # hide\nend                                                                       # hide\nscript = script * \"```\\n\"                                                 # hide\nMarkdown.parse(script)                                                    # hide","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"The results are as follows.","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"using BSeries, Markdown                                                   # hide\nfilename = joinpath(pathof(BSeries) |> dirname |> dirname, \"docs\", \"src\", # hide\n  \"benchmark_python_bseries.txt\")                                         # hide\ntry                                                                       # hide\n  results = \"```\\n\" * read(filename, String) * \"```\\n\"                    # hide\n  Markdown.parse(results)                                                 # hide\ncatch                                                                     # hide\n  ci = get(ENV, \"CI\", nothing) == \"true\" &&                               # hide\n       get(ENV, \"GITHUB_REPOSITORY\", nothing) == \"ranocha/Bseries.jl\"     # hide\n  if ci                                                                   # hide\n    rethrow()                                                             # hide\n  else                                                                    # hide\n    println(\"We are not running CI so we do not show results here.\")      # hide\n  end                                                                     # hide\nend                                                                       # hide","category":"page"},{"location":"benchmarks/#Python-package-pybs","page":"Benchmarks","title":"Python package pybs","text":"","category":"section"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"Next, we look at the Python package pybs and the following benchmark script. Note that this package does not provide functionality for modifying integrators.","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"using BSeries, Markdown                                                   # hide\nfilename = joinpath(pathof(BSeries) |> dirname |> dirname, \"docs\", \"src\", # hide\n  \"benchmark_python_pybs.py\")                                             # hide\nscript = \"```python\\n\"                                                    # hide\nfor line in Iterators.drop(readlines(filename), 4)                        # hide\n  startswith(line, \"with\") && continue                                    # hide\n  line = replace(line, \"  print\" => \"print\")                              # hide\n  global script                                                           # hide\n  script = script * replace(line, \", file=io\" => \"\") * \"\\n\"               # hide\nend                                                                       # hide\nscript = script * \"```\\n\"                                                 # hide\nMarkdown.parse(script)                                                    # hide","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"The results are as follows.","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"using BSeries, Markdown                                                   # hide\nfilename = joinpath(pathof(BSeries) |> dirname |> dirname, \"docs\", \"src\", # hide\n  \"benchmark_python_pybs.txt\")                                            # hide\ntry                                                                       # hide\n  results = \"```\\n\" * read(filename, String) * \"```\\n\"                    # hide\n  Markdown.parse(results)                                                 # hide\ncatch                                                                     # hide\n  ci = get(ENV, \"CI\", nothing) == \"true\" &&                               # hide\n       get(ENV, \"GITHUB_REPOSITORY\", nothing) == \"ranocha/Bseries.jl\"     # hide\n  if ci                                                                   # hide\n    rethrow()                                                             # hide\n  else                                                                    # hide\n    println(\"We are not running CI so we do not show results here.\")      # hide\n  end                                                                     # hide\nend                                                                       # hide","category":"page"},{"location":"benchmarks/#Python-package-orderconditions","page":"Benchmarks","title":"Python package orderconditions","text":"","category":"section"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"Next, we look at the Python package orderconditions of Valentin Dallerit and the following benchmark script.","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"using BSeries, Markdown                                                   # hide\nfilename = joinpath(pathof(BSeries) |> dirname |> dirname, \"docs\", \"src\", # hide\n  \"benchmark_python_orderconditions.py\")                                  # hide\nscript = \"```python\\n\"                                                    # hide\nfor line in Iterators.drop(readlines(filename), 4)                        # hide\n  startswith(line, \"with\") && continue                                    # hide\n  line = replace(line, \"  print\" => \"print\")                              # hide\n  global script                                                           # hide\n  script = script * replace(line, \", file=io\" => \"\") * \"\\n\"               # hide\nend                                                                       # hide\nscript = script * \"```\\n\"                                                 # hide\nMarkdown.parse(script)                                                    # hide","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"The results are as follows.","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"using BSeries, Markdown                                                   # hide\nfilename = joinpath(pathof(BSeries) |> dirname |> dirname, \"docs\", \"src\", # hide\n  \"benchmark_python_orderconditions.txt\")                                 # hide\ntry                                                                       # hide\n  results = \"```\\n\" * read(filename, String) * \"```\\n\"                    # hide\n  Markdown.parse(results)                                                 # hide\ncatch                                                                     # hide\n  ci = get(ENV, \"CI\", nothing) == \"true\" &&                               # hide\n       get(ENV, \"GITHUB_REPOSITORY\", nothing) == \"ranocha/Bseries.jl\"     # hide\n  if ci                                                                   # hide\n    rethrow()                                                             # hide\n  else                                                                    # hide\n    println(\"We are not running CI so we do not show results here.\")      # hide\n  end                                                                     # hide\nend                                                                       # hide","category":"page"},{"location":"benchmarks/#This-Julia-package-BSeries.jl","page":"Benchmarks","title":"This Julia package BSeries.jl","text":"","category":"section"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"Finally, we perform the same task using BSeries.jl in Julia.","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"using BSeries, StaticArrays\n\nA = @SArray [0 0; 1//2 0]\nb = @SArray [0, 1//1]\nc = @SArray [0, 1//2]\nup_to_order = 9\n\n\nprintln(\"Modified equation\")\n@time begin\n  series = modified_equation(A, b, c, up_to_order)\n  println(sum(values(series)))\nend\n\n@time begin\n  series = modified_equation(A, b, c, up_to_order)\n  println(sum(values(series)))\nend\n\n\nprintln(\"\\nModifying integrator\")\n@time begin\n  series = modifying_integrator(A, b, c, up_to_order)\n  println(sum(values(series)))\nend\n\n@time begin\n  series = modifying_integrator(A, b, c, up_to_order)\n  println(sum(values(series)))\nend","category":"page"},{"location":"benchmarks/#References","page":"Benchmarks","title":"References","text":"","category":"section"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"[RanochaKetcheson2020]: ","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"Hendrik Ranocha and David Ketcheson (2020)   Energy Stability of Explicit Runge-Kutta Methods for Nonautonomous or   Nonlinear Problems.   SIAM Journal on Numerical Analysis   DOI: 10.1137/19M1290346","category":"page"},{"location":"tutorials/code_generation/#Code-generation","page":"Code generation","title":"Code generation","text":"","category":"section"},{"location":"tutorials/code_generation/","page":"Code generation","title":"Code generation","text":"This tutorial shows how to generate C code to compute expressions found using BSeries.jl. Although BSeries.jl is compatible with three symbolic backends, it's currently easiest to perform code generation using Symbolics.jl.","category":"page"},{"location":"tutorials/code_generation/","page":"Code generation","title":"Code generation","text":"First, we generate the B-series that we want work with. Here we take a generic 2nd-order RK method and generate terms only up to 3rd order, in order to work with the leading truncation error.","category":"page"},{"location":"tutorials/code_generation/","page":"Code generation","title":"Code generation","text":"using BSeries, Latexify, Symbolics\n\n@variables α\nA = [0 0; 1/(2*α) 0]\nb = [1-α, α]\nc = [0, 1/(2*α)]\n\nrk22 = bseries(A, b, c, 3)\nexact = ExactSolution(rk22)\ntruncation_error = rk22 - exact","category":"page"},{"location":"tutorials/code_generation/","page":"Code generation","title":"Code generation","text":"Next we set up the ODE of interest, and evaluate the B-series with that right-hand side.","category":"page"},{"location":"tutorials/code_generation/","page":"Code generation","title":"Code generation","text":"@variables h # time step size\n@variables p q # variables of the ODE\nf = [p * (2 - q), q * (p - 1)]\n\ndu = evaluate(f, [p, q], h, truncation_error)","category":"page"},{"location":"tutorials/code_generation/","page":"Code generation","title":"Code generation","text":"Finally, we generate a C function that evaluates the expressions above.","category":"page"},{"location":"tutorials/code_generation/","page":"Code generation","title":"Code generation","text":"build_function(du, α, p, q, h, target = Symbolics.CTarget())","category":"page"},{"location":"tutorials/code_generation/","page":"Code generation","title":"Code generation","text":"The Symbolics.jl function build_function can also generate code in Julia, MATLAB, and Stan; see the documentation for details and other options.","category":"page"},{"location":"tutorials/modifying_integrators/#tutorial-modifying-integrator","page":"Modifying integrators","title":"Modifying integrators","text":"","category":"section"},{"location":"tutorials/modifying_integrators/","page":"Modifying integrators","title":"Modifying integrators","text":"This tutorial describes the API of BSeries.jl related to the notion of modifying integrators. The main API entry point is modifying_integrator.","category":"page"},{"location":"tutorials/modifying_integrators/","page":"Modifying integrators","title":"Modifying integrators","text":"Given a first-order autonomous ordinary differential equation (ODE)","category":"page"},{"location":"tutorials/modifying_integrators/","page":"Modifying integrators","title":"Modifying integrators","text":"u(t) = f(u(t))","category":"page"},{"location":"tutorials/modifying_integrators/","page":"Modifying integrators","title":"Modifying integrators","text":"and a B-series time integration method, the idea is to find a modified ODE","category":"page"},{"location":"tutorials/modifying_integrators/","page":"Modifying integrators","title":"Modifying integrators","text":"u(t) = f_h(u(t))","category":"page"},{"location":"tutorials/modifying_integrators/","page":"Modifying integrators","title":"Modifying integrators","text":"such that the numerical solution with given time step size h of the original ODE is the exact solution of the modified ODE, see [ChartierHairerVilmart2007] and [ChartierHairerVilmart2010].","category":"page"},{"location":"tutorials/modifying_integrators/#Lotka-Volterra-model","page":"Modifying integrators","title":"Lotka-Volterra model","text":"","category":"section"},{"location":"tutorials/modifying_integrators/","page":"Modifying integrators","title":"Modifying integrators","text":"Here, we consider the explicit Euler method to solve the classical Lotka-Volterra model","category":"page"},{"location":"tutorials/modifying_integrators/","page":"Modifying integrators","title":"Modifying integrators","text":"p(t) = (2 - q) p\nquad\nq(t) = (p - 1) q","category":"page"},{"location":"tutorials/modifying_integrators/","page":"Modifying integrators","title":"Modifying integrators","text":"First, we set up the ODE and compute some numerical solutions using OrdinaryDiffEq.jl.","category":"page"},{"location":"tutorials/modifying_integrators/","page":"Modifying integrators","title":"Modifying integrators","text":"using OrdinaryDiffEq\n\nfunction f!(du, u, params, t)\n  p, q = u\n  dp = (2 - q) * p\n  dq = (p - 1) * q\n  du[1] = dp; du[2] = dq\n  return nothing\nend\n\nu0 = [1.5, 2.25]\ntspan = (0.0, 15.0)\node = ODEProblem(f!, u0, tspan)\n\ndt = 0.35\nsol_euler = solve(ode, Euler(), dt=dt)\nsol_ref = solve(ode, Tsit5())\nnothing # hide","category":"page"},{"location":"tutorials/modifying_integrators/","page":"Modifying integrators","title":"Modifying integrators","text":"Next, we look at some phase space plots of the numerical solution.","category":"page"},{"location":"tutorials/modifying_integrators/","page":"Modifying integrators","title":"Modifying integrators","text":"using LaTeXStrings, Plots\n\nfig = plot(xguide=L\"$q$\", yguide=L\"$p$\")\ndefault(linewidth=2)\nplot!(fig, sol_ref, idxs=(2, 1), label=\"Reference solution\")\nscatter!(fig, last.(sol_euler.u), first.(sol_euler.u),\n         label=\"Explicit Euler, dt = $dt\")\nplot!(fig, xlims=(0.0, 4.0), ylims=(0.0, 2.5))\n\nsavefig(fig, \"lotka_volterra_original.svg\"); nothing # hide","category":"page"},{"location":"tutorials/modifying_integrators/","page":"Modifying integrators","title":"Modifying integrators","text":"(Image: )","category":"page"},{"location":"tutorials/modifying_integrators/","page":"Modifying integrators","title":"Modifying integrators","text":"The exact solution of this problem is periodic, but the explicit Euler method produces an unstable trajectory. Here, we used an especially large time step to more clearly illustrate what will follow, but the qualitative behavior is the same for any time step size.","category":"page"},{"location":"tutorials/modifying_integrators/","page":"Modifying integrators","title":"Modifying integrators","text":"Next, we will derive a \"modifying integrator\". What this means is that we will determine a perturbed ODE right-hand side (RHS) such that when Euler's method is applied to the perturbed RHS, the result is the exact solution to the original Lotka-Volterra system. The perturbed system takes the form of a power series in the time step size dt, and in order to compute with it we will truncate it at a certain order. We can compare the accuracy (and qualitative behavior) obtained by truncating at different orders.","category":"page"},{"location":"tutorials/modifying_integrators/","page":"Modifying integrators","title":"Modifying integrators","text":"Here, we use Symbolics.jl for the symbolic computations.","category":"page"},{"location":"tutorials/modifying_integrators/","page":"Modifying integrators","title":"Modifying integrators","text":"using BSeries, StaticArrays, Symbolics\n\n# Explicit Euler method\nA = @SMatrix [0//1;;]\nb = @SArray [1//1]\nc = @SArray [0//1]\n\n# Setup of symbolic variables\n@variables dt_sym\nu_sym = @variables p q\nf_sym = similar(u_sym); f!(f_sym, u_sym, nothing, nothing)\n\nfor truncation_order in 2:4\n  series = modifying_integrator(f_sym, u_sym, dt_sym, A, b, c, truncation_order)\n  series = Symbolics.substitute.(series, dt_sym => dt)\n  modified_f, _ = build_function(series, u_sym, expression=Val(false))\n  modified_ode = ODEProblem((u, params, t) -> modified_f(u), ode.u0, tspan)\n  modified_sol_euler = solve(modified_ode, Euler(), dt=dt)\n  plot!(fig, modified_sol_euler, idxs=(2, 1),\n        label=\"Euler, modified ODE order $(truncation_order-1)\")\nend\nplot!(fig, xlims=(0.0, 4.0), ylims=(0.0, 2.5))\n\nsavefig(fig, \"lotka_volterra_modified.svg\"); nothing # hide","category":"page"},{"location":"tutorials/modifying_integrators/","page":"Modifying integrators","title":"Modifying integrators","text":"(Image: )","category":"page"},{"location":"tutorials/modifying_integrators/","page":"Modifying integrators","title":"Modifying integrators","text":"We see that if we include one additional term, the resulting trajectory still grows, while with two additional terms the solution appears to be dissipative. With each additional term, the solution gets closer to the exact solution of the original problem, and with three added terms it is hard to see the difference between them at this scale.","category":"page"},{"location":"tutorials/modifying_integrators/#References","page":"Modifying integrators","title":"References","text":"","category":"section"},{"location":"tutorials/modifying_integrators/","page":"Modifying integrators","title":"Modifying integrators","text":"[ChartierHairerVilmart2007]: ","category":"page"},{"location":"tutorials/modifying_integrators/","page":"Modifying integrators","title":"Modifying integrators","text":"Philippe Chartier, Ernst Hairer and Gilles Vilmart (2007)   Numerical integrators based on modified differential equations   DOI: 10.1090/S0025-5718-07-01967-9","category":"page"},{"location":"tutorials/modifying_integrators/","page":"Modifying integrators","title":"Modifying integrators","text":"[ChartierHairerVilmart2010]: ","category":"page"},{"location":"tutorials/modifying_integrators/","page":"Modifying integrators","title":"Modifying integrators","text":"Philippe Chartier, Ernst Hairer, Gilles Vilmart (2010)   Algebraic Structures of B-series.   Foundations of Computational Mathematics   DOI: 10.1007/s10208-010-9065-1","category":"page"},{"location":"tutorials/bseries_basics/#tutorial-bseries-basics","page":"B-series basics","title":"B-series basics","text":"","category":"section"},{"location":"tutorials/bseries_basics/","page":"B-series basics","title":"B-series basics","text":"In this tutorial we use BSeries.jl to investigate error expansions for Runge-Kutta (RK) methods, generically or when applied to a specific ordinary differential equation (ODE).","category":"page"},{"location":"tutorials/bseries_basics/","page":"B-series basics","title":"B-series basics","text":"# Load the packages we will use.\n# These must first be installed using: import Pkg; Pkg.add(\"package_name\")\nusing BSeries\nusing Latexify  # Only needed for some pretty-printing cells below using `latexify`\nimport SymPy; sp=SymPy;","category":"page"},{"location":"tutorials/bseries_basics/#B-series-for-a-generic-ODE","page":"B-series basics","title":"B-series for a generic ODE","text":"","category":"section"},{"location":"tutorials/bseries_basics/","page":"B-series basics","title":"B-series basics","text":"First we specify the Butcher coefficients of the RK method. This can include symbolic expressions and parameterized families of methods. Here is a generic 2-stage, 2nd-order method:","category":"page"},{"location":"tutorials/bseries_basics/","page":"B-series basics","title":"B-series basics","text":"α = sp.symbols(\"α\", real=true)\nA = [0 0; 1/(2*α) 0]; b = [1-α, α]; c = [0, 1/(2*α)]\ncoeffs2 = bseries(A, b, c, 3)\nlatexify(coeffs2, cdot=false)","category":"page"},{"location":"tutorials/bseries_basics/","page":"B-series basics","title":"B-series basics","text":"The rooted trees are printed as nested lists, essentially in the form used in Butcher's book. The rooted trees written in this way can be rendered in LaTeX using the package forest; unfortunately, there is no easy way to render them in the browser. Nevertheless, you can render them using LaTeX with an appropriate preamble, see the docstring of RootedTrees.latexify. The rendered output looks like this:","category":"page"},{"location":"tutorials/bseries_basics/","page":"B-series basics","title":"B-series basics","text":"(Image: bseries_creation_eq1-1)","category":"page"},{"location":"tutorials/bseries_basics/","page":"B-series basics","title":"B-series basics","text":"We have generated the B-series up to terms of order h^3.  The terms F_f() represent elementary differentials, which are products of derivatives of the ODE right-hand side.  Since we haven't specified an ODE, these are indicated simply by the associated rooted tree.","category":"page"},{"location":"tutorials/bseries_basics/","page":"B-series basics","title":"B-series basics","text":"Here is a B-series for the classical 4th-order method, expanded up to 5th-order terms:","category":"page"},{"location":"tutorials/bseries_basics/","page":"B-series basics","title":"B-series basics","text":"A = [0 0 0 0; 1//2 0 0 0; 0 1//2 0 0; 0 0 1 0];\nb = [1//6, 1//3, 1//3, 1//6];\nc = [0, 1//2, 1//2, 1];\n\ncoeffs4 = bseries(A, b, c, 5)\nlatexify(coeffs4, cdot=false)","category":"page"},{"location":"tutorials/bseries_basics/","page":"B-series basics","title":"B-series basics","text":"(Image: bseries_creation_eq2-1)","category":"page"},{"location":"tutorials/bseries_basics/","page":"B-series basics","title":"B-series basics","text":"We can also print out the B-series coefficients this way:","category":"page"},{"location":"tutorials/bseries_basics/","page":"B-series basics","title":"B-series basics","text":"coeffs4","category":"page"},{"location":"tutorials/bseries_basics/","page":"B-series basics","title":"B-series basics","text":"In this form, the rooted trees are printed as level sequences. The corresponding coefficients are on the right.","category":"page"},{"location":"tutorials/bseries_basics/","page":"B-series basics","title":"B-series basics","text":"You can use the function RootedTrees.set_printing_style to change the printing style globally. For example, you can use the notation of Butcher as follows.","category":"page"},{"location":"tutorials/bseries_basics/","page":"B-series basics","title":"B-series basics","text":"RootedTrees.set_printing_style(\"butcher\")\ncoeffs4","category":"page"},{"location":"tutorials/bseries_basics/","page":"B-series basics","title":"B-series basics","text":"To use the level sequence representation, you need to change the printing style again.","category":"page"},{"location":"tutorials/bseries_basics/","page":"B-series basics","title":"B-series basics","text":"RootedTrees.set_printing_style(\"sequence\")\ncoeffs4","category":"page"},{"location":"tutorials/bseries_basics/#Exact-series-and-local-error","page":"B-series basics","title":"Exact series and local error","text":"","category":"section"},{"location":"tutorials/bseries_basics/","page":"B-series basics","title":"B-series basics","text":"We can also get the B-series of the exact solution:","category":"page"},{"location":"tutorials/bseries_basics/","page":"B-series basics","title":"B-series basics","text":"coeffs_ex = ExactSolution(coeffs4)","category":"page"},{"location":"tutorials/bseries_basics/","page":"B-series basics","title":"B-series basics","text":"latexify(coeffs_ex, cdot=false)","category":"page"},{"location":"tutorials/bseries_basics/","page":"B-series basics","title":"B-series basics","text":"(Image: bseries_creation_eq3-1)","category":"page"},{"location":"tutorials/bseries_basics/","page":"B-series basics","title":"B-series basics","text":"We can find the local error by subtracting the exact solution B-series from the RK method B-series:","category":"page"},{"location":"tutorials/bseries_basics/","page":"B-series basics","title":"B-series basics","text":"latexify(coeffs4-coeffs_ex, cdot=false)","category":"page"},{"location":"tutorials/bseries_basics/","page":"B-series basics","title":"B-series basics","text":"(Image: bseries_creation_eq4-1)","category":"page"},{"location":"tutorials/bseries_basics/","page":"B-series basics","title":"B-series basics","text":"This confirms that the method is of 4th order, since all terms involving smaller powers of h vanish exactly.  We don't see the h^6 and higher order terms since we only generated the truncated B-series up to 5th order. We can also obtain the order of accuracy awithout comparing the coefficients to the exact solution manually:","category":"page"},{"location":"tutorials/bseries_basics/","page":"B-series basics","title":"B-series basics","text":"order_of_accuracy(coeffs4)","category":"page"},{"location":"tutorials/bseries_basics/","page":"B-series basics","title":"B-series basics","text":"For the 2nd-order method, we get","category":"page"},{"location":"tutorials/bseries_basics/","page":"B-series basics","title":"B-series basics","text":"order_of_accuracy(coeffs2)","category":"page"},{"location":"tutorials/bseries_basics/","page":"B-series basics","title":"B-series basics","text":"with the following leading error terms:","category":"page"},{"location":"tutorials/bseries_basics/","page":"B-series basics","title":"B-series basics","text":"latexify(coeffs2-coeffs_ex, cdot=false)","category":"page"},{"location":"tutorials/bseries_basics/","page":"B-series basics","title":"B-series basics","text":"(Image: bseries_creation_eq5-1)","category":"page"},{"location":"tutorials/bseries_basics/","page":"B-series basics","title":"B-series basics","text":"This confirms again the accuracy of the method, and shows us that we can eliminate one of the leading error terms completely if we take alpha=34 (this is known as Ralston's method, or sometimes as Heun's method).","category":"page"},{"location":"tutorials/bseries_basics/#B-series-for-a-specific-ODE","page":"B-series basics","title":"B-series for a specific ODE","text":"","category":"section"},{"location":"tutorials/bseries_basics/","page":"B-series basics","title":"B-series basics","text":"Next, let us define an ODE.  We'll consider the Prothero-Robinson problem:","category":"page"},{"location":"tutorials/bseries_basics/","page":"B-series basics","title":"B-series basics","text":"    y(t) = lambda(y-sin(t)) + cos(t)","category":"page"},{"location":"tutorials/bseries_basics/","page":"B-series basics","title":"B-series basics","text":"For a non-autonomous ODE like this, it's convenient to rewrite the problem in autonomous form.  We set u=yt^T and","category":"page"},{"location":"tutorials/bseries_basics/","page":"B-series basics","title":"B-series basics","text":"beginalign\nu_1(t)  = lambda(u_1 - sin(u_2)) + cos(u_2) \nu_2(t)  = t\nendalign","category":"page"},{"location":"tutorials/bseries_basics/","page":"B-series basics","title":"B-series basics","text":"λ = sp.symbols(\"λ\", real=true)\ny, t = sp.symbols(\"y t\", real=true)\nh = sp.symbols(\"h\", real=true)\n\nu = [y, t]\nff = [λ*(u[1]-sin(t))+cos(t), 1]","category":"page"},{"location":"tutorials/bseries_basics/","page":"B-series basics","title":"B-series basics","text":"Finally, we get the B-Series for our RK method applied to our ODE:","category":"page"},{"location":"tutorials/bseries_basics/","page":"B-series basics","title":"B-series basics","text":"evaluate(ff, u, h, coeffs4)[1]","category":"page"},{"location":"tutorials/bseries_basics/","page":"B-series basics","title":"B-series basics","text":"Notice that the series is truncated at the same order that we specified when we initially generated it from the RK coefficients.","category":"page"},{"location":"tutorials/bseries_basics/","page":"B-series basics","title":"B-series basics","text":"Here's the B-Series for the exact solution of the same ODE:","category":"page"},{"location":"tutorials/bseries_basics/","page":"B-series basics","title":"B-series basics","text":"evaluate(ff, u, h, coeffs_ex)[1]","category":"page"},{"location":"tutorials/bseries_basics/","page":"B-series basics","title":"B-series basics","text":"And their difference, which is the local error:","category":"page"},{"location":"tutorials/bseries_basics/","page":"B-series basics","title":"B-series basics","text":"expr = sp.simplify(evaluate(ff, u, h, coeffs4) - evaluate(ff, u, h,coeffs_ex))[1]","category":"page"},{"location":"tutorials/bseries_basics/#B-series-for-a-generic-RK-method","page":"B-series basics","title":"B-series for a generic RK method","text":"","category":"section"},{"location":"tutorials/bseries_basics/","page":"B-series basics","title":"B-series basics","text":"We can also examine just the elementary differentials, without specifying a RK method:","category":"page"},{"location":"tutorials/bseries_basics/","page":"B-series basics","title":"B-series basics","text":"elementary_differentials(ff, u, 5)","category":"page"},{"location":"tutorials/bseries_creation/#tutorial-bseries-creation","page":"Creating B-series","title":"Creating B-series","text":"","category":"section"},{"location":"tutorials/bseries_creation/","page":"Creating B-series","title":"Creating B-series","text":"We have already seen some ways of creating B-series in the basic tutorial. In this tutorial, we look at ways to obtain the B-series of different time integration methods.","category":"page"},{"location":"tutorials/bseries_creation/#B-series-for-Runge-Kutta-methods","page":"Creating B-series","title":"B-series for Runge-Kutta methods","text":"","category":"section"},{"location":"tutorials/bseries_creation/","page":"Creating B-series","title":"Creating B-series","text":"BSeries.jl and RootedTrees.jl provide the type RungeKuttaMethod as wrapper of Butcher coefficients A, b, c of Runge-Kutta methods. For example, you can create the classical explicit, fourth-order Runge-Kutta method as follows.","category":"page"},{"location":"tutorials/bseries_creation/","page":"Creating B-series","title":"Creating B-series","text":"using BSeries\n\n# classical RK4\nA = [0 0 0 0\n      1//2 0 0 0\n      0 1//2 0 0\n      0 0 1 0]\nb = [1 // 6, 1 // 3, 1 // 3, 1 // 6]\nrk = RungeKuttaMethod(A, b)","category":"page"},{"location":"tutorials/bseries_creation/","page":"Creating B-series","title":"Creating B-series","text":"Instead of passing the Butcher coefficients explicitly to bseries, you can also pass the wrapper struct rk. In fact, this is the preferred method.","category":"page"},{"location":"tutorials/bseries_creation/","page":"Creating B-series","title":"Creating B-series","text":"series = bseries(rk, 5)","category":"page"},{"location":"tutorials/bseries_creation/","page":"Creating B-series","title":"Creating B-series","text":"We can check that the classical Runge-Kutta method is indeed fourth-order accurate.","category":"page"},{"location":"tutorials/bseries_creation/","page":"Creating B-series","title":"Creating B-series","text":"series - ExactSolution(series)","category":"page"},{"location":"tutorials/bseries_creation/","page":"Creating B-series","title":"Creating B-series","text":"order_of_accuracy(series)","category":"page"},{"location":"tutorials/bseries_creation/#B-series-for-additive-Runge-Kutta-methods","page":"Creating B-series","title":"B-series for additive Runge-Kutta methods","text":"","category":"section"},{"location":"tutorials/bseries_creation/","page":"Creating B-series","title":"Creating B-series","text":"BSeries.jl and RootedTrees.jl also support additive Runge-Kutta methods via the wrapper AdditiveRungeKuttaMethod. For example, we can write the Störmer-Verlet method as additive Runge-Kutta method following Table II.2.1 of Hairer, Lubich, and Wanner (2002).","category":"page"},{"location":"tutorials/bseries_creation/","page":"Creating B-series","title":"Creating B-series","text":"using BSeries\n\nAs = [\n    [0 0; 1//2 1//2],\n    [1//2 0; 1//2 0],\n]\nbs = [\n    [1 // 2, 1 // 2],\n    [1 // 2, 1 // 2],\n]\nark = AdditiveRungeKuttaMethod(As, bs)","category":"page"},{"location":"tutorials/bseries_creation/","page":"Creating B-series","title":"Creating B-series","text":"We can create the B-series as usual, truncated to order 3.","category":"page"},{"location":"tutorials/bseries_creation/","page":"Creating B-series","title":"Creating B-series","text":"series = bseries(ark, 3)","category":"page"},{"location":"tutorials/bseries_creation/","page":"Creating B-series","title":"Creating B-series","text":"For additive Runge-Kutta methods like this, we use colored rooted trees. Again, we can check the order of accuracy by comparing the coefficients to the exact solution.","category":"page"},{"location":"tutorials/bseries_creation/","page":"Creating B-series","title":"Creating B-series","text":"series - ExactSolution(series)","category":"page"},{"location":"tutorials/bseries_creation/","page":"Creating B-series","title":"Creating B-series","text":"order_of_accuracy(series)","category":"page"},{"location":"tutorials/bseries_creation/","page":"Creating B-series","title":"Creating B-series","text":"We can also create LaTeX code for this B-series as follows.","category":"page"},{"location":"tutorials/bseries_creation/","page":"Creating B-series","title":"Creating B-series","text":"using Latexify\nlatexify(series)","category":"page"},{"location":"tutorials/bseries_creation/","page":"Creating B-series","title":"Creating B-series","text":"When compiled using the preamble code shown in the docstring of RootedTrees.latexify, the output looks as follows.","category":"page"},{"location":"tutorials/bseries_creation/","page":"Creating B-series","title":"Creating B-series","text":"(Image: bseries-SV)","category":"page"},{"location":"tutorials/bseries_creation/#References","page":"Creating B-series","title":"References","text":"","category":"section"},{"location":"tutorials/bseries_creation/","page":"Creating B-series","title":"Creating B-series","text":"Ernst Hairer, Gerhard Wanner, Christian Lubich. Geometric numerical integration. Springer, 2002. DOI: 10.1007/3-540-30666-8","category":"page"},{"location":"tutorials/bseries_creation/#B-series-for-Rosenbrock-methods","page":"Creating B-series","title":"B-series for Rosenbrock methods","text":"","category":"section"},{"location":"tutorials/bseries_creation/","page":"Creating B-series","title":"Creating B-series","text":"BSeries.jl and RootedTrees.jl also support Rosenbrock (Rosenbrock-Wanner, ROW) methods via the wrapper RosenbrockMethod. For example, a classical ROW method of Kaps and Rentrop (1979) can be parameterized as follows.","category":"page"},{"location":"tutorials/bseries_creation/","page":"Creating B-series","title":"Creating B-series","text":"using BSeries\n\nγ = [0.395 0 0 0;\n     -0.767672395484 0.395 0 0;\n     -0.851675323742 0.522967289188 0.395 0;\n     0.288463109545 0.880214273381e-1 -0.337389840627 0.395]\nA = [0 0 0 0;\n     0.438 0 0 0;\n     0.796920457938 0.730795420615e-1 0 0;\n     0.796920457938 0.730795420615e-1 0 0]\nb = [0.199293275701, 0.482645235674, 0.680614886256e-1, 0.25]\nros = RosenbrockMethod(γ, A, b)","category":"page"},{"location":"tutorials/bseries_creation/","page":"Creating B-series","title":"Creating B-series","text":"We can create the B-series as usual, truncated to order 5.","category":"page"},{"location":"tutorials/bseries_creation/","page":"Creating B-series","title":"Creating B-series","text":"series = bseries(ros, 5)","category":"page"},{"location":"tutorials/bseries_creation/","page":"Creating B-series","title":"Creating B-series","text":"Again, we can check the order of accuracy by comparing the coefficients to the exact solution.","category":"page"},{"location":"tutorials/bseries_creation/","page":"Creating B-series","title":"Creating B-series","text":"series - ExactSolution(series)","category":"page"},{"location":"tutorials/bseries_creation/","page":"Creating B-series","title":"Creating B-series","text":"order_of_accuracy(series)","category":"page"},{"location":"tutorials/bseries_creation/#References-2","page":"Creating B-series","title":"References","text":"","category":"section"},{"location":"tutorials/bseries_creation/","page":"Creating B-series","title":"Creating B-series","text":"Peter Kaps and Peter Rentrop. \"Generalized Runge-Kutta methods of order four with stepsize control for stiff ordinary differential equations.\" Numerische Mathematik 33, no. 1 (1979): 55-68. DOI: 10.1007/BF01396495","category":"page"},{"location":"tutorials/bseries_creation/#tutorial-bseries-creation-AVF","page":"Creating B-series","title":"B-series for the average vector field method","text":"","category":"section"},{"location":"tutorials/bseries_creation/","page":"Creating B-series","title":"Creating B-series","text":"Consider the autonomous ODE","category":"page"},{"location":"tutorials/bseries_creation/","page":"Creating B-series","title":"Creating B-series","text":"u(t) = fbigl( u(t) bigr)","category":"page"},{"location":"tutorials/bseries_creation/","page":"Creating B-series","title":"Creating B-series","text":"The average vector field method","category":"page"},{"location":"tutorials/bseries_creation/","page":"Creating B-series","title":"Creating B-series","text":"u^n+1 = u^n + Delta t int_0^1 fbigl(xi u^n+1 + (1 - xi) u^nbigr) mathrmd xi","category":"page"},{"location":"tutorials/bseries_creation/","page":"Creating B-series","title":"Creating B-series","text":"introduced by McLachlan, Quispel, and Robidoux (1999) is a second-order accurate method. Quispel and McLaren (2008) discovered that it is indeed a B-series method. Its coefficients are given explicitly as","category":"page"},{"location":"tutorials/bseries_creation/","page":"Creating B-series","title":"Creating B-series","text":"beginalign*\nb() = 1 \nb(t_1  t_n) = b(t_1)b(t_n)  (n + 1)\nendalign*","category":"page"},{"location":"tutorials/bseries_creation/","page":"Creating B-series","title":"Creating B-series","text":"by Celledoni, McLachlan, McLaren, Owren, Quispel, and Wright (2009). We can implement this up to order 5 in BSeries.jl as follows.","category":"page"},{"location":"tutorials/bseries_creation/","page":"Creating B-series","title":"Creating B-series","text":"using BSeries\n\nseries = bseries(5) do t, series\n    if order(t) in (0, 1)\n        return 1 // 1\n    else\n        v = 1 // 1\n        n = 0\n        for subtree in SubtreeIterator(t)\n            v *= series[subtree]\n            n += 1\n        end\n        return v / (n + 1)\n    end\nend","category":"page"},{"location":"tutorials/bseries_creation/","page":"Creating B-series","title":"Creating B-series","text":"We can check that this method is second-order accurate by comparing it to the B-series of the exact solution, truncated at the same order.","category":"page"},{"location":"tutorials/bseries_creation/","page":"Creating B-series","title":"Creating B-series","text":"series - ExactSolution(series)","category":"page"},{"location":"tutorials/bseries_creation/","page":"Creating B-series","title":"Creating B-series","text":"order_of_accuracy(series)","category":"page"},{"location":"tutorials/bseries_creation/#References-3","page":"Creating B-series","title":"References","text":"","category":"section"},{"location":"tutorials/bseries_creation/","page":"Creating B-series","title":"Creating B-series","text":"Robert I. McLachlan, G. Reinout W. Quispel, and Nicolas Robidoux. \"Geometric integration using discrete gradients.\" Philosophical Transactions of the Royal Society of London. Series A: Mathematical, Physical and Engineering Sciences 357, no. 1754 (1999): 1021-1045. DOI: 10.1098/rsta.1999.0363\nG. Reinout W. Quispel, and David Ian McLaren. \"A new class of energy-preserving numerical integration methods.\" Journal of Physics A: Mathematical and Theoretical 41, no. 4 (2008): 045206. DOI: 10.1088/1751-8113/41/4/045206\nElena Celledoni, Robert I. McLachlan, David I. McLaren, Brynjulf Owren, G. Reinout W. Quispel, and William M. Wright. \"Energy-preserving Runge-Kutta methods.\" ESAIM: Mathematical Modelling and Numerical Analysis 43, no. 4 (2009): 645-649. DOI: 10.1051/m2an/2009020","category":"page"},{"location":"tutorials/bseries_creation/#tutorial-bseries-creation-compose","page":"Creating B-series","title":"Composing B-series","text":"","category":"section"},{"location":"tutorials/bseries_creation/","page":"Creating B-series","title":"Creating B-series","text":"B-series representing a mapping such as a time integration method can be composed. This operation is equivalent to performing a step with one method after another. Here, we present the example of Butcher's method of effective order 5. This is a fourth-order Runge-Kutta method resulting in a fifth-order method when composed with a special starting and finishing procedure.","category":"page"},{"location":"tutorials/bseries_creation/","page":"Creating B-series","title":"Creating B-series","text":"First, we set up the B-series of the main method (method \"a\" in Butcher's paper):","category":"page"},{"location":"tutorials/bseries_creation/","page":"Creating B-series","title":"Creating B-series","text":"using BSeries\n\nA = [0 0 0 0 0;\n     1//5 0 0 0 0;\n     0 2//5 0 0 0;\n     3//16 0 5//16 0 0;\n     1//4 0 -5//4 2 0]\nb = [1 // 6, 0, 0, 2 // 3, 1 // 6]\nrk_a = RungeKuttaMethod(A, b)\nseries_a = bseries(rk_a, 6)","category":"page"},{"location":"tutorials/bseries_creation/","page":"Creating B-series","title":"Creating B-series","text":"Note that this method is fourth-order accurate:","category":"page"},{"location":"tutorials/bseries_creation/","page":"Creating B-series","title":"Creating B-series","text":"order_of_accuracy(series_a)","category":"page"},{"location":"tutorials/bseries_creation/","page":"Creating B-series","title":"Creating B-series","text":"Next, we set up the starting procedure (method \"b\" in Butcher's paper):","category":"page"},{"location":"tutorials/bseries_creation/","page":"Creating B-series","title":"Creating B-series","text":"A = [0 0 0 0 0;\n     1//5 0 0 0 0;\n     0 2//5 0 0 0;\n     75//64 -9//4 117//64 0 0;\n     -37//36 7//3 -3//4 4//9 0]\nb = [19 // 144, 0, 25 // 48, 2 // 9, 1 // 8]\nrk_b = RungeKuttaMethod(A, b)\nseries_b = bseries(rk_b, 6)","category":"page"},{"location":"tutorials/bseries_creation/","page":"Creating B-series","title":"Creating B-series","text":"order_of_accuracy(series_b)","category":"page"},{"location":"tutorials/bseries_creation/","page":"Creating B-series","title":"Creating B-series","text":"Note that this method is only third-order accurate - as is the finishing procedure given by","category":"page"},{"location":"tutorials/bseries_creation/","page":"Creating B-series","title":"Creating B-series","text":"A = [0 0 0 0 0;\n     1//5 0 0 0 0;\n     0 2//5 0 0 0;\n     161//192 -19//12 287//192 0 0;\n     -27//28 19//7 -291//196 36//49 0]\nb = [7 // 48, 0, 475 // 1008, 2 // 7, 7 // 72]\nrk_c = RungeKuttaMethod(A, b)\nseries_c = bseries(rk_c, 6)","category":"page"},{"location":"tutorials/bseries_creation/","page":"Creating B-series","title":"Creating B-series","text":"order_of_accuracy(series_c)","category":"page"},{"location":"tutorials/bseries_creation/","page":"Creating B-series","title":"Creating B-series","text":"Finally, we can compose the three methods to obtain","category":"page"},{"location":"tutorials/bseries_creation/","page":"Creating B-series","title":"Creating B-series","text":"series = compose(series_b, series_a, series_c, normalize_stepsize = true)","category":"page"},{"location":"tutorials/bseries_creation/","page":"Creating B-series","title":"Creating B-series","text":"Note that this composition has to be read from left to right. Finally, we check that the resulting series is indeed fifth-order accurate:","category":"page"},{"location":"tutorials/bseries_creation/","page":"Creating B-series","title":"Creating B-series","text":"order_of_accuracy(series)","category":"page"},{"location":"tutorials/bseries_creation/","page":"Creating B-series","title":"Creating B-series","text":"series - ExactSolution(series)","category":"page"},{"location":"tutorials/bseries_creation/#References-4","page":"Creating B-series","title":"References","text":"","category":"section"},{"location":"tutorials/bseries_creation/","page":"Creating B-series","title":"Creating B-series","text":"Butcher, J. C. \"The effective order of Runge-Kutta methods.\" In Conference on the numerical solution of differential equations, pp. 133-139. Springer, Berlin, Heidelberg, 1969. DOI: 10.1007/BFb0060019","category":"page"},{"location":"tutorials/rk_order_conditions/#Runge-Kutta-order-conditions","page":"Runge-Kutta order conditions","title":"Runge-Kutta order conditions","text":"","category":"section"},{"location":"tutorials/rk_order_conditions/","page":"Runge-Kutta order conditions","title":"Runge-Kutta order conditions","text":"In this tutorial, we generate order conditions for a generic explicit Runge-Kutta method.","category":"page"},{"location":"tutorials/rk_order_conditions/","page":"Runge-Kutta order conditions","title":"Runge-Kutta order conditions","text":"First, we create symbolic coefficient arrays with the appropriate structure. There are several symbolic packages you can use. Here, we will use SymPy.jl.","category":"page"},{"location":"tutorials/rk_order_conditions/","page":"Runge-Kutta order conditions","title":"Runge-Kutta order conditions","text":"using BSeries, SymPy, Latexify\n\ns = 4  # Stages\np = 4  # Desired order of accuracy\n\nA = Array{Sym,2}(undef, s, s)\nb = Array{Sym,1}(undef, s)\nc = Array{Sym,1}(undef, s);\nfor i in 1:s\n    b[i] = symbols(\"b$i\", real = true)\n    for j in 1:i-1\n        A[i, j] = symbols(\"a$i$j\", real = true)\n    end\n    for j in i:s\n        A[i, j] = 0\n    end\nend\n\nfor i in 1:s\n    c[i] = 0\n    for j in 1:i-1\n        c[i] += A[i, j]\n    end\nend","category":"page"},{"location":"tutorials/rk_order_conditions/","page":"Runge-Kutta order conditions","title":"Runge-Kutta order conditions","text":"Next we generate the B-series for the RK method and the exact solution, and take their difference.","category":"page"},{"location":"tutorials/rk_order_conditions/","page":"Runge-Kutta order conditions","title":"Runge-Kutta order conditions","text":"\nrk3 = bseries(A, b, c, p)\nexact = ExactSolution(rk3)\nerror = rk3 - exact","category":"page"},{"location":"tutorials/rk_order_conditions/","page":"Runge-Kutta order conditions","title":"Runge-Kutta order conditions","text":"The output above is truncated.  We can see the full expressions as follows:","category":"page"},{"location":"tutorials/rk_order_conditions/","page":"Runge-Kutta order conditions","title":"Runge-Kutta order conditions","text":"for (tree, order_condition) in error\n    println(order_condition)\nend","category":"page"},{"location":"api_reference/#API-reference","page":"API reference","title":"API reference","text":"","category":"section"},{"location":"api_reference/#BSeries.jl-API","page":"API reference","title":"BSeries.jl API","text":"","category":"section"},{"location":"api_reference/","page":"API reference","title":"API reference","text":"CurrentModule = BSeries","category":"page"},{"location":"api_reference/","page":"API reference","title":"API reference","text":"Modules = [BSeries]","category":"page"},{"location":"api_reference/#BSeries.BSeries","page":"API reference","title":"BSeries.BSeries","text":"BSeries\n\n(Image: Docs-stable) (Image: Docs-dev) (Image: Build Status) (Image: Coveralls) (Image: Codecov) (Image: License: MIT) (Image: DOI)\n\nA collection of functionality around B-series in Julia. See\n\nPhilippe Chartier, Ernst Hairer, Gilles Vilmart (2010) Algebraic Structures of B-series. Foundations of Computational Mathematics DOI: 10.1007/s10208-010-9065-1\n\nAPI Documentation\n\nThe API of BSeries.jl is documented in the online documentation. Information on each function is available in their docstrings.\n\nBSeries.jl re-exports everything from RootedTrees.jl. However, if you rely on functionality from that package, you should also include it explicitly in your project dependencies to track breaking changes, since the version numbers of RootedTrees.jl and BSeries.jl are not necessarily synchronized.\n\nThe main API of BSeries.jl consists of the following components.\n\nB-series behave like AbstractDicts mapping RootedTrees to coefficients.\nThe B-series of time integration methods such as Runge-Kutta methods can be constructed by the function bseries.\nVector space operations (addition/subtraction and multiplication by scalars) are available.\nThe algebraic structures of the composition law and the substitution law are implemented via compose and substitute.\nBackward error analysis can be performed via modified_equations and modifying_integrators.\n\nPlease consult the documentation or the docstrings for further information.\n\nPlease note that B-series analysis is most conveniently applied to the autonomous form of ordinary differential equations (ODEs). Thus, BSeries.jl and RootedTrees.jl usually assume that time integration methods give the same result, independent of whether an ODE is written in an autonomous or a non-autonomous form. For Runge-Kutta methods, this means that the usual row-sum assumption is used.\n\nReferencing\n\nIf you use BSeries.jl for your research, please cite it using the bibtex entry\n\n@article{ketcheson2022computing,\n  title={Computing with {B}-series},\n  author={Ketcheson, David I and Ranocha, Hendrik},\n  journal={ACM Transactions on Mathematical Software},\n  year={2022},\n  month={12},\n  doi={10.1145/3573384},\n  eprint={2111.11680},\n  eprinttype={arXiv},\n  eprintclass={math.NA}\n}\n\nIn addition, you can also refer to BSeries.jl directly as\n\n@misc{ranocha2021bseries,\n  title={{BSeries.jl}: {C}omputing with {B}-series in {J}ulia},\n  author={Ranocha, Hendrik and Ketcheson, David I},\n  year={2021},\n  month={09},\n  howpublished={\\url{https://github.com/ranocha/BSeries.jl}},\n  doi={10.5281/zenodo.5534602}\n}\n\nLicense and contributing\n\nThis project is licensed under the MIT license (see LICENSE.md). Since it is an open-source project, we are very happy to accept contributions from the community. Please refer to CONTRIBUTING.md for more details.\n\n\n\n\n\n","category":"module"},{"location":"api_reference/#BSeries.AverageVectorFieldMethod","page":"API reference","title":"BSeries.AverageVectorFieldMethod","text":"AverageVectorFieldMethod([T=Rational{Int}])\n\nConstruct a representation of the average vector field (AVF) method using coefficients of type T. You can pass it as argument to bseries to construct the corresponding B-series.\n\nExamples\n\nWe can generate this as follows.\n\njulia> series = bseries(AverageVectorFieldMethod(), 3)\nTruncatedBSeries{RootedTree{Int64, Vector{Int64}}, Rational{Int64}} with 5 entries:\n  RootedTree{Int64}: Int64[]   => 1//1\n  RootedTree{Int64}: [1]       => 1//1\n  RootedTree{Int64}: [1, 2]    => 1//2\n  RootedTree{Int64}: [1, 2, 3] => 1//4\n  RootedTree{Int64}: [1, 2, 2] => 1//3\n\nReferences\n\nThe B-series of the average vector field (AVF) method is given by b() = 1 and b(t_1  t_n) = b(t_1)b(t_n)  (n + 1), see\n\nElena Celledoni, Robert I. McLachlan, David I. McLaren, Brynjulf Owren, G. Reinout W. Quispel, and William M. Wright. \"Energy-preserving Runge-Kutta methods.\" ESAIM: Mathematical Modelling and Numerical Analysis 43, no. 4 (2009): 645-649. DOI: 10.1051/m2an/2009020\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#BSeries.ExactSolution","page":"API reference","title":"BSeries.ExactSolution","text":"ExactSolution{V}()\n\nLazy representation of the B-series of the exact solution of an ordinary differential equation using coefficients of type at least as representative as V.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#BSeries.ExactSolution-Tuple{Any}","page":"API reference","title":"BSeries.ExactSolution","text":"ExactSolution(series_integrator)\n\nA representation of the B-series of the exact solution of an ODE using the same type of coefficients as the B-series series_integrator.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#BSeries.MultirateInfinitesimalSplitMethod","page":"API reference","title":"BSeries.MultirateInfinitesimalSplitMethod","text":"MultirateInfinitesimalSplitMethod(A, D, G, c)\n\nReferences\n\nKnoth, Oswald, and Joerg Wensch. \"Generalized split-explicit Runge-Kutta methods for the compressible Euler equations\". Monthly Weather Review 142, no. 5 (2014): 2067-2081. DOI: 10.1175/MWR-D-13-00068.1\n\nwarning: Experimental code\nThis code is considered to be experimental at the moment and can change any time.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#BSeries.TruncatedBSeries","page":"API reference","title":"BSeries.TruncatedBSeries","text":"TruncatedBSeries\n\nA struct that can describe B-series of both numerical integration methods (where the coefficient of the empty tree is unity) and right-hand sides of an ordinary differential equation and perturbations thereof (where the coefficient of the empty tree is zero) up to a prescribed order.\n\nGenerally, this kind of struct should be constructed via bseries or one of the other functions returning a B-series, e.g., modified_equation or modifying_integrator.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#BSeries.bseries","page":"API reference","title":"BSeries.bseries","text":"bseries(f::Function, order, iterator_type=RootedTreeIterator)\n\nReturn a truncated B-series up to the specified order with coefficients determined by f. The type of rooted trees is determined by the iterator_type, which can be RootedTreeIterator or BicoloredRootedTreeIterator. Calling f(t, series) needs to return the coefficient of the rooted tree t of the desired series in a type-stable manner. For the empty tree, f is called as f(t, nothing). Otherwise, the series constructed so far is passed as second argument, allowing one to access values of lower-order trees.\n\nnote: Normalization by elementary differentials\nThe coefficients of the B-series returned by this method need to be multiplied by a power of the time step divided by the symmetry of the rooted tree and multiplied by the corresponding elementary differential of the input vector field f. See also evaluate.\n\nExamples\n\nThe B-series of the average vector field (AVF) method is given by b() = 1 and b(t_1  t_n) = b(t_1)b(t_n)  (n + 1), see\n\nElena Celledoni, Robert I. McLachlan, David I. McLaren, Brynjulf Owren, G. Reinout W. Quispel, and William M. Wright. \"Energy-preserving Runge-Kutta methods.\" ESAIM: Mathematical Modelling and Numerical Analysis 43, no. 4 (2009): 645-649. DOI: 10.1051/m2an/2009020\n\nWe can generate this as follows.\n\njulia> series = bseries(3) do t, series\n           if order(t) in (0, 1)\n               return 1 // 1\n           else\n               v = 1 // 1\n               n = 0\n               for subtree in SubtreeIterator(t)\n                   v *= series[subtree]\n                   n += 1\n               end\n               return v / (n + 1)\n           end\n       end\nTruncatedBSeries{RootedTree{Int64, Vector{Int64}}, Rational{Int64}} with 5 entries:\n  RootedTree{Int64}: Int64[]   => 1//1\n  RootedTree{Int64}: [1]       => 1//1\n  RootedTree{Int64}: [1, 2]    => 1//2\n  RootedTree{Int64}: [1, 2, 3] => 1//4\n  RootedTree{Int64}: [1, 2, 2] => 1//3\n\n\n\n\n\n","category":"function"},{"location":"api_reference/#BSeries.bseries-Tuple{AdditiveRungeKuttaMethod, Any}","page":"API reference","title":"BSeries.bseries","text":"bseries(ark::AdditiveRungeKuttaMethod, order)\n\nCompute the B-series of the additive Runge-Kutta method ark up to a prescribed integer order.\n\nnote: Normalization by elementary differentials\nThe coefficients of the B-series returned by this method need to be multiplied by a power of the time step divided by the symmetry of the colored rooted tree and multiplied by the corresponding elementary differential of the input vector fields f^nu. See also evaluate.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#BSeries.bseries-Tuple{MultirateInfinitesimalSplitMethod, Any}","page":"API reference","title":"BSeries.bseries","text":"bseries(mis::MultirateInfinitesimalSplitMethod, order)\n\nCompute the B-series of the multirate infinitesimal split method mis up to a prescribed integer order.\n\nnote: Normalization by elementary differentials\nThe coefficients of the B-series returned by this method need to be multiplied by a power of the time step divided by the symmetry of the colored rooted tree and multiplied by the corresponding elementary differential of the input vector fields f^nu. See also evaluate.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#BSeries.bseries-Tuple{RosenbrockMethod, Any}","page":"API reference","title":"BSeries.bseries","text":"bseries(ros::RosenbrockMethod, order)\n\nCompute the B-series of the Rosenbrock method ros up to a prescribed integer order.\n\nnote: Normalization by elementary differentials\nThe coefficients of the B-series returned by this method need to be multiplied by a power of the time step divided by the symmetry of the rooted tree and multiplied by the corresponding elementary differential of the input vector field f. See also evaluate.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#BSeries.bseries-Tuple{RungeKuttaMethod, Any}","page":"API reference","title":"BSeries.bseries","text":"bseries(rk::RungeKuttaMethod, order)\nbseries(A::AbstractMatrix, b::AbstractVector, c::AbstractVector, order)\n\nCompute the B-series of the Runge-Kutta method rk with Butcher coefficients A, b, c up to a prescribed integer order.\n\nnote: Normalization by elementary differentials\nThe coefficients of the B-series returned by this method need to be multiplied by a power of the time step divided by the symmetry of the rooted tree and multiplied by the corresponding elementary differential of the input vector field f. See also evaluate.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#BSeries.bseries-Union{Tuple{T}, Tuple{AverageVectorFieldMethod{T}, Any}} where T","page":"API reference","title":"BSeries.bseries","text":"bseries(avf::AverageVectorFieldMethod, order)\n\nCompute the B-series of the AverageVectorFieldMethod up to a prescribed integer order.\n\nnote: Normalization by elementary differentials\nThe coefficients of the B-series returned by bseries need to be multiplied by a power of the time step divided by the symmetry of the rooted tree and multiplied by the corresponding elementary differential of the input vector field f. See also evaluate.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#BSeries.compose-Tuple{Any, Any, RootedTree}","page":"API reference","title":"BSeries.compose","text":"compose(b, a, t::RootedTree)\n\nCompute the coefficient corresponding to the tree t of the B-series that is formed by composing the B-series a with the B-series b. It is assumed that the B-series b has the coefficient unity of the empty tree.\n\nReferences\n\nSection 3.1 of\n\nPhilippe Chartier, Ernst Hairer, Gilles Vilmart (2010) Algebraic Structures of B-series. Foundations of Computational Mathematics DOI: 10.1007/s10208-010-9065-1\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#BSeries.compose-Tuple{Any, Any}","page":"API reference","title":"BSeries.compose","text":"compose(b, a; normalize_stepsize=false)\n\nCompose the B-series a with the B-series b. It is assumed that the B-series b has the coefficient unity of the empty tree.\n\nIn the notation of Chartier, Hairer and Vilmart (2010), we have compose(b, a) = b ⋅ a. Note that this means that method b is applied first, followed by method a.\n\nIf normalize_stepsize = true, the coefficients of the returned B-series are divided by 2^order(t) for each rooted tree t. This normalizes the step size so that the resulting numerical integrator B-series uses the same step size as the input series (instead of a doubled step size).\n\nReferences\n\nSection 3.1 of\n\nPhilippe Chartier, Ernst Hairer, Gilles Vilmart (2010) Algebraic Structures of B-series. Foundations of Computational Mathematics DOI: 10.1007/s10208-010-9065-1\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#BSeries.compose-Union{Tuple{N}, Tuple{Any, Any, Vararg{Any, N}}} where N","page":"API reference","title":"BSeries.compose","text":"compose(b1, b2, bs...; normalize_stepsize=false)\n\nCompose the B-series b1, b2, bs.... It is assumed that all B-series have the coefficient unity of the empty tree.\n\nIn the notation of Chartier, Hairer and Vilmart (2010), we have compose(b1, b2, b3) = b1 ⋅ b2 ⋅ b3. Note that this product is associative and has to be read from left to right, i.e., method b1 is applied first, followed by b2, bs....\n\nIf normalize_stepsize = true, the coefficients of the returned B-series are divided by n^order(t) for each rooted tree t, where n is the total number of composed B-series. This normalizes the step size so that the resulting numerical integrator B-series uses the same step size as the input series (instead of an n-fold step size).\n\nReferences\n\nSection 3.1 of\n\nPhilippe Chartier, Ernst Hairer, Gilles Vilmart (2010) Algebraic Structures of B-series. Foundations of Computational Mathematics DOI: 10.1007/s10208-010-9065-1\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#BSeries.compute_derivative","page":"API reference","title":"BSeries.compute_derivative","text":"compute_derivative(expression, variable)\n\nInternal function specialized on symbolic variables and expressions from\n\nSymEngine.jl,\nSymPy.jl, and\nSymbolics.jl\n\nif these packages are loaded (via Requires.jl).\n\n\n\n\n\n","category":"function"},{"location":"api_reference/#BSeries.elementary_differentials-Tuple{AbstractVector, Any, Any}","page":"API reference","title":"BSeries.elementary_differentials","text":"elementary_differentials(f::AbstractVector, u, order)\n\nCompute all elementary differentials of the vector field f with independent variables u up to the given order. The return value can be indexed by rooted trees to obtain the corresponding elementary differential.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#BSeries.elementary_differentials-Tuple{Tuple{AbstractVector, AbstractVector}, Any, Any}","page":"API reference","title":"BSeries.elementary_differentials","text":"elementary_differentials(fs::NTuple{2, AbstractVector}, u, order)\n\nCompute all elementary differentials of the sum of the two vector fields f with independent variables u up to the given order. The return value can be indexed by (bi-) colored rooted trees to obtain the corresponding elementary differential.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#BSeries.energy_preserving_order-Tuple{RungeKuttaMethod, Any}","page":"API reference","title":"BSeries.energy_preserving_order","text":"energy_preserving(rk::RungeKuttaMethod, max_order)\n\nThis function checks up to which order a Runge-Kitta method 'rk' is energy-preserving for Hamiltonian problems. It requires a 'maxorder' so that it does not run forever if the order up to which the method is energypreserving is too big or infinite.\n\nSee also is_energy_preserving\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#BSeries.evaluate","page":"API reference","title":"BSeries.evaluate","text":"evaluate(f, u, dt, series, reduce_order_by=0)\n\nEvaluate the B-series series specialized to the ordinary differential equation u(t) = f(u(t)) with vector field f and dependent variables u for a time step size dt.\n\nHere, u is assumed to be a vector of symbolic variables and f is assumed to be a vector of expressions in these variables for plain B-series. For B-series with colored trees, f must be a tuple of vectors of expressions in the variables u. Currently, symbolic variables from\n\nSymEngine.jl,\nSymPy.jl, and\nSymbolics.jl\n\nare supported.\n\nThe powers of dt can be controlled by reduce_order_by to make them different from the usual order(t) for a rooted tree t. This can be useful in the context of modified_equations or modifying_integrators, where the B-series coefficients are those of h fₕ, i.e., they contain an additional power of dt. In this case, the B-series of the vector field can be obtained using reduce_order_by = 1.\n\nReferences\n\nSection 3.2 of\n\nPhilippe Chartier, Ernst Hairer, Gilles Vilmart (2010) Algebraic Structures of B-series. Foundations of Computational Mathematics DOI: 10.1007/s10208-010-9065-1\n\n\n\n\n\n","category":"function"},{"location":"api_reference/#BSeries.is_energy_preserving-Tuple{Any}","page":"API reference","title":"BSeries.is_energy_preserving","text":"is_energy_preserving(series_integrator)::Bool\n\nThis function checks whether the B-series series_integrator of a time integration method is energy-preserving for Hamiltonian systems - up to the order of series_integrator.\n\nReferences\n\nThis code is based on the Theorem 2 of\n\nElena Celledoni, Robert I. McLachlan, Brynjulf Owren, and G. R. W. Quispel. \"Energy-preserving integrators and the structure of B-series.\" Foundations of Computational Mathematics 10 (2010): 673-693. DOI: 10.1007/s10208-010-9073-1\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#BSeries.is_energy_preserving-Tuple{RungeKuttaMethod, Any}","page":"API reference","title":"BSeries.is_energy_preserving","text":"is_energy_preserving(rk::RungeKuttaMethod, order)::Bool\n\nThis function checks whether the Runge-Kutta method rk is energy-preserving for Hamiltonian systems up to a given order.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#BSeries.modified_equation-NTuple{4, Any}","page":"API reference","title":"BSeries.modified_equation","text":"modified_equation(f, u, dt, series_integrator)\n\nCompute the B-series of the modified_equation of the time integration method with B-series series_integrator with respect to the ordinary differential equation u(t) = f(u(t)) with vector field f and dependent variables u for a time step size dt.\n\nHere, u is assumed to be a vector of symbolic variables and f is assumed to be a vector of expressions in these variables for plain B-series. For B-series with colored trees, f must be a tuple of vectors of expressions in the variables u. Currently, symbolic variables from\n\nSymEngine.jl,\nSymPy.jl, and\nSymbolics.jl\n\nare supported.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#BSeries.modified_equation-Tuple{Any, Any, Any, RungeKuttaMethod, Any}","page":"API reference","title":"BSeries.modified_equation","text":"modified_equation(f, u, dt, rk::RungeKuttaMethod, order)\nmodified_equation(f, u, dt,\n                  A::AbstractMatrix, b::AbstractVector, c::AbstractVector,\n                  order)\n\nCompute the B-series of the modified_equation of the Runge-Kutta method rk with Butcher coefficients A, b, c up to the prescribed order with respect to the ordinary differential equation u(t) = f(u(t)) with vector field f and dependent variables u for a time step size dt.\n\nHere, u is assumed to be a vector of symbolic variables and f is assumed to be a vector of expressions in these variables for plain B-series. For B-series with colored trees, f must be a tuple of vectors of expressions in the variables u. Currently, symbolic variables from\n\nSymEngine.jl,\nSymPy.jl, and\nSymbolics.jl\n\nare supported.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#BSeries.modified_equation-Tuple{Any}","page":"API reference","title":"BSeries.modified_equation","text":"modified_equation(series_integrator)\n\nCompute the B-series of the modified equation of the time integration method with B-series series_integrator.\n\nGiven an ordinary differential equation (ODE) u(t) = f(u(t)) and a Runge-Kutta method, the idea is to interpret the numerical solution with given time step size as exact solution of a modified ODE u(t) = fₕ(u(t)). This method returns the B-series of h fₕ.\n\nnote: Normalization by elementary differentials\nThe coefficients of the B-series returned by this method need to be multiplied by a power of the time step divided by the symmetry of the rooted tree and multiplied by the corresponding elementary differential of the input vector field f. See also evaluate.\n\nReferences\n\nSection 3.2 of\n\nPhilippe Chartier, Ernst Hairer, Gilles Vilmart (2010) Algebraic Structures of B-series. Foundations of Computational Mathematics DOI: 10.1007/s10208-010-9065-1\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#BSeries.modified_equation-Tuple{RungeKuttaMethod, Any}","page":"API reference","title":"BSeries.modified_equation","text":"modified_equation(rk::RungeKuttaMethod, order)\nmodified_equation(A::AbstractMatrix, b::AbstractVector, c::AbstractVector,\n                  order)\n\nCompute the B-series of the modified_equation of the Runge-Kutta method rk with Butcher coefficients A, b, c up to the prescribed order.\n\nnote: Normalization by elementary differentials\nThe coefficients of the B-series returned by this method need to be multiplied by a power of the time step divided by the symmetry of the rooted tree and multiplied by the corresponding elementary differential of the input vector field f. See also evaluate.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#BSeries.modifying_integrator-NTuple{4, Any}","page":"API reference","title":"BSeries.modifying_integrator","text":"modifying_integrator(f, u, dt, series_integrator)\n\nCompute the B-series of the modifying_integrator equation of the time integration method with B-series series_integrator with respect to the ordinary differential equation u(t) = f(u(t)) with vector field f and dependent variables u for a time step size dt.\n\nHere, u is assumed to be a vector of symbolic variables and f is assumed to be a vector of expressions in these variables for plain B-series. For B-series with colored trees, f must be a tuple of vectors of expressions in the variables u. Currently, symbolic variables from\n\nSymEngine.jl,\nSymPy.jl, and\nSymbolics.jl\n\nare supported.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#BSeries.modifying_integrator-Tuple{Any, Any, Any, RungeKuttaMethod, Any}","page":"API reference","title":"BSeries.modifying_integrator","text":"modifying_integrator(f, u, dt, rk::RungeKuttaMethod, order)\nmodifying_integrator(f, u, dt,\n                     A::AbstractMatrix, b::AbstractVector, c::AbstractVector,\n                     order)\n\nCompute the B-series of the modifying_integrator equation of the Runge-Kutta method with Butcher coefficients A, b, c up to the prescribed order with respect to the ordinary differential equation u(t) = f(u(t)) with vector field f and dependent variables u for a time step size dt.\n\nHere, u is assumed to be a vector of symbolic variables and f is assumed to be a vector of expressions in these variables for plain B-series. For B-series with colored trees, f must be a tuple of vectors of expressions in the variables u. Currently, symbolic variables from\n\nSymEngine.jl,\nSymPy.jl, and\nSymbolics.jl\n\nare supported.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#BSeries.modifying_integrator-Tuple{Any}","page":"API reference","title":"BSeries.modifying_integrator","text":"modifying_integrator(series_integrator)\n\nCompute the B-series of a \"modifying integrator\" equation of the time integration method with B-series series_integrator.\n\nGiven an ordinary differential equation (ODE) u(t) = f(u(t)) and a Runge-Kutta method, the idea is to find a modified ODE u(t) = fₕ(u(t)) such that the numerical solution with given time step size is the exact solution of the original ODE. This method returns the B-series of h fₕ.\n\nnote: Normalization by elementary differentials\nThe coefficients of the B-series returned by this method need to be multiplied by a power of the time step divided by the symmetry of the rooted tree and multiplied by the corresponding elementary differential of the input vector field f. See also evaluate.\n\nReferences\n\nSection 3.2 of\n\nPhilippe Chartier, Ernst Hairer, Gilles Vilmart (2010) Algebraic Structures of B-series. Foundations of Computational Mathematics DOI: 10.1007/s10208-010-9065-1\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#BSeries.modifying_integrator-Tuple{RungeKuttaMethod, Any}","page":"API reference","title":"BSeries.modifying_integrator","text":"modifying_integrator(rk::RungeKuttaMethod, order)\nmodifying_integrator(A::AbstractMatrix, b::AbstractVector, c::AbstractVector,\n                     order)\n\nCompute the B-series of the modifying_integrator equation of the Runge-Kutta method with Butcher coefficients A, b, c up to the prescribed order.\n\nnote: Normalization by elementary differentials\nThe coefficients of the B-series returned by this method need to be multiplied by a power of the time step divided by the symmetry of the rooted tree and multiplied by the corresponding elementary differential of the input vector field f. See also evaluate.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#BSeries.order_of_accuracy-Tuple{TruncatedBSeries}","page":"API reference","title":"BSeries.order_of_accuracy","text":"order_of_accuracy(series; kwargs...)\n\nDetermine the order of accuracy of the B-series series. By default, the comparison with the coefficients of the exact solution is performed using isequal. If keyword arguments such as absolute/relative tolerances atol/rtol are given or floating point numbers are used, the comparison is performed using isapprox and the keyword arguments kwargs... are forwarded.\n\nSee also order, ExactSolution.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#BSeries.renormalize!-Tuple{Any}","page":"API reference","title":"BSeries.renormalize!","text":"renormalize!(series)\n\nThis function modifies a B-series by dividing each coefficient by the symmetry of the corresponding tree.\n\nwarning: Warning\nThis breaks assumptions made on the representation of a B-series. The modified B-series should not be passed to any other function assuming the default normalization.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#BSeries.substitute-Tuple{Any, Any, RootedTrees.AbstractRootedTree}","page":"API reference","title":"BSeries.substitute","text":"substitute(b, a, t::AbstractRootedTree)\n\nCompute the coefficient corresponding to the tree t of the B-series that is formed by substituting the B-series b into the B-series a. It is assumed that the B-series b has the coefficient zero of the empty tree.\n\nReferences\n\nSection 3.2 of\n\nPhilippe Chartier, Ernst Hairer, Gilles Vilmart (2010) Algebraic Structures of B-series. Foundations of Computational Mathematics DOI: 10.1007/s10208-010-9065-1\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#BSeries.substitute-Tuple{Any, Any}","page":"API reference","title":"BSeries.substitute","text":"substitute(b, a)\n\nSubstitute the B-series b into the B-series a. It is assumed that the B-series b has the coefficient zero of the empty tree.\n\nIn the notation of Chartier, Hairer and Vilmart (2010), we have substitute(b, a) = b ★ a.\n\nReferences\n\nSection 3.2 of\n\nPhilippe Chartier, Ernst Hairer, Gilles Vilmart (2010) Algebraic Structures of B-series. Foundations of Computational Mathematics DOI: 10.1007/s10208-010-9065-1\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#RootedTrees.order-Tuple{TruncatedBSeries}","page":"API reference","title":"RootedTrees.order","text":"order(series::TruncatedBSeries)\n\nThe maximal order of a rooted tree with non-vanishing coefficient in the truncated B-series series.\n\nSee also order_of_accuracy.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#RootedTrees.jl-API","page":"API reference","title":"RootedTrees.jl API","text":"","category":"section"},{"location":"api_reference/","page":"API reference","title":"API reference","text":"CurrentModule = RootedTrees","category":"page"},{"location":"api_reference/","page":"API reference","title":"API reference","text":"Modules = [RootedTrees]","category":"page"},{"location":"api_reference/#RootedTrees.RootedTrees","page":"API reference","title":"RootedTrees.RootedTrees","text":"RootedTrees\n\n(Image: Docs-stable) (Image: Docs-dev) (Image: Build Status) (Image: Coverage Status) (Image: codecov) (Image: License: MIT) (Image: DOI) (Image: Downloads)\n\nA collection of functionality around rooted trees to generate order conditions for Runge-Kutta methods in Julia. This package also provides basic functionality for BSeries.jl.\n\nAPI Documentation\n\nThe API of RootedTrees.jl is documented in the following. Additional information on each function is available in their docstrings and in the online documentation.\n\nConstruction\n\nRootedTrees are represented using level sequences, i.e., AbstractVectors containing the distances of the nodes from the root, see\n\nBeyer, Terry, and Sandra Mitchell Hedetniemi. \"Constant time generation of rooted trees\". SIAM Journal on Computing 9.4 (1980): 706-712. DOI: 10.1137/0209055\n\nRootedTrees can be constructed from their level sequence using\n\njulia> t = rootedtree([1, 2, 3, 2])\nRootedTree{Int64}: [1, 2, 3, 2]\n\nIn the notation of Butcher (Numerical Methods for ODEs, 2016), this tree can be written as [[τ] τ] or (τ ∘ τ) ∘ (τ ∘ τ), where ∘ is the non-associative Butcher product of RootedTrees, which is also implemented.\n\nTo get the representation of a RootedTree introduced by Butcher, use butcher_representation:\n\njulia> t = rootedtree([1, 2, 3, 4, 3, 3, 2, 2, 2, 2, 2])\nRootedTree{Int64}: [1, 2, 3, 4, 3, 3, 2, 2, 2, 2, 2]\n\njulia> butcher_representation(t)\n\"[[[τ]τ²]τ⁵]\"\n\nThere are also some simple plot recipes for Plots.jl. Thus, you can visualize a rooted tree t using plot(t) when using Plots.\n\nAdditionally, there is an un-exported function RootedTrees.latexify that can generate LaTeX code for a rooted tree t based on the LaTeX package forest. The relevant code that needs to be included in the preamble can be obtained from the docstring of RootedTrees.latexify (type ? and RootedTrees.latexify in the Julia REPL). The same format is used when you are using Latexify and their function latexify, see Latexify.jl.\n\nIteration over RootedTrees\n\nA RootedTreeIterator(order::Integer) can be used to iterate efficiently over all RootedTrees of a given order.\n\nBe careful that the iterator is stateful for efficiency reasons, so you might need to use copy appropriately, e.g.,\n\njulia> map(identity, RootedTreeIterator(4))\n4-element Array{RootedTrees.RootedTree{Int64,Array{Int64,1}},1}:\n RootedTree{Int64}: [1, 2, 2, 2]\n RootedTree{Int64}: [1, 2, 2, 2]\n RootedTree{Int64}: [1, 2, 2, 2]\n RootedTree{Int64}: [1, 2, 2, 2]\n\njulia> map(copy, RootedTreeIterator(4))\n4-element Array{RootedTrees.RootedTree{Int64,Array{Int64,1}},1}:\n RootedTree{Int64}: [1, 2, 3, 4]\n RootedTree{Int64}: [1, 2, 3, 3]\n RootedTree{Int64}: [1, 2, 3, 2]\n RootedTree{Int64}: [1, 2, 2, 2]\n\nFunctions on Trees\n\nThe usual functions on RootedTrees are implemented, cf. Butcher (Numerical Methods for ODEs, 2016).\n\norder(t::RootedTree): The order of a RootedTree, i.e., the length of its level sequence.\nσ(t::RootedTree) or symmetry(t): The symmetry σ of a rooted tree, i.e., the order of the group of automorphisms on a particular labelling (of the vertices) of t.\nγ(t::RootedTree) or density(t): The density γ(t) of a rooted tree, i.e., the product over all vertices of t of the order of the subtree rooted at that vertex.\nα(t::RootedTree): The number of monotonic labelings of t not equivalent under the symmetry group.\nβ(t::RootedTree): The total number of labelings of t not equivalent under the symmetry group.\n\nAdditionally, functions on trees connected to Runge-Kutta methods are implemented.\n\nelementary_weight(t, A, b, c): Compute the elementary weight Φ(t) of t::RootedTree for the Butcher coefficients A, b, c of a Runge-Kutta method.\nderivative_weight(t, A, b, c): Compute the derivative weight (ΦᵢD)(t) of t for the Butcher coefficients A, b, c of a Runge-Kutta method.\nresidual_order_condition(t, A, b, c): The residual of the order condition (Φ(t) - 1/γ(t)) / σ(t) with elementary weight Φ(t), density γ(t), and symmetry σ(t) of the rooted tree t for the Runge-Kutta method with Butcher coefficients A, b, c.\n\nBrief Changelog\n\nv2.16: The LaTeX printing of rooted trees changed to allow representing colored rooted trees. Please update your LaTeX preamble as described in the docstring of RootedTrees.latexify.\nv2.0: Rooted trees are considered up to isomorphisms introduced by shifting each coefficient of their level sequence by the same number.\n\nReferencing\n\nIf you use RootedTrees.jl for your research, please cite the paper\n\n@article{ketcheson2022computing,\n  title={Computing with {B}-series},\n  author={Ketcheson, David I and Ranocha, Hendrik},\n  journal={ACM Transactions on Mathematical Software},\n  year={2022},\n  month={12},\n  doi={10.1145/3573384},\n  eprint={2111.11680},\n  eprinttype={arXiv},\n  eprintclass={math.NA}\n}\n\nIn addition, you can also refer to RootedTrees.jl directly as\n\n@misc{ranocha2019rootedtrees,\n  title={{RootedTrees.jl}: {A} collection of functionality around rooted trees\n         to generate order conditions for {R}unge-{K}utta methods in {J}ulia\n         for differential equations and scientific machine learning ({SciM}L)},\n  author={Ranocha, Hendrik and contributors},\n  year={2019},\n  month={05},\n  howpublished={\\url{https://github.com/SciML/RootedTrees.jl}},\n  doi={10.5281/zenodo.5534590}\n}\n\n\n\n\n\n","category":"module"},{"location":"api_reference/#RootedTrees.AdditiveRungeKuttaMethod","page":"API reference","title":"RootedTrees.AdditiveRungeKuttaMethod","text":"AdditiveRungeKuttaMethod(rks)\nAdditiveRungeKuttaMethod(As, bs, cs=map(A -> vec(sum(A, dims=2)), As))\n\nRepresent an additive Runge-Kutta method with collections of Butcher coefficients As, bs, and cs. Alternatively, you can pass a collection of RungeKuttaMethods to the constructor. If the cs are not provided, the usual \"row sum\" requirement of consistency with autonomous problems is applied.\n\nAn additive Runge-Kutta method applied to the ODE problem\n\n  u(t) = sum_nu f^nu(t u(t))\n\nhas the form\n\nbeginaligned\n  y^i = u^n + Delta t sum_nu sum_j a^nu_ij f^nu(y^i) \n  u^n+1 = u^n + Delta t sum_nu sum_i b^nu_i f^nu(y^i)\nendaligned\n\nIn particular, additive Runge-Kutta methods are a superset of partitioned RK methods, which are applied to partitioned problems of the form\n\n  (u^1)(t) = f^1(t u^1 u^2)\n  quad\n  (u^2)(t) = f^2(t u^1 u^2)\n\nReferences\n\nA. L. Araujo, A. Murua, and J. M. Sanz-Serna. \"Symplectic Methods Based on Decompositions\". SIAM Journal on Numerical Analysis 34.5 (1997): 1926-1947. DOI: 10.1137/S0036142995292128\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#RootedTrees.BicoloredRootedTree","page":"API reference","title":"RootedTrees.BicoloredRootedTree","text":"BicoloredRootedTree{T<:Integer}\n\nRepresentation of bicolored rooted trees.\n\nSee also ColoredRootedTree, RootedTree, rootedtree.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#RootedTrees.BicoloredRootedTreeIterator","page":"API reference","title":"RootedTrees.BicoloredRootedTreeIterator","text":"BicoloredRootedTreeIterator(order::Integer)\n\nIterator over all bi-colored rooted trees of given order. The returned trees are views to an internal tree modified during the iteration. If the returned trees shall be stored or modified during the iteration, a copy has to be made.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#RootedTrees.ColoredRootedTree","page":"API reference","title":"RootedTrees.ColoredRootedTree","text":"ColoredRootedTree(level_sequence, color_sequence, is_canonical::Bool=false)\n\nRepresents a colored rooted tree using its level sequence. The single-colored version is RootedTree.\n\nSee also BicoloredRootedTree, rootedtree.\n\nwarning: Warning\nThis is a low-overhead and unsafe constructor. Please consider calling rootedtree instead.\n\nReferences\n\nTerry Beyer and Sandra Mitchell Hedetniemi. \"Constant time generation of rooted trees\". SIAM Journal on Computing 9.4 (1980): 706-712. DOI: 10.1137/0209055\nA. L. Araujo, A. Murua, and J. M. Sanz-Serna. \"Symplectic Methods Based on Decompositions\". SIAM Journal on Numerical Analysis 34.5 (1997): 1926–1947. DOI: 10.1137/S0036142995292128\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#RootedTrees.PartitionForestIterator","page":"API reference","title":"RootedTrees.PartitionForestIterator","text":"PartitionForestIterator(t::AbstractRootedTree, edge_set)\n\nLazy iterator representation of the partition_forest of the rooted tree t. Similar to RootedTreeIterator, you should copy the iterates if you want to store or modify them during the iteration since they may be views to internal caches.\n\nSee also partition_forest, partition_skeleton, and PartitionIterator.\n\nReferences\n\nSection 2.3 of\n\nPhilippe Chartier, Ernst Hairer, Gilles Vilmart (2010) Algebraic Structures of B-series. Foundations of Computational Mathematics DOI: 10.1007/s10208-010-9065-1\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#RootedTrees.PartitionIterator","page":"API reference","title":"RootedTrees.PartitionIterator","text":"PartitionIterator(t::AbstractRootedTree)\n\nIterator over all partition forests and skeletons of the rooted tree t. This is basically a pure iterator version of all_partitions. In particular, the partition forest may only be realized as an iterator. Similar to RootedTreeIterator, you should copy the iterates if you want to store or modify them during the iteration since they may be views to internal caches.\n\nSee also partition_forest, partition_skeleton, and PartitionForestIterator.\n\nReferences\n\nSection 2.3 of\n\nPhilippe Chartier, Ernst Hairer, Gilles Vilmart (2010) Algebraic Structures of B-series. Foundations of Computational Mathematics DOI: 10.1007/s10208-010-9065-1\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#RootedTrees.RootedTree","page":"API reference","title":"RootedTrees.RootedTree","text":"RootedTree(level_sequence, is_canonical::Bool=false)\n\nRepresents a rooted tree using its level sequence.\n\nwarning: Warning\nThis is a low-overhead and unsafe constructor. Please consider calling rootedtree instead.\n\nReferences\n\nTerry Beyer and Sandra Mitchell Hedetniemi. \"Constant time generation of rooted trees\". SIAM Journal on Computing 9.4 (1980): 706-712. DOI: 10.1137/0209055\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#RootedTrees.RootedTreeIterator","page":"API reference","title":"RootedTrees.RootedTreeIterator","text":"RootedTreeIterator(order::Integer)\n\nIterator over all rooted trees of given order. The returned trees are views to an internal tree modified during the iteration. If the returned trees shall be stored or modified during the iteration, a copy has to be made.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#RootedTrees.RosenbrockMethod","page":"API reference","title":"RootedTrees.RosenbrockMethod","text":"RosenbrockMethod(γ, A, b, c=vec(sum(A, dims=2)))\n\nRepresent a Rosenbrock (or Rosenbrock-Wanner, ROW) method with coefficients γ, A, b, and c. If c is not provided, the usual \"row sum\" requirement of consistency with autonomous problems is applied.\n\nReference\n\nErnst Hairer, Gerhard Wanner. Solving ordinary differential equations II: Stiff and differential-algebraic problems. Springer, 2010. Section IV.7\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#RootedTrees.RungeKuttaMethod","page":"API reference","title":"RootedTrees.RungeKuttaMethod","text":"RungeKuttaMethod(A, b, c=vec(sum(A, dims=2)))\n\nRepresent a Runge-Kutta method with Butcher coefficients A, b, and c. If c is not provided, the usual \"row sum\" requirement of consistency with autonomous problems is applied.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#RootedTrees.SplittingIterator","page":"API reference","title":"RootedTrees.SplittingIterator","text":"SplittingIterator(t::RootedTree)\n\nIterator over all splitting forests and subtrees of the rooted tree t. This is basically an iterator version of all_splittings.\n\nSee also partition_forest and partition_skeleton.\n\nReferences\n\nSection 2.2 of\n\nPhilippe Chartier, Ernst Hairer, Gilles Vilmart (2010) Algebraic Structures of B-series. Foundations of Computational Mathematics DOI: 10.1007/s10208-010-9065-1\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#RootedTrees.SubtreeIterator","page":"API reference","title":"RootedTrees.SubtreeIterator","text":"SubtreeIterator(t::AbstractRootedTree)\n\nLazy iterator representation of the subtrees of the rooted tree t. Similar to RootedTreeIterator, you should copy the iterates if you want to store or modify them during the iteration since they may be views to internal caches.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#Base.:==-Tuple{ColoredRootedTree, ColoredRootedTree}","page":"API reference","title":"Base.:==","text":"==(t1::ColoredRootedTree, t2::ColoredRootedTree)\n\nCompares two rooted trees based on their level (first) and color (second) sequences while considering equivalence classes given by different root indices.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Base.:==-Tuple{RootedTree, RootedTree}","page":"API reference","title":"Base.:==","text":"==(t1::RootedTree, t2::RootedTree)\n\nCompares two rooted trees based on their level sequences while considering equivalence classes given by different root indices.\n\nExamples\n\njulia> t1 = rootedtree([1, 2, 3]);\n\njulia> t2 = rootedtree([2, 3, 4]);\n\njulia> t3 = rootedtree([1, 2, 2]);\n\njulia> t1 == t2\ntrue\n\njulia> t1 == t3\nfalse\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Base.:∘-Tuple{RootedTree, RootedTree}","page":"API reference","title":"Base.:∘","text":"t1 ∘ t2\n\nThe non-associative Butcher product of rooted trees. It is formed by adding an edge from the root of t1 to the root of t2.\n\nReference: Section 301 of\n\nButcher, John Charles. Numerical methods for ordinary differential equations. John Wiley & Sons, 2016.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Base.isless-Tuple{ColoredRootedTree, ColoredRootedTree}","page":"API reference","title":"Base.isless","text":"isless(t1::ColoredRootedTree, t2::ColoredRootedTree)\n\nCompares two colored rooted trees using a lexicographical comparison of their level (first) and color (second) sequences while considering equivalence classes given by different root indices.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Base.isless-Tuple{RootedTree, RootedTree}","page":"API reference","title":"Base.isless","text":"isless(t1::RootedTree, t2::RootedTree)\n\nCompares two rooted trees using a lexicographical comparison of their level sequences while considering equivalence classes given by different root indices.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#RootedTrees.all_partitions-Tuple{RootedTree}","page":"API reference","title":"RootedTrees.all_partitions","text":"all_partitions(t::RootedTree)\n\nCreate all partition forests and skeletons of a rooted tree t. This returns vectors of the return values of partition_forest and partition_skeleton when looping over all possible edge sets.\n\nSee also PartitionIterator.\n\nReferences\n\nSection 2.3 of\n\nPhilippe Chartier, Ernst Hairer, Gilles Vilmart (2010) Algebraic Structures of B-series. Foundations of Computational Mathematics DOI: 10.1007/s10208-010-9065-1\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#RootedTrees.all_splittings-Tuple{RootedTree}","page":"API reference","title":"RootedTrees.all_splittings","text":"all_splittings(t::RootedTree)\n\nCreate all splitting forests and subtrees associated to ordered subtrees of a rooted tree t.\n\nSeee also SplittingIterator.\n\nReferences\n\nSection 2.2 of\n\nPhilippe Chartier, Ernst Hairer, Gilles Vilmart (2010) Algebraic Structures of B-series. Foundations of Computational Mathematics DOI: 10.1007/s10208-010-9065-1\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#RootedTrees.butcher_representation","page":"API reference","title":"RootedTrees.butcher_representation","text":"butcher_representation(t::RootedTree)\n\nReturns the representation of t::RootedTree introduced by Butcher as a string. Thus, the rooted tree consisting whose only vertex is the root itself is represented as τ. The representation of other trees is defined recursively; if t₁, t₂, ... tₙ are the subtrees of the rooted tree t, it is represented as t = [t₁ t₂ ... tₙ]. If multiple subtrees are the same, their number of occurrences is written as a power.\n\nExamples\n\njulia> rootedtree([1, 2, 3, 2]) |> butcher_representation\n\"[[τ]τ]\"\n\njulia> rootedtree([1, 2, 3, 3, 2]) |> butcher_representation\n\"[[τ²]τ]\"\n\nReferences\n\nSection 300 of\n\nButcher, John Charles. Numerical methods for ordinary differential equations. John Wiley & Sons, 2008.\n\n\n\n\n\n","category":"function"},{"location":"api_reference/#RootedTrees.canonical_representation!","page":"API reference","title":"RootedTrees.canonical_representation!","text":"canonical_representation!(t::AbstractRootedTree)\n\nChange the representation of the rooted tree t to the canonical one, i.e., the one with lexicographically biggest level sequence.\n\nSee also canonical_representation.\n\n\n\n\n\n","category":"function"},{"location":"api_reference/#RootedTrees.canonical_representation-Tuple{RootedTrees.AbstractRootedTree}","page":"API reference","title":"RootedTrees.canonical_representation","text":"canonical_representation(t::AbstractRootedTree)\n\nReturns a new tree using the canonical representation of the rooted tree t, i.e., the one with lexicographically biggest level sequence.\n\nSee also canonical_representation!.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#RootedTrees.check_canonical-Tuple{RootedTrees.AbstractRootedTree}","page":"API reference","title":"RootedTrees.check_canonical","text":"check_canonical(t::AbstractRootedTree)\n\nCheck whether t is in canonical representation.\n\nwarning: Internal interface\nThis function is considered to be an internal implementation detail and will not necessarily be stable.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#RootedTrees.count_trees-Tuple{Any}","page":"API reference","title":"RootedTrees.count_trees","text":"count_trees(order)\n\nCounts all rooted trees of order.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#RootedTrees.density-Tuple{RootedTrees.AbstractRootedTree}","page":"API reference","title":"RootedTrees.density","text":"γ(t::AbstractRootedTree)\ndensity(t::AbstractRootedTree)\n\nThe density γ(t) of a rooted tree, i.e., the product over all vertices of t of the order of the subtree rooted at that vertex.\n\nReference: Section 301 of\n\nButcher, John Charles. Numerical methods for ordinary differential equations. John Wiley & Sons, 2008.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#RootedTrees.derivative_weight-Tuple{ColoredRootedTree, AdditiveRungeKuttaMethod}","page":"API reference","title":"RootedTrees.derivative_weight","text":"derivative_weight(t::ColoredRootedTree, ark::AdditiveRungeKuttaMethod)\n\nCompute the derivative weight (ΦᵢD)(t) of the AdditiveRungeKuttaMethod ark for the colored rooted tree t.\n\nReferences\n\nA. L. Araujo, A. Murua, and J. M. Sanz-Serna. \"Symplectic Methods Based on Decompositions\". SIAM Journal on Numerical Analysis 34.5 (1997): 1926–1947. DOI: 10.1137/S0036142995292128\nButcher, John Charles. Numerical methods for ordinary differential equations. John Wiley & Sons, 2008. Section 312\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#RootedTrees.derivative_weight-Tuple{RootedTree, RosenbrockMethod}","page":"API reference","title":"RootedTrees.derivative_weight","text":"derivative_weight(t::RootedTree, ros::RosenbrockMethod)\n\nCompute the derivative weight (ΦᵢD)(t) of the RosenbrockMethod ros for the rooted tree t.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#RootedTrees.derivative_weight-Tuple{RootedTree, RungeKuttaMethod}","page":"API reference","title":"RootedTrees.derivative_weight","text":"derivative_weight(t::RootedTree, rk::RungeKuttaMethod)\n\nCompute the derivative weight (ΦᵢD)(t) of the RungeKuttaMethod rk with Butcher coefficients A, b, c for the rooted tree t.\n\nReference: Section 312 of\n\nButcher, John Charles. Numerical methods for ordinary differential equations. John Wiley & Sons, 2008.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#RootedTrees.elementary_weight-Tuple{ColoredRootedTree, AdditiveRungeKuttaMethod}","page":"API reference","title":"RootedTrees.elementary_weight","text":"elementary_weight(t::ColoredRootedTree, ark::AdditiveRungeKuttaMethod)\n\nCompute the elementary weight Φ(t) of the AdditiveRungeKuttaMethod ark for a colored rooted tree t.\n\nReferences\n\nA. L. Araujo, A. Murua, and J. M. Sanz-Serna. \"Symplectic Methods Based on Decompositions\". SIAM Journal on Numerical Analysis 34.5 (1997): 1926–1947. DOI: 10.1137/S0036142995292128\nButcher, John Charles. Numerical methods for ordinary differential equations. John Wiley & Sons, 2008. Section 312\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#RootedTrees.elementary_weight-Tuple{RootedTree, RosenbrockMethod}","page":"API reference","title":"RootedTrees.elementary_weight","text":"elementary_weight(t::RootedTree, ros::RosenbrockMethod)\n\nCompute the elementary weight Φ(t) of the RosenbrockMethod ros for a rooted tree t.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#RootedTrees.elementary_weight-Tuple{RootedTree, RungeKuttaMethod}","page":"API reference","title":"RootedTrees.elementary_weight","text":"elementary_weight(t::RootedTree, rk::RungeKuttaMethod)\nelementary_weight(t::RootedTree, A::AbstractMatrix, b::AbstractVector, c::AbstractVector)\n\nCompute the elementary weight Φ(t) of the RungeKuttaMethod rk with Butcher coefficients A, b, c for a rooted tree t`.\n\nReference: Section 312 of\n\nButcher, John Charles. Numerical methods for ordinary differential equations. John Wiley & Sons, 2008.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#RootedTrees.latexify-Tuple{RootedTree}","page":"API reference","title":"RootedTrees.latexify","text":"latexify(t::Union{RootedTree, BicoloredRootedTree})\n\nReturn a LaTeX representation of the rooted tree t. This makes use of the LaTeX package forest and assumes that you use the following LaTeX code in the preamble.\n\n% Classical and colored Butcher trees based on\n% https://tex.stackexchange.com/a/673436\n\\usepackage{forest}\n\\forestset{\n    whitenode/.style={draw,             circle, minimum size=0.5ex, inner sep=0pt},\n    blacknode/.style={draw, fill=black, circle, minimum size=0.5ex, inner sep=0pt},\n    colornode/.style={draw, fill=#1,    circle, minimum size=0.5ex, inner sep=0pt},\n    colornode/.default={red}\n}\n\\newcommand{\\blankforrootedtree}{\\rule{0pt}{0pt}}\n\\NewDocumentCommand\\rootedtree{o}{\\begin{forest}\n    for tree={grow'=90, thick, edge=thick, l sep=0.5ex, l=0pt, s sep=0.5ex},\n    delay={\n      where content={}{\n        for children={no edge, before drawing tree={for tree={y-=5pt}}}\n      }\n      {\n        where content={o}{content={\\blankforrootedtree}, whitenode}{\n          where content={.}{content={\\blankforrootedtree}, blacknode}{}\n        }\n      }\n    }\n    [#1]\n\\end{forest}}\n\n\nTo change the style of latexify to a human-readable Butcher-representation, you can use RootedTrees.set_latexify_style.\n\nExamples\n\njulia> rootedtree([1, 2, 2]) |> RootedTrees.latexify |> println\n\\rootedtree[.[.][.]]\n\njulia> rootedtree([1, 2, 3, 3, 2]) |> RootedTrees.latexify |> println\n\\rootedtree[.[.[.][.]][.]]\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#RootedTrees.normalize_root!","page":"API reference","title":"RootedTrees.normalize_root!","text":"normalize_root!(t::AbstractRootedTree, root=one(eltype(t.level_sequence)))\n\nNormalize the level sequence of the rooted tree t such that the root is set to root.\n\n\n\n\n\n","category":"function"},{"location":"api_reference/#RootedTrees.order-Tuple{RootedTrees.AbstractRootedTree}","page":"API reference","title":"RootedTrees.order","text":"order(t::AbstractRootedTree)\n\nThe order of a rooted tree t, i.e., the length of its level sequence.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#RootedTrees.partition_forest-Tuple{RootedTree, Any}","page":"API reference","title":"RootedTrees.partition_forest","text":"partition_forest(t::RootedTree, edge_set)\n\nForm the partition forest of the rooted tree t where edges marked with false in the edge_set are removed. The ith value in the Boolean iterable edge_set corresponds to the edge connecting node i+1 in the level sequence to its parent.\n\nSee also partition_skeleton, PartitionIterator, and PartitionForestIterator.\n\nReferences\n\nSection 2.3 of\n\nPhilippe Chartier, Ernst Hairer, Gilles Vilmart (2010) Algebraic Structures of B-series. Foundations of Computational Mathematics DOI: 10.1007/s10208-010-9065-1\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#RootedTrees.partition_skeleton-Tuple{RootedTrees.AbstractRootedTree, Any}","page":"API reference","title":"RootedTrees.partition_skeleton","text":"partition_skeleton(t::AbstractRootedTree, edge_set)\n\nForm the partition skeleton of the rooted tree t, i.e., the rooted tree obtained by contracting each tree of the partition forest to a single vertex and re-establishing the edges removed to obtain the partition forest.\n\nSee also partition_forest and PartitionIterator.\n\nReferences\n\nSection 2.3 (and Section 6.1 for colored trees) of\n\nPhilippe Chartier, Ernst Hairer, Gilles Vilmart (2010) Algebraic Structures of B-series. Foundations of Computational Mathematics DOI: 10.1007/s10208-010-9065-1\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#RootedTrees.residual_order_condition-Tuple{ColoredRootedTree, AdditiveRungeKuttaMethod}","page":"API reference","title":"RootedTrees.residual_order_condition","text":"residual_order_condition(t::ColoredRootedTree, ark::AdditiveRungeKuttaMethod)\n\nThe residual of the order condition   (Φ(t) - 1/γ(t)) / σ(t) with elementary_weight Φ(t), density γ(t), and symmetry σ(t) of the AdditiveRungeKuttaMethod ark for the colored rooted tree t.\n\nReferences\n\nA. L. Araujo, A. Murua, and J. M. Sanz-Serna. \"Symplectic Methods Based on Decompositions\". SIAM Journal on Numerical Analysis 34.5 (1997): 1926–1947. DOI: 10.1137/S0036142995292128\nButcher, John Charles. Numerical methods for ordinary differential equations. John Wiley & Sons, 2008. Section 312\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#RootedTrees.residual_order_condition-Tuple{RootedTree, RosenbrockMethod}","page":"API reference","title":"RootedTrees.residual_order_condition","text":"residual_order_condition(t::RootedTree, ros::RosenbrockMethod)\n\nThe residual of the order condition   (Φ(t) - 1/γ(t)) / σ(t) with elementary_weight Φ(t), density γ(t), and symmetry σ(t) of the RosenbrockMethod ros for the rooted tree t.\n\nReference\n\nErnst Hairer, Gerhard Wanner. Solving ordinary differential equations II: Stiff and differential-algebraic problems. Springer, 2010. Section IV.7\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#RootedTrees.residual_order_condition-Tuple{RootedTree, RungeKuttaMethod}","page":"API reference","title":"RootedTrees.residual_order_condition","text":"residual_order_condition(t::RootedTree, rk::RungeKuttaMethod)\n\nThe residual of the order condition   (Φ(t) - 1/γ(t)) / σ(t) with elementary_weight Φ(t), density γ(t), and symmetry σ(t) of the RungeKuttaMethod rk with Butcher coefficients A, b, c for the rooted tree t.\n\nReference: Section 315 of\n\nButcher, John Charles. Numerical methods for ordinary differential equations. John Wiley & Sons, 2008.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#RootedTrees.root_color-Tuple{ColoredRootedTree}","page":"API reference","title":"RootedTrees.root_color","text":"root_color(t::ColoredRootedTree)\n\nReturn the color of the root of t.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#RootedTrees.rootedtree!-Tuple{AbstractVector, AbstractVector}","page":"API reference","title":"RootedTrees.rootedtree!","text":"rootedtree!(level_sequence, color_sequence)\n\nConstruct a canonical ColoredRootedTree object from a level_sequence and a color_sequence which may be modified in this process. See also rootedtree.\n\nReferences\n\nTerry Beyer and Sandra Mitchell Hedetniemi. \"Constant time generation of rooted trees\". SIAM Journal on Computing 9.4 (1980): 706-712. DOI: 10.1137/0209055\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#RootedTrees.rootedtree!-Tuple{AbstractVector}","page":"API reference","title":"RootedTrees.rootedtree!","text":"rootedtree!(level_sequence)\n\nConstruct a canonical RootedTree object from a level_sequence which may be modified in this process. See also rootedtree.\n\nwarning: Warning\nThis may modify the level_sequence and further modifications of the level_sequence may invalidate the rooted tree returned by this function. Please consider calling rootedtree instead.\n\nReferences\n\nTerry Beyer and Sandra Mitchell Hedetniemi. \"Constant time generation of rooted trees\". SIAM Journal on Computing 9.4 (1980): 706-712. DOI: 10.1137/0209055\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#RootedTrees.rootedtree-Tuple{AbstractVector, AbstractVector}","page":"API reference","title":"RootedTrees.rootedtree","text":"rootedtree(level_sequence, color_sequence)\n\nConstruct a canonical ColoredRootedTree object from a level_sequence and a color_sequence, i.e., a vector of integers representing the levels of each node of the tree and a vector of associated colors (e.g., Bools or Integers).\n\nReferences\n\nTerry Beyer and Sandra Mitchell Hedetniemi. \"Constant time generation of rooted trees\". SIAM Journal on Computing 9.4 (1980): 706-712. DOI: 10.1137/0209055\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#RootedTrees.rootedtree-Tuple{AbstractVector}","page":"API reference","title":"RootedTrees.rootedtree","text":"rootedtree(level_sequence)\n\nConstruct a canonical RootedTree object from a level_sequence, i.e., a vector of integers representing the levels of each node of the tree.\n\nReferences\n\nTerry Beyer and Sandra Mitchell Hedetniemi. \"Constant time generation of rooted trees\". SIAM Journal on Computing 9.4 (1980): 706-712. DOI: 10.1137/0209055\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#RootedTrees.set_latexify_style-Tuple{String}","page":"API reference","title":"RootedTrees.set_latexify_style","text":"RootedTrees.set_latexify_style(style::String)\n\nSet the style of rooted trees when using latexify. Possible options are\n\n\"butcher\": print the butcher_representation of rooted trees\n\"forest\": use the LaTeX macro \\rootedtree described in the docstring of latexify\n\nThis system is based on Preferences.jl.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#RootedTrees.set_printing_style-Tuple{String}","page":"API reference","title":"RootedTrees.set_printing_style","text":"RootedTrees.set_printing_style(style::String)\n\nSet the printing style of rooted trees. Possible options are\n\n\"butcher\": print the butcher_representation of rooted trees\n\"sequence\": print the level sequence representation\n\nThis system is based on Preferences.jl.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#RootedTrees.subtrees-Tuple{ColoredRootedTree}","page":"API reference","title":"RootedTrees.subtrees","text":"subtrees(t::ColoredRootedTree)\n\nReturns a vector of all subtrees of t.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#RootedTrees.subtrees-Tuple{RootedTree}","page":"API reference","title":"RootedTrees.subtrees","text":"subtrees(t::RootedTree)\n\nReturns a vector of all subtrees of t.\n\nSee also SubtreeIterator.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#RootedTrees.symmetry-Tuple{RootedTrees.AbstractRootedTree}","page":"API reference","title":"RootedTrees.symmetry","text":"σ(t::AbstractRootedTree)\nsymmetry(t::AbstractRootedTree)\n\nThe symmetry σ of a rooted tree t, i.e., the order of the group of automorphisms on a particular labelling (of the vertices) of t.\n\nReference: Section 301 of\n\nButcher, John Charles. Numerical methods for ordinary differential equations. John Wiley & Sons, 2008.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#RootedTrees.unsafe_copyto!-Tuple{RootedTree, Any, RootedTree, Any, Any}","page":"API reference","title":"RootedTrees.unsafe_copyto!","text":"unsafe_copyto!(t_dst::AbstractRootedTree, dst_offset,\n               t_src::AbstractRootedTree, src_offset, N)\n\nCopy N nodes from t_src starting at offset src_offset to t_dst starting at offset dst_offset. The types of the rooted trees must match. For example, you cannot copy a ColoredRootedTree to a RootedTree.\n\nThis is an unsafe operation since the rooted tree t_dst will not necessarily be in canonical representation afterwards, even if the corresponding flag of t_dst is set. Use with caution!\n\nwarning: Internal interface\nThis function is considered to be an internal implementation detail and will not necessarily be stable.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#RootedTrees.unsafe_deleteat!-Tuple{RootedTree, Any}","page":"API reference","title":"RootedTrees.unsafe_deleteat!","text":"unsafe_deleteat!(t::AbstractRootedTree, i)\n\nDelete the node i from the rooted tree t. This is an unsafe operation since the rooted tree will not necessarily be in canonical representation afterwards, even if the corresponding flag of t is set. Use with caution!\n\nwarning: Internal interface\nThis function is considered to be an internal implementation detail and will not necessarily be stable.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#RootedTrees.unsafe_resize!-Tuple{RootedTree, Integer}","page":"API reference","title":"RootedTrees.unsafe_resize!","text":"unsafe_resize!(t::AbstractRootedTree, n::Integer)\n\nResize the rooted tree t to n nodes. This is an unsafe operation since the rooted tree will not necessarily be in canonical representation afterwards, even if the corresponding flag of t is set. Use with caution!\n\nwarning: Internal interface\nThis function is considered to be an internal implementation detail and will not necessarily be stable.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#RootedTrees.α-Tuple{RootedTrees.AbstractRootedTree}","page":"API reference","title":"RootedTrees.α","text":"α(t::AbstractRootedTree)\n\nThe number of monotonic labelings of t not equivalent under the symmetry group.\n\nReference: Section 302 of\n\nButcher, John Charles. Numerical methods for ordinary differential equations. John Wiley & Sons, 2008.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#RootedTrees.β-Tuple{RootedTrees.AbstractRootedTree}","page":"API reference","title":"RootedTrees.β","text":"β(t::AbstractRootedTree)\n\nThe total number of labelings of t not equivalent under the symmetry group.\n\nReference: Section 302 of\n\nButcher, John Charles. Numerical methods for ordinary differential equations. John Wiley & Sons, 2008.\n\n\n\n\n\n","category":"method"},{"location":"license/","page":"License","title":"License","text":"EditURL = \"https://github.com/ranocha/BSeries.jl/blob/main/LICENSE.md\"","category":"page"},{"location":"license/#License","page":"License","title":"License","text":"","category":"section"},{"location":"license/","page":"License","title":"License","text":"MIT LicenseCopyright (c) 2021-present Hendrik RanochaPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","category":"page"},{"location":"#BSeries.jl","page":"Home","title":"BSeries.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"BSeries.jl is a collection of functionality around B-series in Julia. See for example","category":"page"},{"location":"","page":"Home","title":"Home","text":"Philippe Chartier, Ernst Hairer, Gilles Vilmart (2010) Algebraic Structures of B-series. Foundations of Computational Mathematics DOI: 10.1007/s10208-010-9065-1","category":"page"},{"location":"","page":"Home","title":"Home","text":"BSeries.jl re-exports everything from RootedTrees.jl. However, if you rely on functionality from that package, you should also include it explicitly in your project dependencies to track breaking changes, since the version numbers of RootedTrees.jl and BSeries.jl are not necessarily synchronized.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The main API of BSeries.jl consists of the following components.","category":"page"},{"location":"","page":"Home","title":"Home","text":"B-series behave like AbstractDicts mapping (abstract) RootedTrees to coefficients.\nThe B-series of time integration methods such as Runge-Kutta methods can be constructed by the function bseries.\nVector space operations (addition/subtraction and multiplication by scalars) are available.\nThe algebraic structures of the composition law and the substitution law are implemented via compose and substitute.\nBackward error analysis can be performed via modified_equations and modifying_integrators.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Further information is provided in the following tutorials and API documentation.","category":"page"},{"location":"","page":"Home","title":"Home","text":"note: Note\nPlease note that B-series analysis is most conveniently applied to the autonomous form of ordinary differential equations (ODEs). Thus, BSeries.jl and RootedTrees.jl usually assume that time integration methods give the same result, independent of whether an ODE is written in an autonomous or a non-autonomous form. For Runge-Kutta methods, this means that the usual row-sum assumption is used.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"BSeries.jl is a registered Julia package. Thus, you can install it from the Julia REPL via","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> using Pkg; Pkg.add(\"BSeries\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"BSeries.jl works with Julia version 1.6 and newer.","category":"page"},{"location":"","page":"Home","title":"Home","text":"If you want to update BSeries.jl, you can use","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> using Pkg; Pkg.update(\"BSeries\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"As usual, if you want to update BSeries.jl and all other packages in your current project, you can execute","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> using Pkg; Pkg.update()","category":"page"},{"location":"#Referencing","page":"Home","title":"Referencing","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"If you use BSeries.jl for your research, please cite it using the bibtex entry","category":"page"},{"location":"","page":"Home","title":"Home","text":"@article{ketcheson2022computing,\n  title={Computing with {B}-series},\n  author={Ketcheson, David I and Ranocha, Hendrik},\n  journal={ACM Transactions on Mathematical Software},\n  year={2022},\n  month={12},\n  doi={10.1145/3573384},\n  eprint={2111.11680},\n  eprinttype={arXiv},\n  eprintclass={math.NA}\n}","category":"page"},{"location":"","page":"Home","title":"Home","text":"In addition, you can also refer to BSeries.jl directly as","category":"page"},{"location":"","page":"Home","title":"Home","text":"@misc{ranocha2021bseries,\n  title={{BSeries.jl}: {C}omputing with {B}-series in {J}ulia},\n  author={Ranocha, Hendrik and Ketcheson, David I},\n  year={2021},\n  month={09},\n  howpublished={\\url{https://github.com/ranocha/BSeries.jl}},\n  doi={10.5281/zenodo.5534602}\n}","category":"page"},{"location":"","page":"Home","title":"Home","text":"Please also cite the appropriate references for specific functions you use, which can be obtained from their docstrings.","category":"page"},{"location":"#License-and-contributing","page":"Home","title":"License and contributing","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This project is licensed under the MIT license (see License). Since it is an open-source project, we are very happy to accept contributions from the community. Please refer to the section Contributing for more details.","category":"page"},{"location":"tutorials/modified_equations/#tutorial-modified-equation","page":"Modified equations","title":"Modified equations","text":"","category":"section"},{"location":"tutorials/modified_equations/","page":"Modified equations","title":"Modified equations","text":"This tutorial describes the API of BSeries.jl related to the notion of modified equations. The main API entry point is the function modified_equation.","category":"page"},{"location":"tutorials/modified_equations/","page":"Modified equations","title":"Modified equations","text":"Given a first-order autonomous ordinary differential equation (ODE)","category":"page"},{"location":"tutorials/modified_equations/","page":"Modified equations","title":"Modified equations","text":"u(t) = f(u(t))","category":"page"},{"location":"tutorials/modified_equations/","page":"Modified equations","title":"Modified equations","text":"and a B-series time integration method, the idea is to interpret the numerical solution with given time step size h of the original ODE as the exact solution of the modified ODE","category":"page"},{"location":"tutorials/modified_equations/","page":"Modified equations","title":"Modified equations","text":"u(t) = f_h(u(t))","category":"page"},{"location":"tutorials/modified_equations/","page":"Modified equations","title":"Modified equations","text":"see for example [ChartierHairerVilmart2010].","category":"page"},{"location":"tutorials/modified_equations/#Lotka-Volterra-model,-explicit-Euler-method","page":"Modified equations","title":"Lotka-Volterra model, explicit Euler method","text":"","category":"section"},{"location":"tutorials/modified_equations/","page":"Modified equations","title":"Modified equations","text":"Here, we reproduce the example on p. 340 of [HairerLubichWanner2006]. Thus, we consider the explicit Euler method to solve the classical Lotka-Volterra model","category":"page"},{"location":"tutorials/modified_equations/","page":"Modified equations","title":"Modified equations","text":"p(t) = (2 - q) p\nquad\nq(t) = (p - 1) q","category":"page"},{"location":"tutorials/modified_equations/","page":"Modified equations","title":"Modified equations","text":"First, we set up the ODE and compute some numerical solutions using OrdinaryDiffEq.jl.","category":"page"},{"location":"tutorials/modified_equations/","page":"Modified equations","title":"Modified equations","text":"using OrdinaryDiffEq\n\nfunction f!(du, u, params, t)\n  p, q = u\n  dp = (2 - q) * p\n  dq = (p - 1) * q\n  du[1] = dp; du[2] = dq\n  return nothing\nend\n\nu0 = [1.5, 2.25]\ntspan = (0.0, 15.0)\node = ODEProblem(f!, u0, tspan)\n\ndt = 0.1\nsol_euler = solve(ode, Euler(), dt=dt)\nsol_ref = solve(ode, Tsit5())\nnothing # hide","category":"page"},{"location":"tutorials/modified_equations/","page":"Modified equations","title":"Modified equations","text":"We use the in-place form of the right-hand side (RHS) and follow the Julia convention to indicate that f! modifies its first argument du by appending ! to its name. Thus, calling f!(du, u, params, t) will compute the RHS at the state u and time t (unused) and store the result in du. The argument params could be used to pass additional parameters explicitly, which we do not need in this case.","category":"page"},{"location":"tutorials/modified_equations/","page":"Modified equations","title":"Modified equations","text":"Next, we look at some phase space plots of the numerical solution.","category":"page"},{"location":"tutorials/modified_equations/","page":"Modified equations","title":"Modified equations","text":"using LaTeXStrings, Plots\n\nfig = plot(xguide=L\"$q$\", yguide=L\"$p$\")\ndefault(linewidth=2)\nplot!(fig, sol_ref, idxs=(2, 1), label=\"Reference solution\")\nscatter!(fig, last.(sol_euler.u), first.(sol_euler.u),\n         label=\"Explicit Euler, dt = $dt\")\nplot!(fig, xlims=(0.0, 9.0), ylims=(0.0, 5.0))\n\nsavefig(fig, \"lotka_volterra_explicit_euler.svg\"); nothing # hide","category":"page"},{"location":"tutorials/modified_equations/","page":"Modified equations","title":"Modified equations","text":"(Image: )","category":"page"},{"location":"tutorials/modified_equations/","page":"Modified equations","title":"Modified equations","text":"The exact solution of this problem is periodic, but the explicit Euler method produces an unstable trajectory. Here, we used an especially large time step to more clearly illustrate what will follow, but the qualitative behavior is the same for any time step size.","category":"page"},{"location":"tutorials/modified_equations/","page":"Modified equations","title":"Modified equations","text":"Next, we will derive the \"modified equation\" (see modified_equation) of the explicit Euler method and solve this new ODE to high accuracy. The perturbed system takes the form of a power series in the time step size dt, and in order to compute with it we will truncate it at a certain order.","category":"page"},{"location":"tutorials/modified_equations/","page":"Modified equations","title":"Modified equations","text":"Here, we use Symbolics.jl for the symbolic computations.","category":"page"},{"location":"tutorials/modified_equations/","page":"Modified equations","title":"Modified equations","text":"using BSeries, StaticArrays, Symbolics\n\nfunction solve_modified_equation(ode, truncation_orders, dt)\n  # Explicit Euler method\n  A = @SMatrix [0//1;;]\n  b = @SArray [1//1]\n  c = @SArray [0//1]\n\n  # Setup of symbolic variables\n  @variables dt_sym\n  u_sym = @variables p q\n  # Create `f_sym` as a vector `similar` to `u_sym` to store symbolic expressions.\n  # Then, call the in-place function `f!` to write the RHS to `f_sym`.\n  f_sym = similar(u_sym); f!(f_sym, u_sym, nothing, nothing)\n\n  sol_euler = solve(ode, Euler(), dt=dt)\n\n  fig = plot(xguide=L\"$q$\", yguide=L\"$p$\")\n  default(linewidth=2)\n  scatter!(fig, last.(sol_euler.u), first.(sol_euler.u),\n          label=\"Explicit Euler, dt = $dt\")\n\n  for truncation_order in truncation_orders\n    series = modified_equation(f_sym, u_sym, dt_sym, A, b, c, truncation_order)\n    series = Symbolics.substitute.(series, dt_sym => dt)\n    modified_f, _ = build_function(series, u_sym, expression=Val(false))\n    modified_ode = ODEProblem((u, params, t) -> modified_f(u), ode.u0, ode.tspan)\n    modified_sol = solve(modified_ode, Tsit5())\n    plot!(fig, modified_sol, idxs=(2, 1),\n          label=\"Modified ODE, order $(truncation_order-1)\")\n  end\n  fig\nend\n\nfig = solve_modified_equation(ode, 2, dt)\n\nsavefig(fig, \"lotka_volterra_explicit_euler_modified1.svg\"); nothing # hide","category":"page"},{"location":"tutorials/modified_equations/","page":"Modified equations","title":"Modified equations","text":"(Image: )","category":"page"},{"location":"tutorials/modified_equations/","page":"Modified equations","title":"Modified equations","text":"The exact solution of the Lotka-Volterra model is periodic, but Euler's method generates a solution with growing amplitude. The modified equations accurately predict this.","category":"page"},{"location":"tutorials/modified_equations/","page":"Modified equations","title":"Modified equations","text":"Now we go to the next order and increase the time step size dt slightly.","category":"page"},{"location":"tutorials/modified_equations/","page":"Modified equations","title":"Modified equations","text":"fig = solve_modified_equation(ode, 2:3, 0.11)\n\nsavefig(fig, \"lotka_volterra_explicit_euler_modified2.svg\"); nothing # hide","category":"page"},{"location":"tutorials/modified_equations/","page":"Modified equations","title":"Modified equations","text":"(Image: )","category":"page"},{"location":"tutorials/modified_equations/","page":"Modified equations","title":"Modified equations","text":"Using a larger step size, we see that the first-order modified equations are not fully accurate, but by including the O(h^2) terms we get much better accuracy at late times. Let's keep going.","category":"page"},{"location":"tutorials/modified_equations/","page":"Modified equations","title":"Modified equations","text":"fig = solve_modified_equation(ode, 2:4, 0.12)\n\nsavefig(fig, \"lotka_volterra_explicit_euler_modified3.svg\"); nothing # hide","category":"page"},{"location":"tutorials/modified_equations/","page":"Modified equations","title":"Modified equations","text":"(Image: )","category":"page"},{"location":"tutorials/modified_equations/#Lotka-Volterra-model,-symplectic-Euler-method","page":"Modified equations","title":"Lotka-Volterra model, symplectic Euler method","text":"","category":"section"},{"location":"tutorials/modified_equations/","page":"Modified equations","title":"Modified equations","text":"Next, we reproduce the second part of the example on p. 340 of [HairerLubichWanner2006]. Thus, we consider the symplectic (IMEX) Euler method to solve the classical Lotka-Volterra model","category":"page"},{"location":"tutorials/modified_equations/","page":"Modified equations","title":"Modified equations","text":"p(t) = (2 - q) p\nquad\nq(t) = (p - 1) q","category":"page"},{"location":"tutorials/modified_equations/","page":"Modified equations","title":"Modified equations","text":"Here, the implicit part will be applied to p and the explicit part to q.","category":"page"},{"location":"tutorials/modified_equations/","page":"Modified equations","title":"Modified equations","text":"First, we set up the ODE and compute a reference solution using OrdinaryDiffEq.jl.","category":"page"},{"location":"tutorials/modified_equations/","page":"Modified equations","title":"Modified equations","text":"using OrdinaryDiffEq, Plots, LaTeXStrings\n\nfunction f!(du, u, params, t)\n  q, p = u\n  du[1] = (p - 1) * q # dq/dt\n  du[2] = (2 - q) * p # dp/dt\n  return nothing\nend\n\nu0 = [6.5, 1.0]\ntspan = (0.0, 15.0)\node = ODEProblem(f!, u0, tspan)\nsol_ref = solve(ode, Tsit5(), abstol=1.0e-9, reltol=1.0e-9)\n\nfig = plot(xguide=L\"$q$\", yguide=L\"$p$\")\ndefault(linewidth=2)\nplot!(fig, sol_ref, idxs=(1, 2), label=\"Reference solution\")\n\nsavefig(fig, \"lotka_volterra_reference.svg\"); nothing # hide","category":"page"},{"location":"tutorials/modified_equations/","page":"Modified equations","title":"Modified equations","text":"(Image: )","category":"page"},{"location":"tutorials/modified_equations/","page":"Modified equations","title":"Modified equations","text":"Next, we apply a symplectic (implicit-explicit, IMEX) Euler method to this problem. Given an additively partitioned ODE","category":"page"},{"location":"tutorials/modified_equations/","page":"Modified equations","title":"Modified equations","text":"u(t) = f^1(u) + f^2(u)","category":"page"},{"location":"tutorials/modified_equations/","page":"Modified equations","title":"Modified equations","text":"the symplectic/IMEX Euler method we are interested in is","category":"page"},{"location":"tutorials/modified_equations/","page":"Modified equations","title":"Modified equations","text":"beginaligned\n  y^1 = u^n + Delta t f^1(y^1) \n  u^n+1 = u^n + Delta t f^1(y^1) + Delta t f^2(y^1)\nendaligned","category":"page"},{"location":"tutorials/modified_equations/","page":"Modified equations","title":"Modified equations","text":"There is an IMEXEuler method in OrdinaryDiffEq.jl. However, this is a multistep variant using the update","category":"page"},{"location":"tutorials/modified_equations/","page":"Modified equations","title":"Modified equations","text":"u^n+1 = u^n + Delta t f^1(u^n+1) + Delta t f^2(u^n)","category":"page"},{"location":"tutorials/modified_equations/","page":"Modified equations","title":"Modified equations","text":"and not an additive Runge-Kutta method, see also OrdinaryDiffEq.jl#1590. Thus, we implement our own symplectic Euler method for this specific problem.","category":"page"},{"location":"tutorials/modified_equations/","page":"Modified equations","title":"Modified equations","text":"function imex_euler_lotka_volterra(u0, tspan, dt)\n  @assert tspan[1] < tspan[2]\n  @assert dt > 0\n\n  # setup solution arrays\n  qs = [u0[1]]\n  sizehint!(qs, round(Int, (tspan[2] - tspan[1]) / dt))\n  ps = [u0[2]]\n  sizehint!(ps, length(qs))\n\n  t = tspan[1]\n  while t < tspan[2]\n    qold = qs[end]\n    pold = ps[end]\n\n    # ARK, p implicit\n    pnew = pold / (1 + dt * (qold - 2))\n    qnew = qold + dt * (pnew - 1) * qold\n\n    # ARK, q implicit\n    #qnew = qold / (1 + dt * (1 - pold))\n    #pnew = pold + dt * (2 - qnew) * pold\n\n    # Multistep version of Ascher, Ruuth, Wetton (1995), p implicit\n    #qnew = qold + dt * (pold - 1) * qold\n    #pnew = pold / (1 + dt * (qnew - 2))\n\n    # Multistep version of Ascher, Ruuth, Wetton (1995), q implicit\n    #pnew = pold + dt * (2 - qold) * pold\n    #qnew = qold / (1 + dt * (1 - pnew))\n\n    push!(qs, qnew)\n    push!(ps, pnew)\n    t += dt\n  end\n\n  return qs, ps\nend\n\ndt = 0.12\nqs, ps = imex_euler_lotka_volterra(ode.u0, ode.tspan, dt)\nscatter!(fig, qs, ps, label=\"Symplectic Euler, dt = $dt\")\n\nsavefig(fig, \"lotka_volterra_symplectic_euler.svg\"); nothing # hide","category":"page"},{"location":"tutorials/modified_equations/","page":"Modified equations","title":"Modified equations","text":"(Image: )","category":"page"},{"location":"tutorials/modified_equations/","page":"Modified equations","title":"Modified equations","text":"The exact solution of this problem is periodic. Due to its structure-preserving properties, the symplectic Euler method also produces a stable trajectory.","category":"page"},{"location":"tutorials/modified_equations/","page":"Modified equations","title":"Modified equations","text":"Next, we will derive the modified equation of the symplectic Euler method and solve this new ODE to high accuracy. The perturbed system takes the form of a power series in the time step size dt, and in order to compute with it we will truncate it at a certain order.","category":"page"},{"location":"tutorials/modified_equations/","page":"Modified equations","title":"Modified equations","text":"Again, we use Symbolics.jl for the symbolic computations.","category":"page"},{"location":"tutorials/modified_equations/","page":"Modified equations","title":"Modified equations","text":"using BSeries, StaticArrays, Symbolics\n\nex_euler = RungeKuttaMethod(\n  @SMatrix([0]), @SVector [1]\n)\nim_euler = RungeKuttaMethod(\n  @SMatrix([1]), @SVector [1]\n)\nark = AdditiveRungeKuttaMethod([im_euler, ex_euler])\n\n@variables dt_sym\nu_sym = @variables q, p\nf1_sym = [0, (2 - q) * p] # p implicit\nf2_sym = [(p - 1) * q, 0] # q explicit\nf_sym = (f1_sym, f2_sym)\n\nfor truncation_order in 2:3\n  series_integrator = bseries(ark, truncation_order)\n  series = modified_equation(f_sym, u_sym, dt_sym, series_integrator)\n  series = Symbolics.substitute.(series, dt_sym => dt)\n  modified_f, _ = build_function(series, u_sym, expression=Val(false))\n  modified_ode = ODEProblem((u, params, t) -> modified_f(u), ode.u0, ode.tspan)\n  modified_sol = solve(modified_ode, Tsit5(), abstol=1.0e-9, reltol=1.0e-9)\n  plot!(fig, modified_sol, idxs=(1, 2),\n        label=\"Modified equation, order $(truncation_order-1)\")\nend\n\nfig\nsavefig(fig, \"lotka_volterra_symplectic_euler_modified.svg\"); nothing # hide","category":"page"},{"location":"tutorials/modified_equations/","page":"Modified equations","title":"Modified equations","text":"(Image: )","category":"page"},{"location":"tutorials/modified_equations/#Nonlinear-pendulum,-Störmer-Verlet-method","page":"Modified equations","title":"Nonlinear pendulum, Störmer-Verlet method","text":"","category":"section"},{"location":"tutorials/modified_equations/","page":"Modified equations","title":"Modified equations","text":"Let's reproduce the example shown in Figure 4.1 of [HairerLubichWanner2003]. Thus, we consider the dynamical ODE system describing a nonlinear pendulum as","category":"page"},{"location":"tutorials/modified_equations/","page":"Modified equations","title":"Modified equations","text":"q(t) = v\nquad\nv(t) = -sin(q)","category":"page"},{"location":"tutorials/modified_equations/","page":"Modified equations","title":"Modified equations","text":"Note that [HairerLubichWanner2003] use the order q, v of the variables (position and velocity) but OrdinaryDiffEq.jl requires the order v, q for dynamical ODE systems. Thus, we need to reverse the order of variables from time to time.","category":"page"},{"location":"tutorials/modified_equations/","page":"Modified equations","title":"Modified equations","text":"First, we set up the ODE system and compute a reference solution as well as the numerical solution obtained by the classical Störmer-Verlet method.","category":"page"},{"location":"tutorials/modified_equations/","page":"Modified equations","title":"Modified equations","text":"using OrdinaryDiffEq, LaTeXStrings, Plots\n\nf1(v, q, params, t) = -sin(q)\nf2(v, q, params, t) = v\nv0 = 1.0\nq0 = -1.2\ntspan = (0.0, 55.0)\node = DynamicalODEProblem(f1, f2, v0, q0, tspan)\n\ndt = 1.1\nalg = VerletLeapfrog()\nsol_baseline = solve(ode, alg, dt=dt)\nsol_ref = solve(ode, Tsit5(), abstol=1.0e-9, reltol=1.0e-9)\n\nfig = plot(xguide=L\"$q$\", yguide=L\"$v$\")\ndefault(linewidth=2)\nplot!(fig, sol_ref, idxs=(2, 1), label=\"Reference solution\")\nscatter!(fig, last.(sol_baseline.u), first.(sol_baseline.u),\n         label=\"Störmer-Verlet, dt = $dt\")\n\nsavefig(fig, \"pendulum_original.svg\"); nothing # hide","category":"page"},{"location":"tutorials/modified_equations/","page":"Modified equations","title":"Modified equations","text":"(Image: )","category":"page"},{"location":"tutorials/modified_equations/","page":"Modified equations","title":"Modified equations","text":"The exact solution of this problem is periodic. Since the Störmer-Verlet method is symplectic, it captures this qualitative property of the exact solution very well. However, we can see that the numerical solution trajectory does not really match the reference solution. Indeed, numerical errors pollute the solution and the numerical approximation is closer to a solution of a modified equation. We can compute the first terms of this modified equations as follows. First, we need to set up the time integration method in a form usable by BSeries.jl. For this, we interpret it as an additive Runge-Kutta method as follows.","category":"page"},{"location":"tutorials/modified_equations/","page":"Modified equations","title":"Modified equations","text":"using BSeries\n\n# Störmer-Verlet method as additive RK method, see\n# Hairer, Lubich, Wanner (2002)\n# Geometric numerical integration\n# Table II.2.1\nAs = [\n    [0 0; 1//2 1//2],\n    [1//2 0; 1//2 0]\n]\nbs = [\n    [1//2, 1//2],\n    [1//2, 1//2]\n]\nark = AdditiveRungeKuttaMethod(As, bs)","category":"page"},{"location":"tutorials/modified_equations/","page":"Modified equations","title":"Modified equations","text":"Next, we can set up the symbolic part. Note that we use the order q, v here instead of v, q used above.","category":"page"},{"location":"tutorials/modified_equations/","page":"Modified equations","title":"Modified equations","text":"using Symbolics\n\n# Set up symbolic equation\n@variables dt_sym\nu_sym = @variables q, v\nfq_sym = [f2(reverse(u_sym)..., nothing, nothing), 0]\nfv_sym = [0, f1(reverse(u_sym)..., nothing, nothing)]\nf_sym = (fq_sym, fv_sym)\n\n# Compute B-series of the numerical integrator and the modified equation\nseries_integrator = bseries(ark, 3)\nseries = modified_equation(f_sym, u_sym, dt_sym, series_integrator)\n\n@show series[1]\n@show series[2]\nnothing # hide","category":"page"},{"location":"tutorials/modified_equations/","page":"Modified equations","title":"Modified equations","text":"You can compare this result to eq. (4.8) of [HairerLubichWanner2003]. Next, we can solve the modified differential equations with high precision as follows.","category":"page"},{"location":"tutorials/modified_equations/","page":"Modified equations","title":"Modified equations","text":"for truncation_order in 3:2:5\n  local series_integrator = bseries(ark, truncation_order)\n  local series = modified_equation(f_sym, u_sym, dt_sym, series_integrator)\n  series = Symbolics.substitute.(series, dt_sym => dt)\n  modified_f, _ = build_function(series, u_sym, expression=Val(false))\n  modified_ode = ODEProblem((u, params, t) -> modified_f(u), [q0, v0], ode.tspan)\n  modified_sol = solve(modified_ode, Tsit5(), abstol=1.0e-9, reltol=1.0e-9)\n  plot!(fig, modified_sol, idxs=(1, 2),\n        label=\"Modified equation, order $(truncation_order-1)\")\nend\nfig\n\nsavefig(fig, \"pendulum_modified.svg\"); nothing # hide","category":"page"},{"location":"tutorials/modified_equations/","page":"Modified equations","title":"Modified equations","text":"(Image: )","category":"page"},{"location":"tutorials/modified_equations/","page":"Modified equations","title":"Modified equations","text":"You can see that the high-precision solutions of the modified equations match the numerical solution obtained by the Störmer-Verlet method very well. In fact, the fourth-order modified equation is even a bit more accurate than the second-order one.","category":"page"},{"location":"tutorials/modified_equations/#Modified-equation-of-the-average-vector-field-method","page":"Modified equations","title":"Modified equation of the average vector field method","text":"","category":"section"},{"location":"tutorials/modified_equations/","page":"Modified equations","title":"Modified equations","text":"Here, we reproduce Example 1 of [CelledoniMcLachlanOwrenQuispel2010]. First, we create the B-series of the average vector field method as described in the tutorial on creating B-series.","category":"page"},{"location":"tutorials/modified_equations/","page":"Modified equations","title":"Modified equations","text":"using BSeries\n\nseries = bseries(5) do t, series\n    if order(t) in (0, 1)\n        return 1 // 1\n    else\n        v = 1 // 1\n        n = 0\n        for subtree in SubtreeIterator(t)\n            v *= series[subtree]\n            n += 1\n        end\n        return v / (n + 1)\n    end\nend","category":"page"},{"location":"tutorials/modified_equations/","page":"Modified equations","title":"Modified equations","text":"Next, we compute the coefficients of its modified equation.","category":"page"},{"location":"tutorials/modified_equations/","page":"Modified equations","title":"Modified equations","text":"coefficients = modified_equation(series)","category":"page"},{"location":"tutorials/modified_equations/","page":"Modified equations","title":"Modified equations","text":"Remember that the coefficients of the B-series need to be divided by the symmetry of the rooted trees to get the final expressions.","category":"page"},{"location":"tutorials/modified_equations/#References","page":"Modified equations","title":"References","text":"","category":"section"},{"location":"tutorials/modified_equations/","page":"Modified equations","title":"Modified equations","text":"[HairerLubichWanner2003]: ","category":"page"},{"location":"tutorials/modified_equations/","page":"Modified equations","title":"Modified equations","text":"Ernst Hairer, Christian Lubich, Gerhard Wanner (2003)   Geometric numerical integration illustrated by the Störmer-Verlet method.   DOI: 10.1017/S0962492902000144","category":"page"},{"location":"tutorials/modified_equations/","page":"Modified equations","title":"Modified equations","text":"[HairerLubichWanner2006]: ","category":"page"},{"location":"tutorials/modified_equations/","page":"Modified equations","title":"Modified equations","text":"Ernst Hairer, Christian Lubich, Gerhard Wanner (2006)   Geometric Numerical Integration.   DOI: 10.1007/3-540-30666-8","category":"page"},{"location":"tutorials/modified_equations/","page":"Modified equations","title":"Modified equations","text":"[ChartierHairerVilmart2010]: ","category":"page"},{"location":"tutorials/modified_equations/","page":"Modified equations","title":"Modified equations","text":"Philippe Chartier, Ernst Hairer, Gilles Vilmart (2010)   Algebraic Structures of B-series.   Foundations of Computational Mathematics   DOI: 10.1007/s10208-010-9065-1","category":"page"},{"location":"tutorials/modified_equations/","page":"Modified equations","title":"Modified equations","text":"[CelledoniMcLachlanOwrenQuispel2010]: ","category":"page"},{"location":"tutorials/modified_equations/","page":"Modified equations","title":"Modified equations","text":"Elena Celledoni, Robert I. McLachlan, Brynjulf Owren, and G. R. W. Quispel (2010)   Energy-preserving integrators and the structure of B-series.   Foundations of Computational Mathematics   DOI: 10.1007/s10208-010-9073-1","category":"page"}]
}
